{
  "class": "Workflow",
  "cwlVersion": "v1.2",
  "doc": "**V-pipe 2.99.2 for SARS-CoV-2** is a workflow for analysing high throughput SARS-CoV-2 sequencing data [1]. **V-pipe** integrates several tools for the analysis of viral high throughput sequencing data. It allows for assessing viral diversity at the level of SNVs, short variant sequences (or local haplotypes) and long-range haplotypes (or global haplotypes) [2]. **V-pipe** is highly customisable for analysing different viruses and can be used in various configuration setups (using different aligners, variant callers and processing steps). **V-pipe 2.99.2 for SARS-CoV-2** is  implementation of default **V-pipe** configuration setup specific for analysing SARS-CoV-2 sequences. This configuration uses **bwa** for alignment and **ShoRAH** (Short Reads Assembly into Haplotypes) for calling SNVs. The variant calling in this configuration is done against the reference instead of the cohort's consensus. It also includes preprocessing steps using **Prinseq Lite**, consensus and visualisation steps. This configuration was implemented as described in the V-pipe tutorial for SARS-CoV-2 [3]. **V-pipe 2.99.2 for SARS-CoV-2** has been successfully used for detecting new SARS-CoV-2 mutations from wastewater samples where individual low-frequency mutations were called based on local haplotype reconstruction using **ShoRAH** [4]. \n\nTo run the workflow following inputs are required:\n* **Raw FASTQ files** - raw reads in FASTQ or FASTQ.GZ format;\n* **Input reference** - V-pipe recommends using NC_045512.2 as a reference sequence;\n* **Reference Index TAR** - BWA index TAR archive built for specific reference (using BWA INDEX tool);\n* **Read length** - read length of input reads. \n\nOptionally following inputs can be provided which will be used for creating graphical reports:\n* **GFF files** - GFF annotations files (example [GFF files](https://github.com/cbg-ethz/V-pipe/tree/master/resources/sars-cov-2/gffs) from V-pipe SARS-CoV-2 resources);\n* **Metainfo file** - metainformation for the GFF and primers files in YAML format (example [metainfo file](https://github.com/cbg-ethz/V-pipe/blob/master/resources/sars-cov-2/metainfo.yaml) from V-pipe SARS-CoV-2 resources);\n* **Phylogeny file** - FASTA file with sequences which will be used for building phylogeny tree (example [phylogeny file](https://github.com/cbg-ethz/V-pipe/blob/master/resources/sars-cov-2/phylogeny/selected_covid_sequences.fasta) from V-pipe SARS-CoV-2 resources);\n* **Primers file** - table with primers in TSV format (example [ARTIC bioinformatics primers for nanopore sequencing of nCoV2019](https://github.com/cbg-ethz/V-pipe/blob/master/resources/sars-cov-2/primers/nCoV-2019.tsv)).\n\nStandard WF outputs are:\n* **Output alignment** - output BAM file;\n* **ShoRAH shotgun: VCF file with variants** - VCF file containing called SNVs;\n* **ShoRAH shotgun: CSV file with variants** - CSV file containing called SNVs;\n* **SNV calling HTML report** - visual report for SNV calling;\n* **Alignment HTML report** - visual report for read alignment and phylogeny;\n* **Bcftools Consensus: Consensus majority sequence** - consensus majority sequence with indels;\n* **Bcftools Consensus: Consensus ambiguous sequence** - consensus ambiguous sequence with indels;\n* **Consensus sequences majority** - consensus sequences including the majority bases from **Output alignment** file;\n* **Consensus sequences majority deletions** - consensus sequences including the majority bases from **Output alignment** file with deletions;\n* **Consensus ambiguous reference sequences** - consensus sequences including the ambiguous bases from **Output alignment** file;\n* **Consensus sequences ambiguous deletions** - consensus sequences including the ambiguous bases from **Output alignment** file with deletions.\n\nFollowing tool versions are used in the **V-pipe 2.99.2 for SARS-CoV-2** workflow:\n- **Prinseq Lite 0.20.40**\n- **BWA MEM 0.7.17**\n- **Samtools 1.10** (**View**, **Sort** and **Index**)\n- **smallgenomeutilities 0.3.6** (**aln2basecnt**, **extract_coverage_intervals** and **extract_consensus**)\n- **ShoRAH shotgun 1.99.2** (**Bcftools 1.10.2** functions are used together with **ShoRAH**)\n- **Bcftools 1.13** (**Mpileup**, **Call**, **Norm**, **Filter**, **Index** and **Consensus**)\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n***Please note that any cloud infrastructure costs resulting from app and pipeline executions, including the use of public apps, are the sole responsibility of you as a user. To avoid excessive costs, please read the app description carefully and set the app parameters and execution settings accordingly.***\n\n### Common Use Cases\n\n**V-pipe 2.99.2 for SARS-CoV-2** can be used for analysing high throughput SARS-CoV-2 sequencing data. It can be used for calling individual low-frequency mutations for detecting new SARS-CoV-2 variants. This specific workflow setup has been used for analysing SARS-CoV-2 sequences in wastewater samples for detection and surveillance of SARS-CoV-2 genomic variants [4]. For detecting mutation co-occurrence, **Cojac cooc-mutbamscan** can be used after **V-pipe 2.99.2 for SARS-CoV-2** to analyse **Output alignment** files as described in the previously mentioned publication [4]. **Cojac cooc-mutbamscan** is available in the public apps gallery.\n\n### Changes Introduced by Seven Bridges\n* This workflow is a specific implementation of **V-pipe** workflow when run with [default configuration file for SARS-CoV-2](https://cbg-ethz.github.io/V-pipe/tutorial/sars-cov2/) with additional parameter `visualization = True` included so the visualisation reports are created on the output.\n* In order to run this workflow for multiple samples in parallel on the platform, several steps (Basecount/Consensus sequence/SNV/Consensus/Visualisation) were wrapped as an inner workflow so it can be scattered over alignment files from multiple samples.\n* **BWA INDEX** step was excluded from the original workflow setup, as it is recommended for the user to run this tool separately for specific input reference and then  provide it on the **Reference Index TAR** input of **V-pipe 2.99.2 for SARS-CoV-2** workflow. **BWA INDEX** version 0.7.17 should be used for creating **Reference Index TAR**, which is available in public apps gallery.\n* **Singleton read** input was added as some parameters for filtering BAM files are different when singleton reads are provided on the input. When the input is set to `True`,  the input parameters for the **Samtools View** step are changed.\n* **SBG Pair FASTQs by Metadata** was added to the workflow so the FASTQ files from the same samples are paired and analysed together.\n*  In the original implementation **BWA MEM** step has the **extra** input parameter where the user can add additional input parameters which are not used by default in the alignment step. In the **V-pipe 2.99.2 for SARS-CoV-2** workflow the **extra** parameter is not included; instead, all the input parameter options for **BWA MEM** are exposed to the user so they can be set differently if needed.\n* Some of the original steps in the workflow have been separated into several steps, eg. **SAM2BAM** has been separated into two steps: **Samtools Sort** and **Samtools Index** and **bwa_align** has been separated into **BWA MEM** and **Samtools View**.\n* In the original workflow implementation **BWA MEM** `-R` input, for setting the read group header, is neither exposed nor used. The **Create RG from file metadata** input was added in this wrapper and the input will, when set to `True`, take information from **Raw FASTQ files** metadata and set the read group header based on that information. When set to `True`: the **Platform** metadata field for the output alignments will be automatically set to \"Illumina\" unless it is present in **Raw FASTQ files** metadata; the read group ID will be set to \u20181\u2019, and if the workflow is run on multiple samples, the tool will assign the read group ID according to the order of the scattered folders; and **Sample ID**, **Library ID** and **Platform unit ID** will be inferred from metadata.\n* **Read length** in the original implementation is provided through a TSV file for each sample, and can be different for each of them. In the Seven Bridges implementation, this was changed, as this information is provided on the **Read length** input and can only have one value. This means that only samples with the same read length can be processed together. For different read lengths separate tasks have to be run.\n\n### Common Issues and Important Notes\n\n* Each file provided on the **Raw FASTQ files** input must have the following metadata fields set: **Sample ID** and **Paired-end**.\n* **GFF files**, **Metainfo file**, **Phylogeny file** and **Primers file** are used only for the visualisation step in the workflow. If not provided, the visualisation reports will be the only outputs affected by lack of that information.\n* The workflow is scattered using **Sample ID**.\n* Default instance for this workflow is  c4.2xlarge. But when run with multiple samples, if required, it can be changed to a custom instance with more cores for parallel processing through the **Execution settings** tab on the task page.\n* Testing and validation of the workflow was carried out with a small SARS-CoV-2 data set provided on the [V-pipe GitHub repo](https://github.com/cbg-ethz/V-pipe/tree/master/tests/data/sars-cov-2) and with real data obtained from SRA: [SRR10903401](https://trace.ncbi.nlm.nih.gov/Traces/sra/?run=SRR10903401) and [SRR10903402](https://trace.ncbi.nlm.nih.gov/Traces/sra/?run=SRR10903402) as described in the [V-pipe tutorial for SARS-CoV-2](https://cbg-ethz.github.io/V-pipe/tutorial/sars-cov2/).\n\n\n### Limitations\nThe workflow was tested with data used in the [V-pipe tutorial for SARS-CoV-2](https://cbg-ethz.github.io/V-pipe/tutorial/sars-cov2/).\n\n\n### Performance Benchmarking\nBelow is a table describing the runtimes and task costs for two sets of input files. First one included two samples (2 FASTQ  files each), which were obtained from SRA: [SRR10903401](https://trace.ncbi.nlm.nih.gov/Traces/sra/?run=SRR10903401) and [SRR10903402](https://trace.ncbi.nlm.nih.gov/Traces/sra/?run=SRR10903402). As these files are usually quite small in size compared to human data, to benchmark the workflow for more challenging use cases, we created a second set with ten mock samples, where SRR10903401 files were duplicated and their names and **Sample ID** metadata were changed to new mock IDs. This way we could see how the workflow will perform with more samples, especially with scattered tools and on different instances.\n\n| Experiment type |  Duration | Cost on demand (Instances + Attached Disks) | AWS instance type |\n|:--------------:|:---------:|:----------:|:------:|\n| RNA-Seq - two samples |  20min   | $0.18 ($0.13 + $0.05) | c4.2xlarge |\n| RNA-Seq - two samples | 11min   | $0.16 ($0.13 + $0.03) | c5.4xlarge |\n| RNA-Seq - ten samples | 45min   | $0.41 ($0.30 + $0.10) | c4.2xlarge |\n| RNA-Seq - ten samples | 17min   | $0.23 ($0.19 + $0.04) | c5.4xlarge |\n| RNA-Seq - ten samples | 10min   | $0.30 ($0.27 + $0.02) | c5.9xlarge |\n\n*Cost can be significantly reduced by using\u00a0**spot instances**. Visit the\u00a0[knowledge center](https://docs.sevenbridges.com/docs/about-spot-instances)\u00a0for more details.*\n\n\n\n### Portability\n**V-pipe 2.99.2 for SARS-CoV-2** was tested with cwltool version 3.1.20210816212154. The `in_reads`, `in_reference`, `reference_index_tar`, `gff_files`, `metainfo_file`, `phylogeny_file`, `primers_file` and `read_length` inputs were provided in the job.yaml/job.json file and used for testing.\n\n\n### References\n[1] [V-pipe for SARS-CoV-2 documentation](https://cbg-ethz.github.io/V-pipe/sars-cov-2/)\n\n[2] [V-pipe publication](https://academic.oup.com/bioinformatics/article/37/12/1673/6104816)\n\n[3] [V-pipe for SARS-CoV-2 tutorial](https://cbg-ethz.github.io/V-pipe/tutorial/sars-cov2/)\n\n[4] [Detection and surveillance of SARS-CoV-2 genomic variants in wastewater](https://www.medrxiv.org/content/10.1101/2021.01.08.21249379v2.full)",
  "label": "V-pipe 2.99.2 for SARS-CoV-2",
  "$namespaces": {
    "sbg": "https://sevenbridges.com"
  },
  "inputs": [
    {
      "id": "in_reads",
      "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
      "type": "File[]",
      "label": "Raw FASTQ files",
      "doc": "FASTQ file.",
      "sbg:x": -819.212158203125,
      "sbg:y": 139.60118103027344
    },
    {
      "id": "reference_index_tar",
      "sbg:fileTypes": "TAR",
      "type": "File",
      "label": "Reference Index TAR",
      "doc": "Reference fasta file with its BWA index files packed in a TAR archive.",
      "sbg:x": -824,
      "sbg:y": -162.57957458496094
    },
    {
      "id": "in_reference",
      "sbg:fileTypes": "FASTA",
      "type": "File",
      "label": "Input reference",
      "doc": "Reference file.",
      "sbg:x": 275.9764099121094,
      "sbg:y": 327.8919372558594
    },
    {
      "id": "read_length",
      "type": "int",
      "label": "Read length",
      "doc": "Read length.",
      "sbg:x": -820.6365356445312,
      "sbg:y": -15.640471458435059
    },
    {
      "id": "not_paired_reads",
      "type": "boolean?",
      "label": "Singleton read",
      "doc": "Set to True if Raw fastq files are not paired reads.",
      "sbg:toolDefaultValue": "False",
      "sbg:x": -828.0608520507812,
      "sbg:y": -307.1414489746094
    },
    {
      "id": "gff_files",
      "sbg:fileTypes": "GTF, GFF3, GFF",
      "type": "File[]?",
      "label": "GFF files",
      "doc": "GFF files.",
      "sbg:x": 277.3398742675781,
      "sbg:y": 465.4223937988281
    },
    {
      "id": "metainfo_file",
      "sbg:fileTypes": "YAML",
      "type": "File?",
      "label": "Metainfo file",
      "doc": "Metainfo file.",
      "sbg:x": 253.36346435546875,
      "sbg:y": -421.9135437011719
    },
    {
      "id": "phylogeny_file",
      "sbg:fileTypes": "FASTA",
      "type": "File?",
      "label": "Phylogeny file",
      "doc": "Phylogeny file.",
      "sbg:x": 253.36346435546875,
      "sbg:y": -560.75927734375
    },
    {
      "id": "primers_file",
      "sbg:fileTypes": "TSV",
      "type": "File?",
      "label": "Primers file",
      "doc": "Primers file.",
      "sbg:x": 260.30255126953125,
      "sbg:y": -694.3339233398438
    },
    {
      "id": "extra",
      "type": "string?",
      "label": "Extra command line options for PRINSEQ Lite",
      "doc": "Additional command line options. They can be provided as string with multiple prefixes and values. Default value for V-pipe workflow is -ns_max_n 4 -min_qual_mean 30 -trim_qual_left 30 -trim_qual_right 30 -trim_qual_window 10.",
      "sbg:toolDefaultValue": "-ns_max_n 4 -min_qual_mean 30 -trim_qual_left 30 -trim_qual_right 30 -trim_qual_window 10",
      "sbg:exposed": true
    },
    {
      "id": "trim_percent_cutoff",
      "type": "float?",
      "label": "Trimming cutoff",
      "doc": "Read-length threshold that should be applied during the quality trimming as a percentage.",
      "sbg:toolDefaultValue": "0.8",
      "sbg:exposed": true
    },
    {
      "id": "shift",
      "type": "int?",
      "label": "Shift",
      "doc": "ShoRAH performs local haplotype reconstruction on windows of the read alignment. The overlap between these windows is defined by the window shifts.",
      "sbg:toolDefaultValue": "3",
      "sbg:exposed": true
    },
    {
      "id": "alpha",
      "type": "float?",
      "label": "Alpha",
      "doc": "Hyperparameter used for instantiating a new cluster.",
      "sbg:toolDefaultValue": "0.1",
      "sbg:exposed": true
    },
    {
      "id": "ignore_indels",
      "type": "boolean?",
      "label": "Ignore indels",
      "doc": "Ignore SNVs adjacent to indels.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "coverage",
      "type": "int?",
      "label": "Coverage",
      "doc": "Omit windows with coverage less than this value.",
      "sbg:toolDefaultValue": "0",
      "sbg:exposed": true
    },
    {
      "id": "posterior_threshold",
      "type": "float?",
      "label": "Posterior threshold",
      "doc": "Posterior threshold.",
      "sbg:toolDefaultValue": "0.9",
      "sbg:exposed": true
    },
    {
      "id": "covint",
      "type": "int?",
      "label": "Intervals coverage",
      "doc": "Minimum read depth. A region spanning the reference genome is returned if `coverage` is set to 0.\".",
      "sbg:toolDefaultValue": "50",
      "sbg:exposed": true
    },
    {
      "id": "mask_coverage_threshold",
      "type": "int?",
      "label": "Mask coverage threshold",
      "doc": "Mask coverage threshold. Default is 10.",
      "sbg:toolDefaultValue": "10",
      "sbg:exposed": true
    },
    {
      "id": "ambiguous_base_coverage_threshold",
      "type": "float?",
      "label": "Ambiguous base coverage threshold",
      "doc": "Frequency threshold to include a variant in computation of ambiguous code.",
      "sbg:toolDefaultValue": "0.05",
      "sbg:exposed": true
    },
    {
      "id": "min_read_depth_1",
      "type": "int?",
      "label": "Minimum read depth per window",
      "doc": "Minimum read depth per window (default: 50).",
      "sbg:toolDefaultValue": "50",
      "sbg:exposed": true
    },
    {
      "id": "liberal_shift",
      "type": "boolean?",
      "label": "Apply a more liberal shift",
      "doc": "Indicate whether to apply a more liberal shift on intervals' right-endpoint (default: True).",
      "sbg:toolDefaultValue": "True",
      "sbg:exposed": true
    },
    {
      "id": "overlap",
      "type": [
        "null",
        {
          "type": "enum",
          "symbols": [
            "True",
            "False"
          ],
          "name": "overlap"
        }
      ],
      "label": "Overlap",
      "doc": "Construct intervals based on overlapping windows of the read alignment. By default, regions with high coverage are built based on the position-wise read depth.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "max_coverage",
      "type": "int?",
      "label": "Maximum coverage",
      "doc": "Maximum coverage.",
      "sbg:toolDefaultValue": "10000",
      "sbg:exposed": true
    },
    {
      "id": "min_read_depth",
      "type": "int?",
      "label": "Minimum read depth",
      "doc": "Minimum read depth for reporting variants per locus (default: 50).",
      "sbg:toolDefaultValue": "50",
      "sbg:exposed": true
    },
    {
      "id": "min_phred_qual",
      "type": "int?",
      "label": "Minimum phred quality score",
      "doc": "Minimum phred quality score a base has to reach to be counted (default: 15).",
      "sbg:toolDefaultValue": "15",
      "sbg:exposed": true
    },
    {
      "id": "min_freq",
      "type": "float?",
      "label": "Minimum frequency",
      "doc": "Minimum frequency for an ambiguous nucleotide (default: 0.05).",
      "sbg:toolDefaultValue": "0.05",
      "sbg:exposed": true
    },
    {
      "id": "read_count",
      "type": "int?",
      "label": "Read count threshold",
      "doc": "Read count below which ambiguous base 'n' is reported (default: 5).",
      "sbg:toolDefaultValue": "5",
      "sbg:exposed": true
    },
    {
      "id": "minimum_seed_length",
      "type": "int?",
      "label": "Minimum seed length",
      "doc": "Minimum seed length for BWA MEM.",
      "sbg:toolDefaultValue": "19",
      "sbg:exposed": true
    },
    {
      "id": "dropoff",
      "type": "int?",
      "label": "Dropoff",
      "doc": "Off-diagonal X-dropoff.",
      "sbg:toolDefaultValue": "100",
      "sbg:exposed": true
    },
    {
      "id": "select_seeds",
      "type": "float?",
      "label": "Select seeds",
      "doc": "Look for internal seeds inside a seed longer than {-k} * FLOAT.",
      "sbg:toolDefaultValue": "1.5",
      "sbg:exposed": true
    },
    {
      "id": "seed_occurrence_for_the_3rd_round",
      "type": "int?",
      "label": "Seed occurrence",
      "doc": "Seed occurrence for the 3rd round seeding.",
      "sbg:toolDefaultValue": "20",
      "sbg:exposed": true
    },
    {
      "id": "skip_seeds",
      "type": "int?",
      "label": "Skip seeds",
      "doc": "Skip seeds with more than a given number (INT) of occurrences.",
      "sbg:toolDefaultValue": "500",
      "sbg:exposed": true
    },
    {
      "id": "drop_chains_fraction",
      "type": "float?",
      "label": "Drop chains fraction",
      "doc": "Drop chains shorter than a given fraction (FLOAT) of the longest overlapping chain.",
      "sbg:toolDefaultValue": "0.50",
      "sbg:exposed": true
    },
    {
      "id": "discard_chain_length",
      "type": "int?",
      "label": "Discard chain length",
      "doc": "Discard a chain if seeded bases are shorter than a given number (INT).",
      "sbg:toolDefaultValue": "0",
      "sbg:exposed": true
    },
    {
      "id": "mate_rescue_rounds",
      "type": "string?",
      "label": "Mate rescue rounds",
      "doc": "Perform at the most a given number (INT) of rounds of mate rescues for each read.",
      "sbg:toolDefaultValue": "50",
      "sbg:exposed": true
    },
    {
      "id": "skip_mate_rescue",
      "type": "boolean?",
      "label": "Skip mate rescue",
      "doc": "Skip mate rescue.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "skip_pairing",
      "type": "boolean?",
      "label": "Skip pairing",
      "doc": "Skip pairing; mate rescue is performed unless -S also in use.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "discard_exact_matches",
      "type": "boolean?",
      "label": "Discard exact matches",
      "doc": "Discard full-length exact matches.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "score_for_a_sequence_match",
      "type": "int?",
      "label": "Score for a sequence match",
      "doc": "Score for a sequence match, which scales options -TdBOELU unless overridden.",
      "sbg:toolDefaultValue": "1",
      "sbg:exposed": true
    },
    {
      "id": "mismatch_penalty",
      "type": "int?",
      "label": "Mismatch penalty",
      "doc": "Penalty for a mismatch.",
      "sbg:toolDefaultValue": "4",
      "sbg:exposed": true
    },
    {
      "id": "smart_pairing_in_input_fastq",
      "type": "boolean?",
      "label": "Smart pairing",
      "doc": "Smart pairing in input FASTQ file (ignoring in2.fq).",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "insert_string_to_header",
      "type": "string?",
      "label": "Insert string to header",
      "doc": "Insert STR to output header if it starts with \"@\".",
      "sbg:exposed": true
    },
    {
      "id": "ignore_alt_file",
      "type": "boolean?",
      "label": "Ignore ALT file",
      "doc": "Treat ALT contigs as part of the primary assembly (i.e. ignore <idxbase>.alt file).",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "minimum_output_score",
      "type": "int?",
      "label": "Minimum alignment score",
      "doc": "Minimum alignment score for a read to be outputted in SAM/BAM/CRAM.",
      "sbg:toolDefaultValue": "30",
      "sbg:exposed": true
    },
    {
      "id": "output_alignments",
      "type": "boolean?",
      "label": "Output alignments",
      "doc": "Output all alignments for SE or unpaired PE.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "append_comment",
      "type": "boolean?",
      "label": "Append comment",
      "doc": "Append FASTA/FASTQ comment to the output file.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "output_header",
      "type": "boolean?",
      "label": "Output header",
      "doc": "Output the reference FASTA header in the XR tag.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "use_soft_clipping",
      "type": "boolean?",
      "label": "Use soft clipping",
      "doc": "Use soft clipping for supplementary alignments.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "mark_shorter",
      "type": "boolean?",
      "label": "Mark shorter",
      "doc": "Mark shorter split hits as secondary.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "gap_open_penalties",
      "type": "int[]?",
      "label": "Gap open penalties",
      "doc": "Gap open penalties for deletions and insertions. \nThis array can't have more than two values.",
      "sbg:toolDefaultValue": "[6,6]",
      "sbg:exposed": true
    },
    {
      "id": "gap_extension_penalties",
      "type": "int[]?",
      "label": "Gap extension",
      "doc": "Gap extension penalty; a gap of size k cost '{-O} + {-E}*k'. \nThis array can't have more than two values.",
      "sbg:toolDefaultValue": "[1,1]",
      "sbg:exposed": true
    },
    {
      "id": "clipping_penalty",
      "type": "int[]?",
      "label": "Clipping penalty",
      "doc": "Penalty for 5'- and 3'-end clipping.",
      "sbg:toolDefaultValue": "[5,5]",
      "sbg:exposed": true
    },
    {
      "id": "unpaired_read_penalty",
      "type": "int?",
      "label": "Unpaired read penalty",
      "doc": "Penalty for an unpaired read pair.",
      "sbg:toolDefaultValue": "17",
      "sbg:exposed": true
    },
    {
      "id": "read_type",
      "type": [
        "null",
        {
          "type": "enum",
          "symbols": [
            "pacbio",
            "ont2d",
            "intractg"
          ],
          "name": "read_type"
        }
      ],
      "label": "Sequencing technology-specific settings",
      "doc": "Sequencing technology-specific settings; Setting -x changes multiple parameters unless overridden. \npacbio: -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0  (PacBio reads to ref). \nont2d: -k14 -W20 -r10 -A1 -B1 -O1 -E1 -L0  (Oxford Nanopore 2D-reads to ref).\nintractg: -B9 -O16 -L5  (intra-species contigs to ref).",
      "sbg:toolDefaultValue": "null",
      "sbg:exposed": true
    },
    {
      "id": "output_in_xa",
      "type": "int[]?",
      "label": "Output in XA",
      "doc": "If there are < number (INT) of hits with a score >80% of the max score, output all in XA. \nThis array should have no more than two values.",
      "sbg:toolDefaultValue": "[5, 200]",
      "sbg:exposed": true
    },
    {
      "id": "speficy_distribution_parameters",
      "type": "float[]?",
      "label": "Specify distribution parameters",
      "doc": "Specify the mean, standard deviation (10% of the mean if absent), max (4 sigma from the mean if absent), and min of the insert size distribution. \nFR orientation only. \nThis array can have maximum of four values, where the first two should be specified as FLOAT and the last two as INT.",
      "sbg:toolDefaultValue": "inferred",
      "sbg:exposed": true
    },
    {
      "id": "band_width",
      "type": "int?",
      "label": "Band width",
      "doc": "Band width for banded alignment.",
      "sbg:toolDefaultValue": "100",
      "sbg:exposed": true
    },
    {
      "id": "deduplication",
      "type": [
        "null",
        {
          "type": "enum",
          "symbols": [
            "None",
            "MarkDuplicates",
            "RemoveDuplicates"
          ],
          "name": "deduplication"
        }
      ],
      "label": "PCR duplicate detection",
      "doc": "Use Biobambam2 for finding duplicates on sequence reads.",
      "sbg:toolDefaultValue": "None",
      "sbg:exposed": true
    },
    {
      "id": "split_alignment_primary",
      "type": "boolean?",
      "label": "Split alignment - smallest coordinate as primary",
      "doc": "For split alignment, take the alignment with the smallest coordinate as primary.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "mapQ_of_suplementary",
      "type": "boolean?",
      "label": "Don't modify mapQ",
      "doc": "Don't modify mapQ of supplementary alignments.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    },
    {
      "id": "num_input_bases_in_each_batch",
      "type": "int?",
      "label": "Number of input bases to process",
      "doc": "Process a given number (INT) of input bases in each batch regardless of nThreads (for reproducibility).",
      "sbg:exposed": true
    },
    {
      "id": "create_rg",
      "type": "boolean?",
      "label": "Create RG from file metadata",
      "doc": "If set to True, the RG string will be created from values pulled from file metadata.",
      "sbg:toolDefaultValue": "False",
      "sbg:exposed": true
    }
  ],
  "outputs": [
    {
      "id": "indexed_data_file",
      "outputSource": [
        "samtools_index_1_10/indexed_data_file"
      ],
      "sbg:fileTypes": "BAM, CRAM",
      "type": "File[]?",
      "label": "Output alignment",
      "doc": "Output BAM file along with its index as secondary file.",
      "sbg:x": 1214.9371337890625,
      "sbg:y": -371.2102355957031
    },
    {
      "id": "snv_html_file",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/snv_html_file"
      ],
      "sbg:fileTypes": "HTML",
      "type": "File[]?",
      "label": "SNV callling HTML report",
      "doc": "SNV callling HTML report.",
      "sbg:x": 1212.677734375,
      "sbg:y": -226.60118103027344
    },
    {
      "id": "out_vcf",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/out_vcf"
      ],
      "sbg:fileTypes": "VCF",
      "type": "File[]?",
      "label": "ShoRAH shotgun: VCF file with variants",
      "doc": "VCF file with variants.",
      "sbg:x": 1216.4656982421875,
      "sbg:y": 139.1512908935547
    },
    {
      "id": "out_csv",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/out_csv"
      ],
      "sbg:fileTypes": "CSV",
      "type": "File[]?",
      "label": "ShoRAH shotgun: CSV file with variants",
      "doc": "Variants in CSV format.",
      "sbg:x": 1219.465576171875,
      "sbg:y": 259.36346435546875
    },
    {
      "id": "alignment_html_file",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/alignment_html_file"
      ],
      "sbg:fileTypes": "HTML",
      "type": "File[]?",
      "label": "Alignment HTML report",
      "doc": "Alignment HTML report.",
      "sbg:x": 1235.2532958984375,
      "sbg:y": 890.8683471679688
    },
    {
      "id": "out_reference_majority",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/output_reference_majority"
      ],
      "sbg:fileTypes": "FASTA",
      "type": "File[]?",
      "label": "Bcftools Consensus: Consensus majority sequence",
      "doc": "Bcftools consensus majority sequence obtained by applying variants from VCF file with variants to the Input reference FASTA file.",
      "sbg:x": 1215.3026123046875,
      "sbg:y": -91.36345672607422
    },
    {
      "id": "out_reference_ambiguous",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/output_reference_ambiguous"
      ],
      "sbg:fileTypes": "FASTA",
      "type": "File[]?",
      "label": "Bcftools Consensus: Consensus ambiguous sequence",
      "doc": "Bcftools consensus ambiguous sequence obtained by applying variants from VCF file with variants to the Input reference FASTA file.",
      "sbg:x": 1215.42431640625,
      "sbg:y": 19.54616928100586
    },
    {
      "id": "out_consensus_major_seq",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/out_consensus_major_seq"
      ],
      "sbg:fileTypes": "FASTA",
      "type": "File[]?",
      "label": "Consensus sequences majority",
      "doc": "Consensus sequences including the majority base as FASTA files from smallgenomeutilities extract_consensus.",
      "sbg:x": 1220.5147705078125,
      "sbg:y": 387.7878112792969
    },
    {
      "id": "out_consensus_major_dels_seq",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/out_consensus_major_dels_seq"
      ],
      "sbg:fileTypes": "FASTA",
      "type": "File[]?",
      "label": "Consensus sequences majority deletions",
      "doc": "Consensus sequences including the majority base as FASTA files with deletions from smallgenomeutilities extract_consensus.",
      "sbg:x": 1232.24560546875,
      "sbg:y": 512.6365356445312
    },
    {
      "id": "out_consensus_ambig_seq",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/out_consensus_ambig_seq"
      ],
      "sbg:fileTypes": "FASTA",
      "type": "File[]?",
      "label": "Consensus ambiguous reference sequences",
      "doc": "Consensus sequences including the ambiguous bases as FASTA files from smallgenomeutilities extract_consensus.",
      "sbg:x": 1232,
      "sbg:y": 644
    },
    {
      "id": "out_consensus_ambig_dels_seq",
      "outputSource": [
        "v_pipe_basecount_consensus_sequence_snv_visualisation/out_consensus_ambig_dels_seq"
      ],
      "sbg:fileTypes": "FASTA",
      "type": "File[]?",
      "label": "Consensus sequences ambiguous deletions",
      "doc": "Consensus sequences including the ambiguous bases as FASTA files with deletions from smallgenomeutilities extract_consensus.",
      "sbg:x": 1231.5186767578125,
      "sbg:y": 769
    }
  ],
  "steps": [
    {
      "id": "gunzip_and_extract",
      "in": [
        {
          "id": "in_reads",
          "source": "in_reads"
        }
      ],
      "out": [
        {
          "id": "out_reads_raw"
        },
        {
          "id": "out_reads_extracted"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/gunzip-and-extract/4",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Input FIles",
            "id": "in_reads",
            "type": "File?",
            "label": "FASTQ file",
            "doc": "FASTQ file.",
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ"
          },
          {
            "sbg:toolDefaultValue": "2000",
            "sbg:category": "Platform Options",
            "id": "mem_per_job",
            "type": "int?",
            "label": "Memory per job",
            "doc": "Memory per job in MB. Default is 2000."
          },
          {
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Platform Options",
            "id": "cpu_per_job",
            "type": "int?",
            "label": "Number of CPUs",
            "doc": "Number of CPUs per job. Default is 1."
          }
        ],
        "outputs": [
          {
            "id": "out_reads_raw",
            "doc": "Raw FASTQ files",
            "label": "Raw FASTQ files",
            "type": "File[]?",
            "outputBinding": {
              "glob": "*raw*",
              "outputEval": "$(inheritMetadata(self, inputs.in_reads))"
            },
            "sbg:fileTypes": "FASTQ, FQ"
          },
          {
            "id": "out_reads_extracted",
            "doc": "Extracted  reads.",
            "label": "Extracted reads",
            "type": "File[]?",
            "outputBinding": {
              "glob": "*extracted*",
              "outputEval": "$(inheritMetadata(self, inputs.in_reads))"
            },
            "sbg:fileTypes": "FASTQ, FQ"
          }
        ],
        "label": "Gunzip and Extract",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var compressed = 'No';\n    var cmd = '';\n    \n    if (inputs.in_reads.nameext == '.gz'){\n        compressed = 'Yes';\n        var output_name = inputs.in_reads.basename.split('.').slice(0, -2).join('.');\n        var output_ext = inputs.in_reads.basename.split('.')[inputs.in_reads.basename.split('.').length-2];\n    }\n    else {\n        var output_name = inputs.in_reads.basename.split('.').slice(0, -1).join('.');\n        var output_ext = inputs.in_reads.basename.split('.').pop();\n    }\n    if (compressed == 'Yes'){\n        cmd = cmd + '/bin/bash -c \\'gunzip -c ' + inputs.in_reads.path + ' > ' + output_name + '.raw.'+ output_ext + ' && cat ' + output_name + '.raw.'+ output_ext + ' | paste - - - - | sort -k1,1 -t \" \" | tr \"\\\\t\" \"\\\\n\" > ' + output_name + '.extracted.fastq; if [[ ${PIPESTATUS[@]} == \"0 0 0 0\" ]]; then echo \"Everything OK\"; else exit 1; fi\\'';\n    }\n    else {\n        cmd = cmd + '/bin/bash -c \\'mv '+ inputs.in_reads.path +' '+ output_name + '.raw.'+ output_ext +' && cat ' + output_name + '.raw.'+ output_ext + ' | paste - - - - | sort -k1,1 -t \" \" | tr \"\\\\t\" \"\\\\n\" > ' + output_name + '.extracted.fastq; if [[ ${PIPESTATUS[@]} == \"0 0 0 0\" ]]; then echo \"Everything OK\"; else exit 1; fi\\'';\n    }\n    return cmd\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    if(inputs.mem_per_job){\n        return inputs.mem_per_job\n    }\n    else{\n        return 2000\n    }\n}",
            "coresMin": "${\n    if (inputs.cpu_per_job){\n        return inputs.cpu_per_job\n    }\n    else{\n        return 1\n    }\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/jrandjelovic/pybuntu:v2.1"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "V-pipe tools - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650376564,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650376680,
            "sbg:revisionNotes": "Final version from dev."
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650433883,
            "sbg:revisionNotes": "JS edited."
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650535470,
            "sbg:revisionNotes": "Resource requirements changed."
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1653029817,
            "sbg:revisionNotes": "Pipe status added."
          }
        ],
        "sbg:image_url": null,
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "h-06dc43c9/h-08324ae2/h-61c4c4da/0",
        "sbg:revision": 4,
        "sbg:revisionNotes": "Pipe status added.",
        "sbg:modifiedOn": 1653029817,
        "sbg:modifiedBy": "lea_lenhardt_ackovic",
        "sbg:createdOn": 1650376564,
        "sbg:createdBy": "lea_lenhardt_ackovic",
        "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "lea_lenhardt_ackovic"
        ],
        "sbg:latestRevision": 4,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a849a0ea093e64d4e600dfd6b512b7387e9c465af5b58e907d6bbf94711442482",
        "sbg:workflowLanguage": "CWL"
      },
      "label": "Gunzip and Extract",
      "scatter": [
        "in_reads"
      ],
      "sbg:x": -591.66796875,
      "sbg:y": 143.60118103027344
    },
    {
      "id": "prinseq_lite_0_20_4",
      "in": [
        {
          "id": "in_reads",
          "source": [
            "sbg_pair_fastqs_by_metadata/tuple_list"
          ],
          "valueFrom": "$(self ? [].concat(self) : self)"
        },
        {
          "id": "extra",
          "default": "-ns_max_n 4 -min_qual_mean 30 -trim_qual_left 30 -trim_qual_right 30 -trim_qual_window 10",
          "source": "extra"
        },
        {
          "id": "out_format",
          "default": 3
        },
        {
          "id": "out_good",
          "valueFrom": "${\n    if (inputs.in_reads[0] instanceof Array) {\n        var input_1 = inputs.in_reads[0][0]; // scatter mode\n    } \n    else if (inputs.in_reads instanceof Array) {\n        var input_1 = inputs.in_reads[0];\n    } \n    else {\n        var input_1 = [].concat(inputs.in_reads)[0];\n    }\n    return input_1.metadata['sample_id']\n}"
        },
        {
          "id": "out_bad",
          "default": "null"
        },
        {
          "id": "read_length",
          "source": "read_length"
        },
        {
          "id": "trim_percent_cutoff",
          "default": 0.8,
          "source": "trim_percent_cutoff"
        }
      ],
      "out": [
        {
          "id": "out_reads"
        },
        {
          "id": "out_singletons"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/prinseq-lite-0-20-4/6",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Input Files",
            "id": "in_reads",
            "type": "File[]?",
            "label": "FASTQ files",
            "doc": "FASTQ files.",
            "sbg:fileTypes": "FASTQ"
          },
          {
            "sbg:toolDefaultValue": "-ns_max_n 4 -min_qual_mean 30 -trim_qual_left 30 -trim_qual_right 30 -trim_qual_window 10",
            "sbg:category": "Config Inputs",
            "id": "extra",
            "type": "string?",
            "inputBinding": {
              "shellQuote": false,
              "position": 5
            },
            "label": "Extra command line options",
            "doc": "Additional command line options. They can be provided as string with multiple prefixes and values. Default value for V-pipe workflow is -ns_max_n 4 -min_qual_mean 30 -trim_qual_left 30 -trim_qual_right 30 -trim_qual_window 10.",
            "default": "-ns_max_n 4 -min_qual_mean 30 -trim_qual_left 30 -trim_qual_right 30 -trim_qual_window 10"
          },
          {
            "sbg:category": "Config Options",
            "id": "out_format",
            "type": "int?",
            "inputBinding": {
              "prefix": "-out_format",
              "shellQuote": false,
              "position": 6
            },
            "label": "Output format",
            "doc": "Output format. If not defined, the output format will be the same as the input format.",
            "default": 3
          },
          {
            "id": "out_good",
            "type": "string?",
            "inputBinding": {
              "prefix": "-out_good",
              "shellQuote": false,
              "position": 7
            },
            "label": "Out good",
            "doc": "Out good."
          },
          {
            "id": "out_bad",
            "type": "string?",
            "inputBinding": {
              "prefix": "-out_bad",
              "shellQuote": false,
              "position": 8
            },
            "label": "Out bad",
            "doc": "Out bad"
          },
          {
            "sbg:category": "Config Inputs",
            "id": "read_length",
            "type": "int?",
            "label": "Read length",
            "doc": "Read length."
          },
          {
            "id": "trim_percent_cutoff",
            "type": "float?",
            "label": "Trimming cutoff",
            "doc": "Read-length threshold that should be applied during the quality trimming as a percentage."
          },
          {
            "sbg:toolDefaultValue": "2000",
            "sbg:category": "Platform Options",
            "id": "mem_per_job",
            "type": "int?",
            "label": "Memory per job",
            "doc": "Memory per job in MB. Default is 2000."
          },
          {
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Platform Options",
            "id": "cpu_per_job",
            "type": "int?",
            "label": "Number of CPUs",
            "doc": "Number of CPUs per job. Default is 1."
          }
        ],
        "outputs": [
          {
            "id": "out_reads",
            "doc": "Preprocessed reads.",
            "label": "Preprocessed reads",
            "type": "File[]?",
            "outputBinding": {
              "glob": "*_[1-2].fastq.gz",
              "outputEval": "$(inheritMetadata(self, inputs.in_reads))"
            },
            "sbg:fileTypes": "FASTQ.GZ"
          },
          {
            "id": "out_singletons",
            "doc": "Singleton reads.",
            "label": "Singleton reads",
            "type": "File[]?",
            "outputBinding": {
              "glob": "*singleton*",
              "outputEval": "$(inheritMetadata(self, inputs.in_reads))"
            },
            "sbg:fileTypes": "FASTQ.GZ"
          }
        ],
        "doc": "**Prinseq Lite** is a tool that generates summary statistics of sequence and quality data and that is used to filter, reformat and trim next-generation sequence data. This lite version is primarily designed for data preprocessing and does not generate summary statistics in graphical form.\n\n##Changes introduced by Seven Bridges\n* This tool version is specifically wrapped for V-pipe workflow, and only parameters specified by V-pipe were included in the wrapper.\n##References\n\n[1] [PRINSEQ homepage](http://prinseq.sourceforge.net/index.html)",
        "label": "Prinseq Lite",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 2,
            "valueFrom": "${\n    var cmd1 = '';\n    var cmd2 = '';\n    if (inputs.in_reads[0] instanceof Array) {\n        if (inputs.in_reads[0].length>1){\n            for (var i=0; i<inputs.in_reads[0].length; i++){\n                if (inputs.in_reads[0][i].metadata['paired_end']=='1'){\n                    var cmd1 = '-fastq '+ inputs.in_reads[0][i].path;\n                }\n                else{\n                    var cmd2 = ' -fastq2 '+ inputs.in_reads[0][i].path;\n                }\n            }\n        }\n        else{\n            var cmd1 = '-fastq '+ inputs.in_reads[0][0].path;\n        }\n    }\n    else if (inputs.in_reads instanceof Array) {\n        if (inputs.in_reads.length>1){\n            for (var i=0; i<inputs.in_reads.length; i++){\n                if (inputs.in_reads[i].metadata['paired_end']=='1'){\n                    var cmd1 = '-fastq '+ inputs.in_reads[i].path;\n                }\n                else{\n                    var cmd2 = ' -fastq2 '+ inputs.in_reads[i].path;\n                }\n            }\n        }\n        else{\n            var cmd1 = '-fastq '+ inputs.in_reads[0].path;\n        }\n    } \n    else {\n        var in_r = [].concat(inputs.in_reads);\n        if (in_r.length>1){\n            for (var i=0; i<in_r.length; i++){\n                if (in_r[i].metadata['paired_end']=='1'){\n                    var cmd1 = '-fastq '+ in_r[i].path;\n                }\n                else{\n                    var cmd2 = ' -fastq2 '+ in_r[i].path;\n                }\n            }\n        }\n        else{\n            var cmd1 = '-fastq '+ in_r[0].path;\n        }\n    }\n    return cmd1+cmd2\n}"
          },
          {
            "prefix": "-min_len",
            "shellQuote": false,
            "position": 3,
            "valueFrom": "${\n    var len=inputs.read_length*inputs.trim_percent_cutoff;\n    return len\n}"
          },
          {
            "prefix": "&& gzip",
            "shellQuote": false,
            "position": 100,
            "valueFrom": "${\n    return '*.fastq'\n}"
          },
          {
            "prefix": "-log",
            "shellQuote": false,
            "position": 50,
            "valueFrom": "${\n    if (inputs.in_reads[0] instanceof Array) {\n        var input_1 = inputs.in_reads[0][0]; // scatter mode\n    } \n    else if (inputs.in_reads instanceof Array) {\n        var input_1 = inputs.in_reads[0];\n    } \n    else {\n        var input_1 = [].concat(inputs.in_reads)[0];\n    }\n    return input_1.metadata['sample_id']+'_prinseq.out.log'\n}"
          },
          {
            "prefix": "perl",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "/opt/prinseq-lite-0.20.4/prinseq-lite.pl"
          },
          {
            "prefix": "echo",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cut=inputs.read_length*inputs.trim_percent_cutoff;\n    if (inputs.in_reads[0] instanceof Array) {\n        var input_1 = inputs.in_reads[0][0]; // scatter mode\n    } \n    else if (inputs.in_reads instanceof Array) {\n        var input_1 = inputs.in_reads[0];\n    } \n    else {\n        var input_1 = [].concat(inputs.in_reads)[0];\n    }\n    return '\"The length cutoff is: '+ cut + '\" > ' + input_1.metadata['sample_id']+'_prinseq.out.log &&'\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    if(inputs.mem_per_job){\n        return inputs.mem_per_job\n    }\n    else{\n        return 2000\n    }\n}",
            "coresMin": "${\n    if (inputs.cpu_per_job){\n        return inputs.cpu_per_job\n    }\n    else{\n        return 1\n    }\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/prinseq-lite-0-20-4:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "V-pipe tools - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650376727,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650376759,
            "sbg:revisionNotes": "Latest version from dev."
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650434016,
            "sbg:revisionNotes": "JS edited."
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650527956,
            "sbg:revisionNotes": "Edited JS so array input can be processed."
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650528779,
            "sbg:revisionNotes": "Updated JS."
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650535425,
            "sbg:revisionNotes": "Resource requirements changed."
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650539592,
            "sbg:revisionNotes": "Singleton output added."
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "Prinseq",
        "sbg:toolkitVersion": "0.20.40",
        "sbg:license": "GNU General Public License",
        "sbg:toolAuthor": "Robert Schmieder and Robert Edwards",
        "sbg:links": [
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/21278185",
            "label": "Publication"
          },
          {
            "id": "http://prinseq.sourceforge.net/",
            "label": "Homepage"
          },
          {
            "id": "https://sourceforge.net/projects/prinseq/files/standalone/",
            "label": "Source Code"
          },
          {
            "id": "https://sourceforge.net/projects/prinseq/files/standalone/prinseq-lite-0.20.4.tar.gz/download",
            "label": "Download"
          }
        ],
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "h-165b752b/h-22c5ddc5/h-1bc800a5/0",
        "sbg:revision": 6,
        "sbg:revisionNotes": "Singleton output added.",
        "sbg:modifiedOn": 1650539592,
        "sbg:modifiedBy": "lea_lenhardt_ackovic",
        "sbg:createdOn": 1650376727,
        "sbg:createdBy": "lea_lenhardt_ackovic",
        "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "lea_lenhardt_ackovic"
        ],
        "sbg:latestRevision": 6,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a42af0bb9359ed01ad02ac07f868c4c27347c7a411fc41dff90f9b328c7a7f252",
        "sbg:workflowLanguage": "CWL"
      },
      "label": "Prinseq Lite",
      "scatter": [
        "in_reads"
      ],
      "sbg:x": -346.1217956542969,
      "sbg:y": 155.75245666503906
    },
    {
      "id": "sbg_pair_fastqs_by_metadata",
      "in": [
        {
          "id": "fastq_list",
          "source": [
            "gunzip_and_extract/out_reads_extracted"
          ],
          "valueFrom": "${\n    function flatten_recursive (ar) {\n        var out = []\n        for (var i in ar){\n            if (!Array.isArray(ar[i])) {\n                out.push(ar[i])\n            } else\n            {\n                out = out.concat(flatten_recursive(ar[i]))\n            }\n        }\n        return out\n    }\n    return flatten_recursive(self)\n}"
        }
      ],
      "out": [
        {
          "id": "tuple_list"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.0",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "sevenbridges/sbgtools-cwl1-0-demo/sbg-pair-fastqs-by-metadata/3",
        "baseCommand": [
          "echo"
        ],
        "inputs": [
          {
            "id": "fastq_list",
            "type": "File[]?",
            "label": "List of FASTQ files",
            "doc": "List of the FASTQ files with properly set metadata fileds.",
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ"
          }
        ],
        "outputs": [
          {
            "id": "tuple_list",
            "doc": "List of grouped FASTQ files by metadata fields.",
            "label": "List of grouped FASTQ files",
            "type": [
              "null",
              {
                "type": "array",
                "items": [
                  {
                    "type": "array",
                    "items": [
                      "File",
                      "null"
                    ]
                  },
                  "null"
                ]
              }
            ],
            "outputBinding": {
              "outputEval": "${\n  function get_meta_map(m, file, meta) {\n    if (meta in file.metadata) {\n      return m[file.metadata[meta]];\n    } else {\n      return m['Undefined'];\n    }\n  }\n  \n  function create_new_map(map, file, meta) {\n    if (meta in file.metadata) {\n      map[file.metadata[meta]] = {};\n      return map[file.metadata[meta]];\n    } else {\n      map['Undefined'] = {};\n      return map['Undefined'];\n    }\n  }\n  \n  if (inputs.fastq_list) {\n    \n    var arr = [].concat(inputs.fastq_list);\n    var map = {};\n    \n    for (var i in arr) {\n      \n      var sm_map = get_meta_map(map, arr[i], 'sample_id');\n      if (!sm_map) sm_map = create_new_map(map, arr[i], 'sample_id');\n      \n      var lb_map = get_meta_map(sm_map, arr[i], 'library_id');\n      if (!lb_map) lb_map = create_new_map(sm_map, arr[i], 'library_id');\n      \n      var pu_map = get_meta_map(lb_map, arr[i], 'platform_unit_id');\n      if (!pu_map) pu_map = create_new_map(lb_map, arr[i], 'platform_unit_id');\n      \n      var a = '';\n      var ar = '';\n      \n      if ('file_segment_number' in arr[i].metadata) {\n        if (pu_map[arr[i].metadata['file_segment_number']]) {\n          a = pu_map[arr[i].metadata['file_segment_number']];\n          ar = [].concat(a);\n          ar = ar.concat(arr[i]);\n          pu_map[arr[i].metadata['file_segment_number']] = ar;\n        } else {\n          pu_map[arr[i].metadata['file_segment_number']] = [].concat(arr[i]);\n        }\n      } else {\n        if (pu_map['Undefined']) {\n          a = pu_map['Undefined'];\n          ar = [].concat(a);\n          ar = ar.concat(arr[i]);\n          pu_map['Undefined'] = ar;\n        } else {\n          pu_map['Undefined'] = [].concat(arr[i]);\n        }\n      }\n    }\n    var tuple_list = [];\n    var list;\n    for (var sm in map)\n      for (var lb in map[sm])\n        for (var pu in map[sm][lb]) {\n          for (var fsm in map[sm][lb][pu]) {\n            list = map[sm][lb][pu][fsm];\n            tuple_list.push(list);\n          }\n        }\n    return tuple_list;\n  }\n}"
            }
          }
        ],
        "doc": "**SBG Pair FASTQs by Metadata**  tool accepts a list of FASTQ files and groups them into separate lists. This grouping is done by using values of following metadata fields: **Sample ID**, **Library ID**, **Platform unit ID** and **File segment number**. Not all of these four metadata fields do not have to be populated, but the present set of metadata values has to be sufficient to create unique combinations for each pair of FASTQ files. If more than one metadata field is populated, be aware of the hierarchy implemented: **Sample ID** > **Library ID** > **Platform unit ID** > **File segment number**.  \n\n### Important notes\n\n* Metadata values should create unique combinations for each pair of FASTQ files. \n\n* Files with no **Paired-end** metadata are grouped in the same way as the ones with **Paired-end** metadata - generally, single-read file should be alone in a separate list. \n\n* Files with no metadata set will be grouped together. \n\n* If there are more than two files per a created group, errors in the following analysis steps might occur; users should check if the metadata fields for those files are set properly.",
        "label": "SBG Pair FASTQs by Metadata",
        "arguments": [
          {
            "shellQuote": false,
            "position": 0,
            "valueFrom": "'Pairing"
          },
          {
            "shellQuote": false,
            "position": 1,
            "valueFrom": "FASTQs!'"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": 1024,
            "coresMin": 1
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/nikola_jovanovic/alpine:1"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.fastq_list)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
            ]
          }
        ],
        "sbg:image_url": null,
        "sbg:license": "Apache License 2.0",
        "sbg:toolkit": "SBGTools",
        "sbg:cmdPreview": "echo 'Pairing FASTQs!'",
        "sbg:categories": [
          "File Format Conversion"
        ],
        "sbg:toolAuthor": "",
        "sbg:projectName": "SBGTools - CWL1.x - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "nens",
            "sbg:modifiedOn": 1566551892,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "nens",
            "sbg:modifiedOn": 1566551930,
            "sbg:revisionNotes": "v5-dev project"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "nens",
            "sbg:modifiedOn": 1647009647,
            "sbg:revisionNotes": "updated description"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "marko_zecevic",
            "sbg:modifiedOn": 1649097542,
            "sbg:revisionNotes": "update categories"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:id": "h-fa06ebc2/h-73749d14/h-bcb2ab06/0",
        "sbg:revision": 3,
        "sbg:revisionNotes": "update categories",
        "sbg:modifiedOn": 1649097542,
        "sbg:modifiedBy": "marko_zecevic",
        "sbg:createdOn": 1566551892,
        "sbg:createdBy": "nens",
        "sbg:project": "sevenbridges/sbgtools-cwl1-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "nens",
          "marko_zecevic"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a47d1063ca3ff4bc64f3896b570d17ae29ba9313eff38a420fd607ebb7fec48a7",
        "sbg:workflowLanguage": "CWL"
      },
      "label": "SBG Pair FASTQs by Metadata",
      "sbg:x": -460.2436218261719,
      "sbg:y": 260.0255432128906
    },
    {
      "id": "sbg_pair_fastqs_by_metadata_1",
      "in": [
        {
          "id": "fastq_list",
          "source": [
            "prinseq_lite_0_20_4/out_reads"
          ],
          "valueFrom": "${\n    function flatten_recursive (ar) {\n        var out = []\n        for (var i in ar){\n            if (!Array.isArray(ar[i])) {\n                out.push(ar[i])\n            } else\n            {\n                out = out.concat(flatten_recursive(ar[i]))\n            }\n        }\n        return out\n    }\n    return flatten_recursive(self)\n}"
        }
      ],
      "out": [
        {
          "id": "tuple_list"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.0",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "sevenbridges/sbgtools-cwl1-0-demo/sbg-pair-fastqs-by-metadata/3",
        "baseCommand": [
          "echo"
        ],
        "inputs": [
          {
            "id": "fastq_list",
            "type": "File[]?",
            "label": "List of FASTQ files",
            "doc": "List of the FASTQ files with properly set metadata fileds.",
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ"
          }
        ],
        "outputs": [
          {
            "id": "tuple_list",
            "doc": "List of grouped FASTQ files by metadata fields.",
            "label": "List of grouped FASTQ files",
            "type": [
              "null",
              {
                "type": "array",
                "items": [
                  {
                    "type": "array",
                    "items": [
                      "File",
                      "null"
                    ]
                  },
                  "null"
                ]
              }
            ],
            "outputBinding": {
              "outputEval": "${\n  function get_meta_map(m, file, meta) {\n    if (meta in file.metadata) {\n      return m[file.metadata[meta]];\n    } else {\n      return m['Undefined'];\n    }\n  }\n  \n  function create_new_map(map, file, meta) {\n    if (meta in file.metadata) {\n      map[file.metadata[meta]] = {};\n      return map[file.metadata[meta]];\n    } else {\n      map['Undefined'] = {};\n      return map['Undefined'];\n    }\n  }\n  \n  if (inputs.fastq_list) {\n    \n    var arr = [].concat(inputs.fastq_list);\n    var map = {};\n    \n    for (var i in arr) {\n      \n      var sm_map = get_meta_map(map, arr[i], 'sample_id');\n      if (!sm_map) sm_map = create_new_map(map, arr[i], 'sample_id');\n      \n      var lb_map = get_meta_map(sm_map, arr[i], 'library_id');\n      if (!lb_map) lb_map = create_new_map(sm_map, arr[i], 'library_id');\n      \n      var pu_map = get_meta_map(lb_map, arr[i], 'platform_unit_id');\n      if (!pu_map) pu_map = create_new_map(lb_map, arr[i], 'platform_unit_id');\n      \n      var a = '';\n      var ar = '';\n      \n      if ('file_segment_number' in arr[i].metadata) {\n        if (pu_map[arr[i].metadata['file_segment_number']]) {\n          a = pu_map[arr[i].metadata['file_segment_number']];\n          ar = [].concat(a);\n          ar = ar.concat(arr[i]);\n          pu_map[arr[i].metadata['file_segment_number']] = ar;\n        } else {\n          pu_map[arr[i].metadata['file_segment_number']] = [].concat(arr[i]);\n        }\n      } else {\n        if (pu_map['Undefined']) {\n          a = pu_map['Undefined'];\n          ar = [].concat(a);\n          ar = ar.concat(arr[i]);\n          pu_map['Undefined'] = ar;\n        } else {\n          pu_map['Undefined'] = [].concat(arr[i]);\n        }\n      }\n    }\n    var tuple_list = [];\n    var list;\n    for (var sm in map)\n      for (var lb in map[sm])\n        for (var pu in map[sm][lb]) {\n          for (var fsm in map[sm][lb][pu]) {\n            list = map[sm][lb][pu][fsm];\n            tuple_list.push(list);\n          }\n        }\n    return tuple_list;\n  }\n}"
            }
          }
        ],
        "doc": "**SBG Pair FASTQs by Metadata**  tool accepts a list of FASTQ files and groups them into separate lists. This grouping is done by using values of following metadata fields: **Sample ID**, **Library ID**, **Platform unit ID** and **File segment number**. Not all of these four metadata fields do not have to be populated, but the present set of metadata values has to be sufficient to create unique combinations for each pair of FASTQ files. If more than one metadata field is populated, be aware of the hierarchy implemented: **Sample ID** > **Library ID** > **Platform unit ID** > **File segment number**.  \n\n### Important notes\n\n* Metadata values should create unique combinations for each pair of FASTQ files. \n\n* Files with no **Paired-end** metadata are grouped in the same way as the ones with **Paired-end** metadata - generally, single-read file should be alone in a separate list. \n\n* Files with no metadata set will be grouped together. \n\n* If there are more than two files per a created group, errors in the following analysis steps might occur; users should check if the metadata fields for those files are set properly.",
        "label": "SBG Pair FASTQs by Metadata",
        "arguments": [
          {
            "shellQuote": false,
            "position": 0,
            "valueFrom": "'Pairing"
          },
          {
            "shellQuote": false,
            "position": 1,
            "valueFrom": "FASTQs!'"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": 1024,
            "coresMin": 1
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/nikola_jovanovic/alpine:1"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.fastq_list)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
            ]
          }
        ],
        "sbg:image_url": null,
        "sbg:license": "Apache License 2.0",
        "sbg:toolkit": "SBGTools",
        "sbg:cmdPreview": "echo 'Pairing FASTQs!'",
        "sbg:categories": [
          "File Format Conversion"
        ],
        "sbg:toolAuthor": "",
        "sbg:projectName": "SBGTools - CWL1.x - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "nens",
            "sbg:modifiedOn": 1566551892,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "nens",
            "sbg:modifiedOn": 1566551930,
            "sbg:revisionNotes": "v5-dev project"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "nens",
            "sbg:modifiedOn": 1647009647,
            "sbg:revisionNotes": "updated description"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "marko_zecevic",
            "sbg:modifiedOn": 1649097542,
            "sbg:revisionNotes": "update categories"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:id": "h-144624e7/h-df39f83b/h-d4adad3b/0",
        "sbg:revision": 3,
        "sbg:revisionNotes": "update categories",
        "sbg:modifiedOn": 1649097542,
        "sbg:modifiedBy": "marko_zecevic",
        "sbg:createdOn": 1566551892,
        "sbg:createdBy": "nens",
        "sbg:project": "sevenbridges/sbgtools-cwl1-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "nens",
          "marko_zecevic"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a47d1063ca3ff4bc64f3896b570d17ae29ba9313eff38a420fd607ebb7fec48a7",
        "sbg:workflowLanguage": "CWL"
      },
      "label": "SBG Pair FASTQs by Metadata",
      "sbg:x": -219.84872436523438,
      "sbg:y": 46.333988189697266
    },
    {
      "id": "samtools_view_1_10",
      "in": [
        {
          "id": "output_format",
          "default": "SAM"
        },
        {
          "id": "include_header",
          "default": true
        },
        {
          "id": "filter_include",
          "valueFrom": "${\n    if(!inputs.custom_input){\n        return 2\n    }\n    else {\n        return null\n    }\n}"
        },
        {
          "id": "filter_exclude_any",
          "default": 2048
        },
        {
          "id": "in_alignments",
          "source": "bwa_mem_bundle_0_7_17_cwl1_2/aligned_reads"
        },
        {
          "id": "extra_exclude",
          "valueFrom": "${\n    if(inputs.custom_input){\n        return 4\n    }\n    else {\n        return null\n    }\n}"
        },
        {
          "id": "custom_input",
          "source": "not_paired_reads"
        }
      ],
      "out": [
        {
          "id": "out_alignments"
        },
        {
          "id": "reads_not_selected_by_filters"
        },
        {
          "id": "alignement_count"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/samtools-view-1-10/4",
        "baseCommand": [
          "/opt/samtools-1.10/samtools",
          "view"
        ],
        "inputs": [
          {
            "sbg:category": "File inputs",
            "id": "in_index",
            "type": "File?",
            "label": "Index file",
            "doc": "This tool requires index file for some use cases.",
            "sbg:fileTypes": "BAI, CRAI, CSI"
          },
          {
            "sbg:altPrefix": "-O",
            "sbg:category": "Config inputs",
            "sbg:toolDefaultValue": "SAM",
            "id": "output_format",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "SAM",
                  "BAM",
                  "CRAM"
                ],
                "name": "output_format"
              }
            ],
            "inputBinding": {
              "prefix": "--output-fmt",
              "shellQuote": false,
              "position": 1
            },
            "label": "Output format",
            "doc": "Output file format"
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "False",
            "id": "fast_bam_compression",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-1",
              "shellQuote": false,
              "position": 2
            },
            "label": "Fast BAM compression",
            "doc": "Enable fast BAM compression (implies output in bam format)."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "False",
            "id": "uncompressed_bam",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-u",
              "shellQuote": false,
              "position": 3
            },
            "label": "Output uncompressed BAM",
            "doc": "Output uncompressed BAM (implies output BAM format). This option saves time spent on compression/decompression and is thus preferred when the output is piped to another SAMtools command."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "False",
            "id": "include_header",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-h",
              "shellQuote": false,
              "position": 4
            },
            "label": "Include the header in the output",
            "doc": "Include the header in the output."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "False",
            "id": "output_header_only",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-H",
              "shellQuote": false,
              "position": 5
            },
            "label": "Output the header only",
            "doc": "Output the header only."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "False",
            "id": "collapse_cigar",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-B",
              "shellQuote": false,
              "position": 6
            },
            "label": "Collapse the backward CIGAR operation",
            "doc": "Collapse the backward CIGAR operation."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "0",
            "id": "filter_include",
            "type": "int?",
            "inputBinding": {
              "prefix": "-f",
              "shellQuote": false,
              "position": 7
            },
            "label": "Include reads with all of these flags",
            "doc": "Only output alignments with all bits set in this integer present in the FLAG field."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "0",
            "id": "filter_exclude_any",
            "type": "int?",
            "inputBinding": {
              "prefix": "-F",
              "shellQuote": false,
              "position": 8
            },
            "label": "Exclude reads with any of these flags",
            "doc": "Do not output alignments with any bits set in this integer present in the FLAG field."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "0",
            "id": "filter_exclude_all",
            "type": "int?",
            "inputBinding": {
              "prefix": "-G",
              "shellQuote": false,
              "position": 9
            },
            "label": "Exclude reads with all of these flags",
            "doc": "Only exclude reads with all of the bits set in this integer present in the FLAG field."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "null",
            "id": "read_group",
            "type": "string?",
            "inputBinding": {
              "prefix": "-r",
              "shellQuote": false,
              "position": 10
            },
            "label": "Read group",
            "doc": "Only output reads in the specified read group."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "0",
            "id": "filter_mapq",
            "type": "int?",
            "inputBinding": {
              "prefix": "-q",
              "shellQuote": false,
              "position": 11
            },
            "label": "Minimum mapping quality",
            "doc": "Skip alignments with MAPQ smaller than this value."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "null",
            "id": "filter_library",
            "type": "string?",
            "inputBinding": {
              "prefix": "-l",
              "shellQuote": false,
              "position": 12
            },
            "label": "Only include alignments in library",
            "doc": "Only output alignments in this library."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "0",
            "id": "min_cigar_operations",
            "type": "int?",
            "inputBinding": {
              "prefix": "-m",
              "shellQuote": false,
              "position": 13
            },
            "label": "Minimum number of CIGAR bases consuming query sequence",
            "doc": "Only output alignments with number of CIGAR bases consuming query sequence  \u2265 INT."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "read_tag_to_strip",
            "type": "string[]?",
            "inputBinding": {
              "prefix": "",
              "itemSeparator": " ",
              "shellQuote": false,
              "position": 14,
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('-x', self[i]);\n            \n        }\n        return cmd.join(' ');\n    }\n}"
            },
            "label": "Read tags to strip",
            "doc": "Read tag to exclude from output (repeatable)."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "False",
            "id": "count_alignments",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-c",
              "shellQuote": false,
              "position": 15
            },
            "label": "Output only count of matching records",
            "doc": "Instead of outputing the alignments, only count them and output the total number. All filter options, such as -f, -F, and -q, are taken into account."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "input_fmt_option",
            "type": "string?",
            "inputBinding": {
              "prefix": "--input-fmt-option",
              "shellQuote": false,
              "position": 16
            },
            "label": "Input file format option",
            "doc": "Specify a single input file format option in the form of OPTION or OPTION=VALUE."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "output_fmt_option",
            "type": "string?",
            "inputBinding": {
              "prefix": "--output-fmt-option",
              "shellQuote": false,
              "position": 17
            },
            "label": "Output file format option",
            "doc": "Specify a single output file format option in the form of OPTION or OPTION=VALUE."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "subsample_fraction",
            "type": "float?",
            "inputBinding": {
              "prefix": "-s",
              "shellQuote": false,
              "position": 18
            },
            "label": "Subsample fraction",
            "doc": "Output only a proportion of the input alignments. This subsampling acts in the same way on all of the alignment records in the same template or read pair, so it never keeps a read but not its mate. The integer and fractional parts of the INT.FRAC are used separately: the part after the decimal point sets the fraction of templates/pairs to be kept, while the integer part is used as a seed that influences which subset of reads is kept. When subsampling data that has previously been subsampled, be sure to use a different seed value from those used previously; otherwise more reads will be retained than expected."
          },
          {
            "sbg:altPrefix": "-@",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Execution",
            "id": "threads",
            "type": "int?",
            "inputBinding": {
              "prefix": "--threads",
              "shellQuote": false,
              "position": 19,
              "valueFrom": "${\n  if((inputs.threads)){\n    return (inputs.threads) - 1\n  }\n  else{\n    return\n  }\n}"
            },
            "label": "Number of threads",
            "doc": "Number of threads. SAMtools uses argument --threads/-@ to specify number of additional threads. This parameter sets total number of threads (and CPU cores). Command line argument will be reduced by 1 to set number of additional threads."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "omitted_reads_filename",
            "type": "string?",
            "inputBinding": {
              "prefix": "-U",
              "shellQuote": false,
              "position": 20
            },
            "label": "Filename for reads not selected by filters",
            "doc": "Write alignments that are not selected by the various filter options to this file. When this option is used, all alignments (or all alignments intersecting the regions specified) are written to either the output file or this file, but never both."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "stdout",
            "id": "output_filename",
            "type": "string?",
            "inputBinding": {
              "prefix": "-o",
              "shellQuote": false,
              "position": 21,
              "valueFrom": "${\n  if (inputs.output_filename!=\"default_output_filename\"){\n    return (inputs.output_filename)\n  }\n  var input_filename = [].concat(inputs.in_alignments)[0].path.split('/').pop();\n  var input_name_base = input_filename.split('.').slice(0,-1).join('.');\n  var ext = 'sam';\n  if (inputs.count_alignments){\n    return input_name_base + '.count.txt'\n  }\n  if ((inputs.uncompressed_bam) || (inputs.fast_bam_compression)){\n    ext = 'bam';\n  }\n  if (inputs.output_format){\n    ext = (inputs.output_format).toLowerCase();\n  }\n  if (inputs.output_header_only){\n    ext = 'header.' + ext;\n  }\n  if (inputs.subsample_fraction){\n    ext = 'subsample.' + ext;\n  }\n  if ((inputs.bed_file) || (inputs.read_group) || (inputs.read_group_list) ||\n      (inputs.filter_mapq) || (inputs.filter_library) || (inputs.min_cigar_operations) ||\n      (inputs.filter_include) || (inputs.filter_exclude_any) || \n      (inputs.filter_exclude_all) || (inputs.regions_array)){\n    ext = 'filtered.' + ext;\n  }\n    \n  return input_name_base + '.' + ext;\n}"
            },
            "label": "Output filename",
            "doc": "Define a filename of the output.",
            "default": "default_output_filename"
          },
          {
            "sbg:category": "File Inputs",
            "id": "bed_file",
            "type": "File?",
            "inputBinding": {
              "prefix": "-L",
              "shellQuote": false,
              "position": 22
            },
            "label": "BED region file",
            "doc": "Only output alignments overlapping the input BED file.",
            "sbg:fileTypes": "BED"
          },
          {
            "sbg:category": "File Inputs",
            "id": "read_group_list",
            "type": "File?",
            "inputBinding": {
              "prefix": "-R",
              "shellQuote": false,
              "position": 23
            },
            "label": "Read group list",
            "doc": "Output alignments in read groups listed in this file.",
            "sbg:fileTypes": "TXT"
          },
          {
            "sbg:altPrefix": "-T",
            "sbg:category": "File Inputs",
            "id": "in_reference",
            "type": "File?",
            "inputBinding": {
              "prefix": "--reference",
              "shellQuote": false,
              "position": 24
            },
            "label": "Reference file",
            "doc": "A FASTA format reference file, optionally compressed by bgzip and ideally indexed by SAMtools Faidx. If an index is not present, one will be generated for you. This file is used for compression/decompression of CRAM files. Please provide reference file when using CRAM input/output file.",
            "sbg:fileTypes": "FASTA, FA, FASTA.GZ, FA.GZ, GZ"
          },
          {
            "sbg:category": "File Inputs",
            "id": "reference_file_list",
            "type": "File?",
            "inputBinding": {
              "prefix": "-t",
              "shellQuote": false,
              "position": 25
            },
            "label": "List of reference names and lengths",
            "doc": "A tab-delimited file. Each line must contain the reference name in the first column and the length of the reference in the second column, with one line for each distinct reference. Any additional fields beyond the second column are ignored. This file also defines the order of the reference sequences in sorting. If you run SAMtools Faidx on reference FASTA file (<ref.fa>), the resulting index file <ref.fa>.fai can be used as this file.",
            "sbg:fileTypes": "FAI, TSV, TXT"
          },
          {
            "sbg:category": "File Inputs",
            "id": "in_alignments",
            "type": "File",
            "inputBinding": {
              "shellQuote": false,
              "position": 99
            },
            "label": "Input BAM/SAM/CRAM file",
            "doc": "Input BAM/SAM/CRAM file.",
            "sbg:fileTypes": "BAM, SAM, CRAM"
          },
          {
            "sbg:category": "Config Inputs",
            "id": "regions_array",
            "type": "string[]?",
            "inputBinding": {
              "shellQuote": false,
              "position": 100
            },
            "label": "Regions array",
            "doc": "With no options or regions specified, prints all alignments in the specified input alignment file (in SAM, BAM, or CRAM format) to output file in specified format. Use of region specifications requires a coordinate-sorted and indexed input file (in BAM or CRAM format). Regions can be specified as: RNAME[:STARTPOS[-ENDPOS]] and all position coordinates are 1-based.  Important note: when multiple regions are given, some alignments may be output multiple times if they overlap more than one of the specified regions. Examples of region specifications:  chr1 - Output all alignments mapped to the reference sequence named `chr1' (i.e. @SQ SN:chr1);  chr2:1000000 - The region on chr2 beginning at base position 1,000,000 and ending at the end of the chromosome;  chr3:1000-2000 - The 1001bp region on chr3 beginning at base position 1,000 and ending at base position 2,000 (including both end positions);  '*' - Output the unmapped reads at the end of the file (this does not include any unmapped reads placed on a reference sequence alongside their mapped mates.);  . - Output all alignments (mostly unnecessary as not specifying a region at all has the same effect)."
          },
          {
            "sbg:category": "Config inputs",
            "sbg:toolDefaultValue": "False",
            "id": "multi_region_iterator",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-M",
              "shellQuote": false,
              "position": 22
            },
            "label": "Use the multi-region iterator",
            "doc": "Use the multi-region iterator on the union of the BED file and command-line region arguments."
          },
          {
            "sbg:category": "Platform Options",
            "sbg:toolDefaultValue": "1500",
            "id": "mem_per_job",
            "type": "int?",
            "label": "Memory per job",
            "doc": "Memory per job in MB."
          },
          {
            "sbg:category": "Platform Options",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "type": "int?",
            "label": "CPU per job",
            "doc": "Number of CPUs per job."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "extra_exclude",
            "type": "int?",
            "inputBinding": {
              "prefix": "-F",
              "shellQuote": false,
              "position": 8
            },
            "label": "Additional filter",
            "doc": "Additional filter exclude reads with any of these flags."
          }
        ],
        "outputs": [
          {
            "id": "out_alignments",
            "doc": "The output file.",
            "label": "Output BAM, SAM, or CRAM file",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n  if ((inputs.output_filename!=\"default_output_filename\")){\n    return (inputs.output_filename)\n  }\n  var input_filename = [].concat((inputs.in_alignments))[0].path.split('/').pop();\n  var input_name_base = input_filename.split('.').slice(0,-1). join('.');\n  var ext = 'sam';\n  if ((inputs.count_alignments)){\n    return ''\n  }\n  if ((inputs.uncompressed_bam) || (inputs.fast_bam_compression)){\n    ext = 'bam';\n  }\n  if ((inputs.output_format)){\n    ext = (inputs.output_format).toLowerCase();\n  }\n  if ((inputs.output_header_only)){\n    ext = 'header.' + ext;\n  }\n  if ((inputs.subsample_fraction)){\n    ext = 'subsample.' + ext\n  }\n  if ((inputs.bed_file) || (inputs.read_group) || (inputs.read_group_list) ||\n      (inputs.filter_mapq) || (inputs.filter_library) || (inputs.min_cigar_operations) ||\n      (inputs.filter_include) || (inputs.filter_exclude_any) || \n      (inputs.filter_exclude_all) || (inputs.regions_array)){\n    ext = 'filtered.' + ext;\n  }\n    \n  return input_name_base + '.' + ext\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "sbg:fileTypes": "BAM, SAM, CRAM"
          },
          {
            "id": "reads_not_selected_by_filters",
            "doc": "File containing reads that are not selected by filters.",
            "label": "Reads not selected by filters",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n  if ((inputs.omitted_reads_filename)){\n    return (inputs.omitted_reads_filename)\n  }\n  else {\n      return ''\n  }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "sbg:fileTypes": "BAM, SAM, CRAM"
          },
          {
            "id": "alignement_count",
            "doc": "File containing number of alignments.",
            "label": "Alignment count",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n  var input_filename = [].concat((inputs.in_alignments))[0].path.split('/').pop();\n  var input_name_base = input_filename.split('.').slice(0,-1). join('.');\n  return input_name_base + '.count.txt'\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "sbg:fileTypes": "TXT"
          }
        ],
        "doc": "**SAMtools View** tool prints all alignments from a SAM, BAM, or CRAM file to an output file in SAM format (headerless). You may specify one or more space-separated region specifications to restrict output to only those alignments which overlap the specified region(s). Use of region specifications requires a coordinate-sorted and indexed input file (in BAM or CRAM format) [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n####Regions\n\nRegions can be specified as: RNAME[:STARTPOS[-ENDPOS]] and all position coordinates are 1-based. \n\n**Important note:** when multiple regions are given, some alignments may be output multiple times if they overlap more than one of the specified regions.\n\nExamples of region specifications:\n\n- **chr1**  - Output all alignments mapped to the reference sequence named `chr1' (i.e. @SQ SN:chr1).\n\n- **chr2:1000000** - The region on chr2 beginning at base position 1,000,000 and ending at the end of the chromosome.\n\n- **chr3:1000-2000** - The 1001bp region on chr3 beginning at base position 1,000 and ending at base position 2,000 (including both end positions).\n\n- **'\\*'** - Output the unmapped reads at the end of the file. (This does not include any unmapped reads placed on a reference sequence alongside their mapped mates.)\n\n- **.** - Output all alignments. (Mostly unnecessary as not specifying a region at all has the same effect.) [1]\n\n###Common Use Cases\n\nThis tool can be used for: \n\n- Filtering BAM/SAM/CRAM files - options set by the following parameters and input files: **Include reads with all of these flags** (`-f`), **Exclude reads with any of these flags** (`-F`), **Exclude reads with all of these flags** (`-G`), **Read group** (`-r`), **Minimum mapping quality** (`-q`), **Only include alignments in library** (`-l`), **Minimum number of CIGAR bases consuming query sequence** (`-m`), **Subsample fraction** (`-s`), **Read group list** (`-R`), **BED region file** (`-L`)\n- Format conversion between SAM/BAM/CRAM formats - set by the following parameters: **Output format** (`--output-fmt/-O`), **Fast bam compression** (`-1`), **Output uncompressed BAM** (`-u`)\n- Modification of the data which is contained in each alignment - set by the following parameters: **Collapse the backward CIGAR operation** (`-B`), **Read tags to strip** (`-x`)\n- Counting number of alignments in SAM/BAM/CRAM file - set by parameter **Output only count of matching records** (`-c`)\n\n###Changes Introduced by Seven Bridges\n\n- Parameters **Output BAM** (`-b`) and **Output CRAM** (`-C`) were excluded from the wrapper since they are redundant with parameter **Output format** (`--output-fmt/-O`).\n- Parameter **Input format** (`-S`) was excluded from wrapper since it is ignored by the tool (input format is auto-detected).\n- Input file **Index file** was added to the wrapper to enable operations that require an index file for BAM/CRAM files.\n- Parameter **Number of threads** (`--threads/-@`) specifies the total number of threads instead of additional threads. Command line argument (`--threads/-@`) will be reduced by 1 to set the number of additional threads.\n\n###Common Issues and Important Notes\n\n- When multiple regions are given, some alignments may be output multiple times if they overlap more than one of the specified regions [1].\n- Use of region specifications requires a coordinate-sorted and indexed input file (in BAM or CRAM format) [1].\n- Option **Output uncompressed BAM** (`-u`) saves time spent on compression/decompression and is thus preferred when the output is piped to another SAMtools command [1].\n\n###Performance Benchmarking\n\nMultithreading can be enabled by setting parameter **Number of threads** (`--threads/-@`). In the following table you can find estimates of **SAMtools View** running time and cost. \n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*  \n\n| Input type | Input size | # of reads | Read length | Output format | # of threads | Duration | Cost | Instance (AWS)|\n|---------------|--------------|-----------------|---------------|------------------|-------------------|-----------------|-------------|--------|-------------|\n| BAM | 5.26 GB | 71.5M | 76 | BAM | 1 | 13min. | \\$0.12 | c4.2xlarge |\n| BAM | 11.86 GB | 161.2M | 101 | BAM | 1 | 33min. | \\$0.30 | c4.2xlarge |\n| BAM | 18.36 GB | 179M | 76 | BAM | 1 | 60min. | \\$0.54 | c4.2xlarge |\n| BAM | 58.61 GB | 845.6M | 150 | BAM | 1 | 3h 25min. | \\$1.84 | c4.2xlarge |\n| BAM | 5.26 GB | 71.5M | 76 | BAM | 8 | 5min. | \\$0.04 | c4.2xlarge |\n| BAM | 11.86 GB | 161.2M | 101 | BAM | 8 | 11min. | \\$0.10 | c4.2xlarge |\n| BAM | 18.36 GB | 179M | 76 | BAM | 8 | 19min. | \\$0.17 | c4.2xlarge |\n| BAM | 58.61 GB | 845.6M | 150 | BAM | 8 | 61min. | \\$0.55 | c4.2xlarge |\n| BAM | 5.26 GB | 71.5M | 76 | SAM | 8 | 14min. | \\$0.13 | c4.2xlarge |\n| BAM | 11.86 GB | 161.2M | 101 | SAM | 8 | 23min. | \\$0.21 | c4.2xlarge |\n| BAM | 18.36 GB | 179M | 76 | SAM | 8 | 35min. | \\$0.31 | c4.2xlarge |\n| BAM | 58.61 GB | 845.6M | 150 | SAM | 8 | 2h 29min. | \\$1.34 | c4.2xlarge |\n\n###References\n\n[1] [SAMtools documentation](http://www.htslib.org/doc/samtools-1.9.html)",
        "label": "Samtools View",
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n  if (inputs.mem_per_job) {\n      return inputs.mem_per_job\n  }    \n  else {\n  var mem_offset = 1000;\n  if((inputs.in_reference)){\n    mem_offset = mem_offset + 3000;\n  }\n  if((inputs.threads)){\n    var threads = (inputs.threads);\n  }\n  else{\n    threads = 1;\n  }\n  return mem_offset + threads * 500\n  }\n}",
            "coresMin": "${\n  if (inputs.cpu_per_job) {\n      return inputs.cpu_per_job\n  }\n  else {\n  if((inputs.threads)){\n    return (inputs.threads)\n  }\n  else{\n    return 1\n  }\n  }\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/samtools-1-10:1"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.in_reference)",
              "$(inputs.reference_file_list)",
              "$(inputs.in_index)",
              "$(inputs.in_alignments)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "V-pipe tools - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650377083,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650377111,
            "sbg:revisionNotes": "Latest version from dev."
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650434931,
            "sbg:revisionNotes": "JS edited."
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650467736,
            "sbg:revisionNotes": "Added extra argument."
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651822793,
            "sbg:revisionNotes": "Edited for cwltool."
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "samtools",
        "sbg:toolkitVersion": "1.10",
        "sbg:toolAuthor": "Heng Li (Sanger Institute), Bob Handsaker (Broad Institute), Jue Ruan (Beijing Genome Institute), Colin Hercus, Petr Danecek",
        "sbg:license": "MIT License",
        "sbg:categories": [
          "Utilities",
          "SAM/BAM Processing"
        ],
        "sbg:links": [
          {
            "id": "http://www.htslib.org/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/samtools/samtools",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/samtools/samtools/wiki",
            "label": "Wiki"
          },
          {
            "id": "https://sourceforge.net/projects/samtools/files/samtools/",
            "label": "Download"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/19505943",
            "label": "Publication"
          },
          {
            "id": "http://www.htslib.org/doc/samtools-1.9.html",
            "label": "Documentation"
          }
        ],
        "sbg:expand_workflow": false,
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "h-2fd88572/h-995a20d5/h-763ccafb/0",
        "sbg:revision": 4,
        "sbg:revisionNotes": "Edited for cwltool.",
        "sbg:modifiedOn": 1651822793,
        "sbg:modifiedBy": "lea_lenhardt_ackovic",
        "sbg:createdOn": 1650377083,
        "sbg:createdBy": "lea_lenhardt_ackovic",
        "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "lea_lenhardt_ackovic"
        ],
        "sbg:latestRevision": 4,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a1ff43e74547a5b9585c5ed0056d8353bf9e32c022ad044d1bc5557a5191de363",
        "sbg:workflowLanguage": "CWL"
      },
      "label": "Samtools View",
      "scatter": [
        "in_alignments"
      ],
      "sbg:x": 79,
      "sbg:y": -168.5
    },
    {
      "id": "samtools_sort_1_10",
      "in": [
        {
          "id": "in_alignments",
          "source": "samtools_view_1_10/out_alignments"
        }
      ],
      "out": [
        {
          "id": "out_alignments"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/samtools-sort-1-10/3",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "File inputs",
            "id": "in_alignments",
            "type": "File",
            "inputBinding": {
              "shellQuote": false,
              "position": 101
            },
            "label": "Input file",
            "doc": "The input BAM/SAM/CRAM file to be sorted.",
            "sbg:fileTypes": "BAM, CRAM, SAM"
          },
          {
            "sbg:altPrefix": "-@",
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "1",
            "id": "threads",
            "type": "int?",
            "inputBinding": {
              "prefix": "--threads",
              "shellQuote": false,
              "position": 12,
              "valueFrom": "${\n    var self;\n    if (self == 0) {\n        self = null;\n        inputs.threads = null;\n    };\n\n\n    if (inputs.threads) {\n        return inputs.threads - 1\n    } else {\n        return null\n    }\n}"
            },
            "label": "Number of threads",
            "doc": "SAMtools uses argument --threads/-@ to specify number of additional threads. This parameter sets total number of threads (and CPU cores). Command line argument will be reduced by 1 to set number of additional threads. By default, operation is single-threaded.",
            "default": 0
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "6",
            "id": "compression_level",
            "type": "int?",
            "inputBinding": {
              "prefix": "-l",
              "shellQuote": false,
              "position": 2
            },
            "label": "Compression level",
            "doc": "Set the desired compression level for the final output file, ranging from 0 (uncompressed) or 1 (fastest but minimal compression) to 9 (best compression but slowest to write), similarly to gzip's compression level setting."
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "False",
            "id": "sort_by_read_name",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-n",
              "shellQuote": false,
              "position": 4
            },
            "label": "Sort by read name",
            "doc": "Sort by read names (i.e., the QNAME field) rather than by chromosomal coordinates."
          },
          {
            "sbg:altPrefix": "-O",
            "sbg:category": "Config Inputs",
            "id": "output_format",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "BAM",
                  "SAM",
                  "CRAM"
                ],
                "name": "output_format"
              }
            ],
            "inputBinding": {
              "prefix": "--output-fmt",
              "shellQuote": false,
              "position": 9
            },
            "label": "Output format",
            "doc": "Write the final output as SAM, BAM, or CRAM."
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "768M",
            "id": "max_mem_per_thread",
            "type": "string?",
            "inputBinding": {
              "prefix": "-m",
              "shellQuote": false,
              "position": 3
            },
            "label": "Memory per thread",
            "doc": "Approximately the maximum required memory per thread, specified with a G, M, or K suffix. To prevent sort from creating a huge number of temporary files, it enforces a minimum value of 1M for this setting."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "sort_by_tag",
            "type": "string?",
            "inputBinding": {
              "prefix": "-t",
              "shellQuote": false,
              "position": 5
            },
            "label": "Sort by value of tag",
            "doc": "Sort first by the value in the alignment tag, then by position or name (if also using -n)."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "output_filename",
            "type": "string?",
            "inputBinding": {
              "prefix": "-o",
              "shellQuote": false,
              "position": 6,
              "valueFrom": "${\n    if (inputs.output_filename != 'default_filename') {\n        return inputs.output_filename\n    } else {\n        var input_filename = [].concat(inputs.in_alignments)[0].path.split('/').pop();\n        if (inputs.output_format) {\n            var ext = inputs.output_format.toLowerCase();\n        } else {\n            ext = 'bam';\n        }\n        return input_filename.slice(0, input_filename.lastIndexOf('.')) + '.sorted.' + ext\n    }\n}"
            },
            "label": "Output filename",
            "doc": "Define a filename of the output.",
            "default": "default_filename"
          },
          {
            "sbg:category": "Config Inputs",
            "id": "input_fmt_option",
            "type": "string?",
            "inputBinding": {
              "prefix": "--input-fmt-option",
              "shellQuote": false,
              "position": 8
            },
            "label": "Input file format option",
            "doc": "Specify a single input file format option in the form of OPTION or OPTION=VALUE."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "output_fmt_option",
            "type": "string?",
            "inputBinding": {
              "prefix": "--output-fmt-option",
              "shellQuote": false,
              "position": 10
            },
            "label": "Output file format option",
            "doc": "Specify a single output file format option in the form of OPTION or OPTION=VALUE."
          },
          {
            "sbg:category": "File inputs",
            "id": "in_reference",
            "type": "File?",
            "inputBinding": {
              "prefix": "--reference",
              "shellQuote": false,
              "position": 11
            },
            "label": "Reference file",
            "doc": "Reference file. This file is used for compression/decompression of CRAM files. Please provide reference file when using CRAM input/output file.",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BGZF, GZ, BGZF"
          },
          {
            "sbg:category": "Platform Options",
            "sbg:toolDefaultValue": "3072",
            "id": "mem_per_job",
            "type": "int?",
            "label": "Memory per job",
            "doc": "Memory per job in MB."
          },
          {
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "type": "int?",
            "label": "CPU per job",
            "doc": "Number of CPUs per job."
          }
        ],
        "outputs": [
          {
            "id": "out_alignments",
            "doc": "Sorted file.",
            "label": "Sorted file",
            "type": "File",
            "outputBinding": {
              "glob": "${\n    if (inputs.output_filename != 'default_filename') {\n        return inputs.output_filename\n    } else {\n        var input_filename = [].concat(inputs.in_alignments)[0].path.split('/').pop();\n        if (inputs.output_format) {\n            var ext = inputs.output_format.toLowerCase();\n        } else {\n            ext = 'bam';\n        }\n        return input_filename.slice(0, input_filename.lastIndexOf('.')) + '.sorted.' + ext\n    }\n}",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_alignments)\n\n}"
            },
            "sbg:fileTypes": "BAM, SAM, CRAM"
          }
        ],
        "doc": "**SAMtools Sort** tool is used to sort alignments by leftmost coordinates, or by read name when `-n` is used. An appropriate @HD-SO sort order header tag will be added or an existing one updated if necessary [1].\n\nThe sorted output is written to the file specified by the parameter **Output filename** (`-o`) or default filename (in_alignments.sorted.bam for input in_alignments.bam). \n\nThis command will also create temporary files tmpprefix.%d.bam as needed when the entire alignment data cannot fit into memory (as controlled via parameter **Memory per thread** (`-m`)) [1]. \n\nOutput file format is set by the parameter **Output format** (`--output-fmt/-O`). If this parameter is not set, format is recognized from the filename defined by the **Output filename** (`-o`) parameter. If the filename is not set or no format can be deduced, BAM format will be selected. \n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n####Ordering Rules\n\nThe following rules are used for ordering records. If the parameter **Sort by value of tag** (`-t`) is used, records are first sorted by the value of the given alignment tag, and then by position or name (if the parameter **Sort by read name** (`-n`) is set to True). For example, `-t RG` will make read group the primary sort key. The rules for ordering by tag are:  \n- Records that do not have the tag are sorted before the ones that do.\n- If the types of the tags are different, they will be sorted so that single character tags (type A) come before array tags (type B), then string tags (types H and Z), then numeric tags (types f and i).\n- Numeric tags (types f and i) are compared by value. Note that comparisons of floating-point values are subject to issues of rounding and precision.\n- String tags (types H and Z) are compared based on the binary contents of the tag using the C strcmp function.\n- Character tags (type A) are compared by binary character value.\n- No attempt is made to compare tags of other types \u2014 notably type B array values will not be compared.\n\nWhen the parameter **Sort by read name** (`-n`) is set to True, records are sorted by name. Names are compared so as to give a \u201cnatural\u201d ordering \u2014 i.e. sections consisting of digits are compared numerically while all other sections are compared based on their binary representation. This means \u201ca1\u201d will come before \u201cb1\u201d and \u201ca9\u201d will come before \u201ca10\u201d. Records with the same name will be ordered according to the values of the READ1 and READ2 flags.  \nWhen the parameter **Sort by read name** (`-n`) is not set to True, reads are sorted by reference (according to the order of the @SQ header records), then by position in the reference, and then by the REVERSE flag [1].\n\n###Common Use Cases\n\n**SAMtools Sort** is often used as a preprocessing step for other tools that require coordinate or query name sorted BAM/CRAM/SAM file. Some of the tools that require coordinate-sorted input are **SAMtools Index**, **SAMtools View** when using the **Regions array** parameter, **SAMtools Markdup**. Some of the tools that require query name sorted input are **SAMtools Fixmate** and **SAMtools FASTQ** (not required but it is recommended for further processing of FASTQ files). \n\n###Changes Introduced by Seven Bridges\n\n- Parameter for temporary files prefix (`-T`) is omitted from the wrapper because it is not applicable on the platform.\n- Parameter **Number of threads** (`--threads/-@`) specifies the total number of threads instead of additional threads. Command line argument (`--threads/-@`) will be reduced by 1 to set number of additional threads.\n\n###Common Issues and Important Notes\n\n- Parameter **Memory per thread** (`-m`) should be specified either in bytes or with a K, M, or G suffix. The number that precedes suffix should be an integer. To prevent **SAMtools Sort** from creating a huge number of temporary files, it enforces a minimum value of 1M for this setting.\n\n###Performance Benchmarking\n\nBy default, **SAMtools Sort** is single-threaded. Multithreading can be enabled by setting parameter **Number of threads** (`--threads/-@`). Parameter **Memory per thread** (`-m`) does not affect execution time but larger values of this parameter will affect instance type selection which can lead to longer execution and/or larger cost. Instance type also depends on parameter **Number of threads** (`--threads/-@`). Recommended values of these parameters for optimal cost are **Number of threads** = 8, **Memory per thread** = 1G (or None for default settings). \n\nIn the following table you can find estimates of **SAMtools Sort** running time and cost.\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*  \n   \n| Input type | Input size | # of reads | Read length | Sort by read name |  # of threads | Duration | Cost | Instance (AWS)|\n|---------------|--------------|---------------|------------------|---------------------------|------------------|-------------|--------|-------------|\n| BAM | 7.06 GB | 71.5M | 76 | False | 1 | 20min. | \\$0.18 | c4.2xlarge |\n| BAM | 16.21 GB | 161.2M | 101 | False | 1 | 48min. | \\$0.43 | c4.2xlarge |\n| BAM | 24.05 GB | 179M | 76 | False | 1 | 1h 24min. | \\$0.76 | c4.2xlarge |\n| BAM | 89.56 GB | 845.6M | 150 | False | 1 | 5h 23min. | \\$2.90 | c4.2xlarge |\n| BAM | 7.06 GB | 71.5M | 76 | False | 8 | 8min. | \\$0.07 | c4.2xlarge |\n| BAM | 16.21 GB | 161.2M | 101 | False | 8 | 16min. | \\$0.14 | c4.2xlarge |\n| BAM | 24.05 GB | 179M | 76 | False | 8 | 26min. | \\$0.23 | c4.2xlarge |\n| BAM | 89.56 GB | 845.6M | 150 | False | 8 | 1h 37min. | \\$0.87 | c4.2xlarge |\n| BAM | 7.06 GB | 71.5M | 76 | False | 16 | 5min. | \\$0.07 | c5.4xlarge |\n| BAM | 16.21 GB | 161.2M | 101 | False | 16 | 12min. | \\$0.17 | c5.4xlarge |\n| BAM | 24.05 GB | 179M | 76 | False | 16 | 16min. | \\$0.23 | c5.4xlarge |\n| BAM | 89.56 GB | 845.6M | 150 | False | 16 | 56min. | \\$0.8 | c5.4xlarge |\n| BAM | 5.26 GB | 71.5M | 76 | True | 1 | 26min. | \\$0.23 | c4.2xlarge |\n| BAM | 11.86 GB | 161.2M | 101 | True | 1 | 1h 8min. | \\$0.61 | c4.2xlarge |\n| BAM | 18.36 GB | 179M | 76 | True | 1 | 1h 50min. | \\$0.99 | c4.2xlarge |\n| BAM | 58.61 GB | 845.6M | 150 | True | 1 | 7h 11min. | \\$3.88 | c4.2xlarge |\n| BAM | 5.26 GB | 71.5M | 76 | True | 8 | 10min. | \\$0.09 | c4.2xlarge |\n| BAM | 11.86 GB | 161.2M | 101 | True | 8 | 21min. | \\$0.19 | c4.2xlarge |\n| BAM | 18.36 GB | 179M | 76 | True | 8 | 31min. | \\$0.28 | c4.2xlarge |\n| BAM | 58.61 GB | 845.6M | 150 | True | 8 | 2h 5min. | \\$1.12 | c4.2xlarge |\n| BAM | 5.26 GB | 71.5M | 76 | True | 16 | 5min. | \\$0.07 | c5.4xlarge |\n| BAM | 11.86 GB | 161.2M | 101 | True | 16 | 12min. | \\$0.17 | c5.4xlarge |\n| BAM | 18.36 GB | 179M | 76 | True | 16 | 16min. | \\$0.23 | c5.4xlarge |\n| BAM | 58.61 GB | 845.6M | 150 | True | 16 | 56min. | \\$0.8 | c5.4xlarge |\n\n###References\n\n[1] [SAMtools documentation](http://www.htslib.org/doc/samtools-1.9.html)",
        "label": "Samtools Sort",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "/opt/samtools-1.10/samtools"
          },
          {
            "shellQuote": false,
            "position": 1,
            "valueFrom": "sort"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    if (inputs.mem_per_job) {\n        return inputs.mem_per_job\n    }\n    else {\n    var memory_offset = 2048\n\n    if (inputs.in_reference) {\n        memory_offset = memory_offset + 3000\n    }\n\n    if (inputs.threads) {\n        var threads = inputs.threads\n    } else {\n        threads = 1\n    }\n\n    var memory_per_thread = 1024\n    if (inputs.max_mem_per_thread) {\n        if (inputs.max_mem_per_thread.indexOf(\"G\") > 0) {\n            memory_per_thread = parseInt(inputs.max_mem_per_thread.slice(0, inputs.max_mem_per_thread.indexOf('G'))) * 1024\n        } else if (inputs.max_mem_per_thread.indexOf(\"M\") > 0) {\n            memory_per_thread = parseInt(inputs.max_mem_per_thread.slice(0, inputs.max_mem_per_thread.indexOf('M')))\n        } else if ((inputs.max_mem_per_thread.indexOf(\"K\") > 0)) {\n            memory_per_thread = parseInt(inputs.max_mem_per_thread.slice(0, inputs.max_mem_per_thread.indexOf('K'))) / 1024\n        }\n    }\n\n    return memory_offset + threads * memory_per_thread\n    }\n}",
            "coresMin": "${\n    if (inputs.cpu_per_job) {\n        return inputs.cpu_per_job\n    }\n    else {\n    if (inputs.threads) {\n        return inputs.threads\n    } else {\n        return 1\n    }\n    }\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/samtools-1-10:1"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.in_reference)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n"
            ]
          }
        ],
        "sbg:toolAuthor": "Heng Li (Sanger Institute), Bob Handsaker (Broad Institute), Jue Ruan (Beijing Genome Institute), Colin Hercus, Petr Danecek",
        "sbg:toolkit": "SAMtools",
        "sbg:license": "MIT License",
        "sbg:categories": [
          "Utilities",
          "SAM/BAM Processing"
        ],
        "sbg:toolkitVersion": "1.10",
        "sbg:image_url": null,
        "sbg:cmdPreview": "/opt/samtools-1.9/samtools sort  in_alignments.bam",
        "sbg:links": [
          {
            "id": "http://www.htslib.org",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/samtools/samtools",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/samtools/samtools/wiki",
            "label": "Wiki"
          },
          {
            "id": "https://sourceforge.net/projects/samtools/files/samtools/",
            "label": "Download"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/19505943",
            "label": "Publication"
          },
          {
            "id": "http://www.htslib.org/doc/samtools-1.9.html",
            "label": "Documentation"
          }
        ],
        "sbg:projectName": "V-pipe tools - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650376923,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650376985,
            "sbg:revisionNotes": "Latest version from dev."
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650434129,
            "sbg:revisionNotes": "JS edited."
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651822551,
            "sbg:revisionNotes": "Edited for cwltool."
          }
        ],
        "sbg:expand_workflow": false,
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "h-9f55e327/h-420d042f/h-cc53b4a1/0",
        "sbg:revision": 3,
        "sbg:revisionNotes": "Edited for cwltool.",
        "sbg:modifiedOn": 1651822551,
        "sbg:modifiedBy": "lea_lenhardt_ackovic",
        "sbg:createdOn": 1650376923,
        "sbg:createdBy": "lea_lenhardt_ackovic",
        "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "lea_lenhardt_ackovic"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "acd7ce21ab8bc373d2a5a9d2ea9111f928ac8c513096b3a3e1c54ad0a1f64405a",
        "sbg:workflowLanguage": "CWL"
      },
      "label": "Samtools Sort",
      "scatter": [
        "in_alignments"
      ],
      "sbg:x": 227,
      "sbg:y": -78.25
    },
    {
      "id": "samtools_index_1_10",
      "in": [
        {
          "id": "in_alignments",
          "source": "samtools_sort_1_10/out_alignments"
        },
        {
          "id": "output_indexed_data",
          "default": true
        }
      ],
      "out": [
        {
          "id": "indexed_data_file"
        },
        {
          "id": "out_index"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/samtools-index-1-10/3",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "File Inputs",
            "id": "in_alignments",
            "type": "File",
            "inputBinding": {
              "shellQuote": false,
              "position": 100,
              "valueFrom": "${\n    if (inputs.in_index) {\n        var index_ext = [].concat(inputs.in_index)[0].path.substr([].concat(inputs.in_index)[0].path.lastIndexOf('.') + 1);\n        var input_ext = [].concat(inputs.in_alignments)[0].path.substr([].concat(inputs.in_alignments)[0].path.lastIndexOf('.') + 1);\n        var index_format = 'BAI';\n        if (inputs.index_file_format) {\n            index_format = inputs.index_file_format;\n        }\n        if (inputs.minimum_interval_size) {\n            index_format = '';\n        }\n\n        if ((index_ext.toUpperCase() === 'CRAI' && input_ext.toUpperCase() === 'CRAM') ||\n            (index_ext.toUpperCase() === index_format && input_ext.toUpperCase() === 'BAM')) {\n            return null\n        } else {\n            return inputs.in_alignments.path\n        }\n    } else {\n        return inputs.in_alignments.path\n    }\n}"
            },
            "label": "BAM/CRAM input file",
            "doc": "BAM/CRAM input file.",
            "sbg:fileTypes": "BAM, CRAM"
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "False",
            "id": "output_indexed_data",
            "type": "boolean?",
            "label": "Output indexed data file",
            "doc": "Setting this parameter to True will provide BAM file (and BAI file as secondary file) at Indexed data file output port. The default value is False."
          },
          {
            "sbg:category": "File Inputs",
            "id": "in_index",
            "type": "File?",
            "label": "Input index file",
            "doc": "Input index file (CSI, CRAI, or BAI). If an input BAM/CRAM file is already indexed, index file can be provided at this port. If it is provided, the tool will just pass it through. This option is useful for workflows when it is not know in advance if the input BAM/CRAM file has accompanying index file present in the project.",
            "sbg:fileTypes": "BAI, CSI, CRAI"
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "14",
            "id": "minimum_interval_size",
            "type": "int?",
            "inputBinding": {
              "prefix": "-m",
              "shellQuote": false,
              "position": 2,
              "valueFrom": "${\n    var self;\n    if (self == 0) {\n        self = null;\n        inputs.minimum_interval_size = null;\n    };\n\n\n    if (inputs.minimum_interval_size) {\n        if (inputs.in_index) {\n            var index_ext = [].concat(inputs.in_index)[0].path.substr([].concat(inputs.in_index)[0].path.lastIndexOf('.') + 1);\n            var input_ext = [].concat(inputs.in_alignments)[0].path.substr([].concat(inputs.in_alignments)[0].path.lastIndexOf('.') + 1);\n            var index_format = 'BAI';\n            if (inputs.index_file_format) {\n                index_format = inputs.index_file_format;\n            }\n            if (inputs.minimum_interval_size) {\n                index_format = '';\n            }\n\n            if ((index_ext.toUpperCase() === 'CRAI' && input_ext.toUpperCase() === 'CRAM') ||\n                (index_ext.toUpperCase() === index_format && input_ext.toUpperCase() === 'BAM')) {\n                return null\n            } else {\n                return inputs.minimum_interval_size\n            }\n        } else {\n            return inputs.minimum_interval_size\n        }\n    } else {\n        return null\n    }\n}"
            },
            "label": "Minimum interval size (2^INT)",
            "doc": "Set minimum interval size for CSI indices to 2^INT. Default value is 14. Setting this value will force generating CSI index file (if the input file is BAM) regardless of the value of the parameter Format of index file (for BAM files).",
            "default": 0
          },
          {
            "sbg:category": "Config Inputs",
            "sbg:toolDefaultValue": "BAI",
            "id": "index_file_format",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "BAI",
                  "CSI"
                ],
                "name": "index_file_format"
              }
            ],
            "inputBinding": {
              "shellQuote": false,
              "position": 1,
              "valueFrom": "${\n    if (inputs.index_file_format != null) {\n        if (inputs.in_index) {\n            var index_ext = [].concat(inputs.in_index)[0].path.substr([].concat(inputs.in_index)[0].path.lastIndexOf('.') + 1);\n            var input_ext = [].concat(inputs.in_alignments)[0].path.substr([].concat(inputs.in_alignments)[0].path.lastIndexOf('.') + 1);\n            var index_format = inputs.index_file_format;\n            if (inputs.minimum_interval_size) {\n                index_format = '';\n            }\n\n            if ((index_ext.toUpperCase() === 'CRAI' && input_ext.toUpperCase() === 'CRAM') ||\n                (index_ext.toUpperCase() === index_format && input_ext.toUpperCase() === 'BAM')) {\n                return\n            } else {\n                if (inputs.index_file_format === 'BAI') {\n                    return '-b'\n                } else if (inputs.index_file_format === 'CSI') {\n                    return '-c'\n                }\n            }\n        } else {\n            if (inputs.index_file_format === 'BAI') {\n                return '-b'\n            } else if (inputs.index_file_format === 'CSI') {\n                return '-c'\n            }\n        }\n    } else {\n        return null\n    }\n}"
            },
            "label": "Format of index file (for BAM files)",
            "doc": "Choose which file format will be generated for index file (BAI or CSI) if the input is BAM file. In case the input is CRAM file, this will be ignored and the tool will generate CRAI file.",
            "default": null
          },
          {
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "1",
            "id": "threads",
            "type": "int?",
            "inputBinding": {
              "prefix": "-@",
              "shellQuote": false,
              "position": 1,
              "valueFrom": "${\n    var self;\n    if (self == 0) {\n        self = null;\n        inputs.threads = null;\n    };\n\n\n    if (inputs.threads) {\n        if (inputs.in_index) {\n            var index_ext = [].concat(inputs.in_index)[0].path.substr([].concat(inputs.in_index)[0].path.lastIndexOf('.') + 1);\n            var input_ext = [].concat(inputs.in_alignments)[0].path.substr([].concat(inputs.in_alignments)[0].path.lastIndexOf('.') + 1);\n            var index_format = 'BAI';\n            if (inputs.index_file_format) {\n                index_format = inputs.index_file_format;\n            }\n            if (inputs.minimum_interval_size) {\n                index_format = '';\n            }\n\n            if ((index_ext.toUpperCase() === 'CRAI' && input_ext.toUpperCase() === 'CRAM') ||\n                (index_ext.toUpperCase() === index_format && input_ext.toUpperCase() === 'BAM')) {\n                return null\n            } else {\n                return inputs.threads\n            }\n        } else {\n            return inputs.threads\n        }\n    } else {\n        return null\n    }\n}"
            },
            "label": "Number of threads",
            "doc": "Number of threads.",
            "default": 0
          },
          {
            "sbg:category": "File Inputs",
            "sbg:altPrefix": "--reference",
            "id": "in_reference",
            "type": "File?",
            "label": "Reference file",
            "doc": "A FASTA format reference file, optionally compressed by bgzip and ideally indexed by SAMtools Faidx. If an index is not present, one will be generated for you. This file is used for compression/decompression of CRAM files. Please provide reference file when using CRAM input/output file.",
            "sbg:fileTypes": "FASTA, FA, FASTA.GZ, FA.GZ, GZ"
          },
          {
            "sbg:category": "Platform Options",
            "sbg:toolDefaultValue": "1500",
            "id": "mem_per_job",
            "type": "int?",
            "label": "Memory per job",
            "doc": "Memory per job in MB."
          },
          {
            "sbg:category": "Platform Options",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "type": "int?",
            "label": "CPU per job",
            "doc": "Number of CPUs per job."
          }
        ],
        "outputs": [
          {
            "id": "indexed_data_file",
            "doc": "Output BAM/CRAM, along with its index as secondary file.",
            "label": "Indexed data file",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.output_indexed_data === true) {\n        return [].concat(inputs.in_alignments)[0].path.split(\"/\").pop()\n    } else {\n        return ''\n    }\n}",
              "outputEval": "${\n    for (var i = 0; i < self.length; i++){\n        self[i] = inheritMetadata(self[i], inputs.in_alignments);\n        if (self.hasOwnProperty('secondaryFiles')){\n            for (var j = 0; j < self[i].secondaryFiles.length; j++){\n                self[i].secondaryFiles[j] = inheritMetadata(self[i].secondaryFiles[j], inputs.in_alignments);\n            }\n        }\n    }\n    return self;\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              },
              {
                "pattern": ".crai",
                "required": false
              },
              {
                "pattern": "^.bai",
                "required": false
              },
              {
                "pattern": "^.crai",
                "required": false
              },
              {
                "pattern": ".csi",
                "required": false
              },
              {
                "pattern": "^.csi",
                "required": false
              }
            ],
            "sbg:fileTypes": "BAM, CRAM"
          },
          {
            "id": "out_index",
            "doc": "Generated index file (without the indexed data).",
            "label": "Generated index file",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var input_ext = [].concat(inputs.in_alignments)[0].path.substr([].concat(inputs.in_alignments)[0].path.lastIndexOf('.') + 1);\n    if (input_ext.toUpperCase() === 'CRAM') {\n        return '*.crai'\n    } else if (input_ext.toUpperCase() === 'BAM') {\n        var index_format = 'BAI';\n        if (inputs.index_file_format) {\n            index_format = inputs.index_file_format;\n        }\n        if (inputs.minimum_interval_size) {\n            index_format = 'CSI';\n        }\n        return '*.' + index_format.toLowerCase()\n    }\n}",
              "outputEval": "${\n    if (inputs.in_index) {\n        for (var i = 0; i < self.length; i++){\n                self[i] = inheritMetadata(self[i], inputs.in_index);\n    }\n    return self\n    }\n    else {\n    for (var i = 0; i < self.length; i++){\n                self[i] = inheritMetadata(self[i], inputs.in_alignments);\n    }\n    return self;\n    }\n}"
            },
            "sbg:fileTypes": "BAI, CRAI, CSI"
          }
        ],
        "doc": "**SAMtools Index** tool is used to index a coordinate-sorted BAM or CRAM file for fast random access. Note that this does not work with SAM files even if they are bgzip compressed \u2014 to index such files, use tabix instead. This index is needed when region arguments are used to limit **SAMtools View** and similar commands to particular regions of interest. For a CRAM file aln.cram, index file aln.cram.crai will be created; for a BAM file aln.bam, either aln.bam.bai or aln.bam.csi will be created, depending on the index format selected [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases \n\n- When using this tool as a standalone tool, **Input index file** should not be provided. This input is given as an option that is convenient to use in workflows. \n- When using this tool in a workflow, **Input index file** can be provided. In case it is provided, tool execution will be skipped and it will just pass the inputs through. This is useful for workflows which use tools that require an index file when it is not known in advance if the input BAM/CRAM file will have accompanying index file present in the project. If the next tool in the workflow requires an index file as a secondary file, parameter **Output indexed data file** should be set to True. This will provide a BAM/CRAM file at the **Indexed data file** output port along with its index file (BAI/CSI/CRAI) as the secondary file.\n- If a CRAM file is provided at the **BAM/CRAM input file** port, the tool will generate a CRAI index file. If a BAM file is provided, the tool will generate a BAI or CSI index file depending on the parameter **Format of index file (for BAM files)** (`-b/-c`). If no value is set, the tool will generate a BAI index file. Setting the parameter **Minimum interval size (2^INT)** (`-m`) will force the CSI format regardless of the value of the parameter **Format of index file (for BAM files)**.\n\n###Changes Introduced by Seven Bridges\n\n- Parameter **Output filename** is omitted from the wrapper. For a CRAM file aln.cram, output filename will be aln.cram.crai; for a BAM file aln.bam, it will be either aln.bam.bai or aln.bam.csi, depending on the index format selected.\n- Parameter **Output indexed data file** and file input **Input index file** are added to provide additional options for integration with other tools within a workflow. \n\n###Common Issues and Important Notes\n\n- **BAM/CRAM input file** should be sorted by coordinates, not by name. Otherwise, the task will fail.\n- **When using this tool in a workflow, if the next tool in the workflow requires index file as a secondary file, parameter Output indexed data file should be set to True. This will provide BAM/CRAM file at Indexed data file output port along with its index file (BAI/CSI/CRAI) as secondary file.**\n\n###Performance Benchmarking\n\nMultithreading can be enabled by setting parameter **Number of threads** (`-@`). In the following table you can find estimates of **SAMtools Index** running time and cost.\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*  \n\n| Input type | Input size | # of reads | Read length |  # of threads | Duration | Cost | Instance (AWS)|\n|---------------|--------------|---------------|------------------|---------------------|-------------|--------|-------------|\n|  BAM | 5.26 GB | 71.5M | 76 | 1 | 4min. | \\$0.04 | c4.2xlarge |\n|  BAM | 11.86 GB | 161.2M | 101| 1 | 10min. | \\$0.09 | c4.2xlarge |\n|  BAM | 18.36 GB | 179M | 76 | 1 | 12min. | \\$0.11 | c4.2xlarge |\n|  BAM | 58.61 GB | 845.6M | 150 | 1 | 36min. | \\$0.32 | c4.2xlarge |\n|  BAM | 5.26 GB | 71.5M | 76 | 8 | 3min. | \\$0.03 | c4.2xlarge |\n|  BAM | 11.86 GB | 161.2M | 101| 8 | 9min. | \\$0.08 | c4.2xlarge |\n|  BAM | 18.36 GB | 179M | 76 | 8 | 11min. | \\$0.10 | c4.2xlarge |\n|  BAM | 58.61 GB | 845.6M | 150 | 8 | 30min. | \\$0.27 | c4.2xlarge |\n\n###References\n\n[1] [SAMtools documentation](http://www.htslib.org/doc/samtools-1.9.html)",
        "label": "Samtools Index",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    if (inputs.in_index) {\n        var index_ext = [].concat(inputs.in_index)[0].path.substr([].concat(inputs.in_index)[0].path.lastIndexOf('.') + 1);\n        var input_ext = [].concat(inputs.in_alignments)[0].path.substr([].concat(inputs.in_alignments)[0].path.lastIndexOf('.') + 1);\n        var index_format = 'BAI';\n        if (inputs.index_file_format) {\n            index_format = inputs.index_file_format;\n        }\n        if (inputs.minimum_interval_size) {\n            index_format = '';\n        }\n\n        if ((index_ext.toUpperCase() === 'CRAI' && input_ext.toUpperCase() === 'CRAM') ||\n            (index_ext.toUpperCase() === index_format && input_ext.toUpperCase() === 'BAM')) {\n            return \"echo Skipping index step because an index file is provided on the input.\"\n        } else {\n            return \"/opt/samtools-1.10/samtools index\"\n        }\n    } else {\n        return \"/opt/samtools-1.10/samtools index\"\n    }\n}"
          },
          {
            "shellQuote": false,
            "position": 1001,
            "valueFrom": "&& echo $REF_PATH"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    if (inputs.mem_per_job) {\n        return inputs.mem_per_job\n    }\n    else {\n        return 1500\n    }\n}",
            "coresMin": "${\n    if (inputs.cpu_per_job) {\n        return inputs.cpu_per_job\n    }\n    else {\n    var threads = 1\n    if (inputs.threads) {\n        threads = inputs.threads\n    }\n\n    if (inputs.in_index) {\n        var index_ext = [].concat(inputs.in_index)[0].path.substr([].concat(inputs.in_index)[0].path.lastIndexOf('.') + 1)\n        var input_ext = [].concat(inputs.in_alignments)[0].path.substr([].concat(inputs.in_alignments)[0].path.lastIndexOf('.') + 1)\n        var index_format = 'BAI'\n        if (inputs.index_file_format) {\n            index_format = inputs.index_file_format\n        }\n        if (inputs.minimum_interval_size) {\n            index_format = ''\n        }\n\n        if ((index_ext.toUpperCase() === 'CRAI' && input_ext.toUpperCase() === 'CRAM') ||\n            (index_ext.toUpperCase() === index_format && input_ext.toUpperCase() === 'BAM')) {\n            return 1\n        } else {\n            return threads\n        }\n    } else {\n        return threads\n    }\n    }\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/samtools-1-10:1"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.in_alignments)",
              "$(inputs.in_index)",
              "$(inputs.in_reference)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n"
            ]
          }
        ],
        "hints": [
          {
            "class": "sbg:saveLogs",
            "value": "path.log"
          },
          {
            "class": "sbg:saveLogs",
            "value": "job.tree.log"
          }
        ],
        "stdout": "path.log",
        "sbg:toolAuthor": "Heng Li (Sanger Institute), Bob Handsaker (Broad Institute), Jue Ruan (Beijing Genome Institute), Colin Hercus, Petr Danecek",
        "sbg:toolkit": "SAMtools",
        "sbg:image_url": null,
        "sbg:toolkitVersion": "1.10",
        "sbg:cmdPreview": "/opt/samtools-1.9/samtools index /path/to/file.bam",
        "sbg:links": [
          {
            "id": "http://www.htslib.org/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/samtools/samtools",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/samtools/samtools/wiki",
            "label": "Wiki"
          },
          {
            "id": "https://sourceforge.net/projects/samtools/files/",
            "label": "Download"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/19505943",
            "label": "Publication"
          },
          {
            "id": "http://www.htslib.org/doc/samtools-1.9.html",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT License",
        "sbg:categories": [
          "Utilities",
          "SAM/BAM Processing"
        ],
        "sbg:projectName": "V-pipe tools - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650377026,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650377055,
            "sbg:revisionNotes": "Latest version from dev."
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650434178,
            "sbg:revisionNotes": "JS edited."
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651822617,
            "sbg:revisionNotes": "Edited for cwltool."
          }
        ],
        "sbg:expand_workflow": false,
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "h-8aa61144/h-932d220e/h-9d4a821c/0",
        "sbg:revision": 3,
        "sbg:revisionNotes": "Edited for cwltool.",
        "sbg:modifiedOn": 1651822617,
        "sbg:modifiedBy": "lea_lenhardt_ackovic",
        "sbg:createdOn": 1650377026,
        "sbg:createdBy": "lea_lenhardt_ackovic",
        "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "lea_lenhardt_ackovic"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a4931bc3f38656881d3894b53d9f0ab3d6a9dab2a25d0803153c9ead0428025f1",
        "sbg:workflowLanguage": "CWL"
      },
      "label": "Samtools Index",
      "scatter": [
        "in_alignments"
      ],
      "sbg:x": 377.5,
      "sbg:y": -22.75
    },
    {
      "id": "v_pipe_basecount_consensus_sequence_snv_visualisation",
      "in": [
        {
          "id": "in_alignments",
          "source": "samtools_index_1_10/indexed_data_file"
        },
        {
          "id": "in_reference",
          "source": "in_reference"
        },
        {
          "id": "read_length",
          "source": "read_length"
        },
        {
          "id": "shift",
          "source": "shift"
        },
        {
          "id": "alpha",
          "source": "alpha"
        },
        {
          "id": "ignore_indels",
          "source": "ignore_indels"
        },
        {
          "id": "coverage",
          "source": "coverage"
        },
        {
          "id": "posterior_threshold",
          "source": "posterior_threshold"
        },
        {
          "id": "covint",
          "source": "covint"
        },
        {
          "id": "gff_files",
          "source": [
            "gff_files"
          ]
        },
        {
          "id": "metainfo_file",
          "source": "metainfo_file"
        },
        {
          "id": "phylogeny_file",
          "source": "phylogeny_file"
        },
        {
          "id": "primers_file",
          "source": "primers_file"
        },
        {
          "id": "min_read_depth",
          "source": "min_read_depth"
        },
        {
          "id": "min_phred_qual",
          "source": "min_phred_qual"
        },
        {
          "id": "min_freq",
          "source": "min_freq"
        },
        {
          "id": "read_count",
          "source": "read_count"
        },
        {
          "id": "max_coverage",
          "source": "max_coverage"
        },
        {
          "id": "mask_coverage_threshold",
          "source": "mask_coverage_threshold"
        },
        {
          "id": "ambiguous_base_coverage_threshold",
          "source": "ambiguous_base_coverage_threshold"
        },
        {
          "id": "min_read_depth_1",
          "source": "min_read_depth_1"
        },
        {
          "id": "liberal_shift",
          "source": "liberal_shift"
        },
        {
          "id": "overlap",
          "source": "overlap"
        }
      ],
      "out": [
        {
          "id": "out_vcf"
        },
        {
          "id": "out_csv"
        },
        {
          "id": "snv_html_file"
        },
        {
          "id": "alignment_html_file"
        },
        {
          "id": "output_reference_majority"
        },
        {
          "id": "output_reference_ambiguous"
        },
        {
          "id": "out_consensus_major_seq"
        },
        {
          "id": "out_consensus_major_dels_seq"
        },
        {
          "id": "out_consensus_ambig_seq"
        },
        {
          "id": "out_consensus_ambig_dels_seq"
        }
      ],
      "run": {
        "class": "Workflow",
        "cwlVersion": "v1.2",
        "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/v-pipe-basecount-consensus-sequence-snv-visualisation/7",
        "doc": "This workflow is meant to be used as inner workflow of V-pipe workflow. It was implemented as inner workflow so it could be used for processing multiple samples in V-pipe.",
        "label": "V-pipe Basecount/Consensus sequence/SNV/Consensus/Visualisation",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "inputs": [
          {
            "id": "in_alignments",
            "sbg:fileTypes": "BAM, CRAM",
            "type": "File",
            "label": "Input BAM/CRAM file",
            "doc": "Input alignments in BAM or CRAM format.",
            "sbg:x": 0,
            "sbg:y": 642
          },
          {
            "id": "in_reference",
            "sbg:fileTypes": "FASTA",
            "type": "File?",
            "label": "Input reference",
            "doc": "Reference file.",
            "sbg:x": 0,
            "sbg:y": 535
          },
          {
            "id": "read_length",
            "type": "int",
            "label": "Read length",
            "doc": "Read length.",
            "sbg:x": 0,
            "sbg:y": 107
          },
          {
            "id": "shift",
            "type": "int?",
            "label": "Shift",
            "doc": "ShoRAH performs local haplotype reconstruction on windows of the read alignment. The overlap between these windows is defined by the window shifts.",
            "sbg:x": 0,
            "sbg:y": 0
          },
          {
            "id": "alpha",
            "type": "float?",
            "label": "Alpha",
            "doc": "Hyperparameter used for instantiating a new cluster.",
            "sbg:exposed": true
          },
          {
            "id": "ignore_indels",
            "type": "boolean?",
            "label": "Ignore indels",
            "doc": "Ignore SNVs adjacent to indels.",
            "sbg:exposed": true
          },
          {
            "id": "coverage",
            "type": "int?",
            "label": "Coverage",
            "doc": "Omit windows with coverage less than this value.",
            "sbg:exposed": true
          },
          {
            "id": "posterior_threshold",
            "type": "float?",
            "label": "Posterior threshold",
            "doc": "Posterior threshold.",
            "sbg:exposed": true
          },
          {
            "id": "covint",
            "type": "int?",
            "label": "Intervals coverage",
            "doc": "Minimum read depth. A region spanning the reference genome is returned if `coverage` is set to 0.\".",
            "sbg:exposed": true
          },
          {
            "id": "gff_files",
            "sbg:fileTypes": "GTF, GFF3, GFF",
            "type": "File[]?",
            "label": "GFF files",
            "doc": "GFF files.",
            "sbg:x": 0,
            "sbg:y": 749
          },
          {
            "id": "metainfo_file",
            "sbg:fileTypes": "YAML",
            "type": "File?",
            "label": "Metainfo file",
            "doc": "Metainfo file.",
            "sbg:x": 0,
            "sbg:y": 428
          },
          {
            "id": "phylogeny_file",
            "sbg:fileTypes": "FASTA",
            "type": "File?",
            "label": "Phylogeny file",
            "doc": "Phylogeny file.",
            "sbg:x": 0,
            "sbg:y": 321
          },
          {
            "id": "primers_file",
            "sbg:fileTypes": "TSV",
            "type": "File?",
            "label": "Primers file",
            "doc": "Primers file.",
            "sbg:x": 0,
            "sbg:y": 214
          },
          {
            "id": "threads",
            "type": "int?",
            "label": "Threads",
            "doc": "Number of threads.",
            "sbg:exposed": true
          },
          {
            "id": "min_read_depth",
            "type": "int?",
            "label": "Minimum read depth",
            "doc": "Minimum read depth for reporting variants per locus (default: 50).",
            "sbg:exposed": true
          },
          {
            "id": "min_phred_qual",
            "type": "int?",
            "label": "Minimum phred quality score",
            "doc": "Minimum phred quality score a base has to reach to be counted (default: 15).",
            "sbg:exposed": true
          },
          {
            "id": "min_freq",
            "type": "float?",
            "label": "Minimum frequency",
            "doc": "Minimum frequency for an ambiguous nucleotide (default: 0.05).",
            "sbg:exposed": true
          },
          {
            "id": "read_count",
            "type": "int?",
            "label": "Read count threshold",
            "doc": "Read count below which ambiguous base 'n' is reported (default: None).",
            "sbg:exposed": true
          },
          {
            "id": "max_coverage",
            "type": "int?",
            "label": "Maximum coverage",
            "doc": "Maximum coverage.",
            "sbg:exposed": true
          },
          {
            "id": "mask_coverage_threshold",
            "type": "int?",
            "label": "Mask coverage threshold",
            "doc": "Mask coverage threshold. Default is 10.",
            "sbg:exposed": true
          },
          {
            "id": "ambiguous_base_coverage_threshold",
            "type": "float?",
            "label": "Ambiguous base coverage threshold",
            "doc": "Frequency threshold to include a variant in computation of ambiguous code.",
            "sbg:exposed": true
          },
          {
            "id": "min_read_depth_1",
            "type": "int?",
            "label": "Minimum read depth per window",
            "doc": "Minimum read depth per window (default: 100).",
            "sbg:exposed": true
          },
          {
            "id": "liberal_shift",
            "type": "boolean?",
            "label": "Apply a more liberal shift",
            "doc": "Indicate whether to apply a more liberal shift on intervals' right-endpoint (default: False).",
            "sbg:exposed": true
          },
          {
            "id": "overlap",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "True",
                  "False"
                ],
                "name": "overlap"
              }
            ],
            "label": "Overlap",
            "doc": "Construct intervals based on overlapping windows of the read alignment. By default, regions with high coverage are built based on the position-wise read depth.",
            "sbg:exposed": true
          }
        ],
        "outputs": [
          {
            "id": "out_vcf",
            "outputSource": [
              "shorah_shotgun_1_99_2/out_vcf"
            ],
            "sbg:fileTypes": "VCF",
            "type": "File?",
            "label": "VCF file with variants",
            "doc": "VCF file with variants.",
            "sbg:x": 1816.7265625,
            "sbg:y": -280.70074462890625
          },
          {
            "id": "out_csv",
            "outputSource": [
              "shorah_shotgun_1_99_2/out_csv"
            ],
            "sbg:fileTypes": "CSV",
            "type": "File?",
            "label": "CSV file with variants",
            "doc": "Variants in CSV format.",
            "sbg:x": 1805.7974853515625,
            "sbg:y": -140.91334533691406
          },
          {
            "id": "snv_html_file",
            "outputSource": [
              "generate_web_visualization/snv_html_file"
            ],
            "sbg:fileTypes": "HTML",
            "type": "File?",
            "label": "SNV callling HTML report",
            "doc": "SNV callling HTML report.",
            "sbg:x": 1811.16015625,
            "sbg:y": -10.724390983581543
          },
          {
            "id": "alignment_html_file",
            "outputSource": [
              "generate_web_visualization/alignment_html_file"
            ],
            "sbg:fileTypes": "HTML",
            "type": "File?",
            "label": "Alignment HTML report",
            "doc": "Alignment HTML report.",
            "sbg:x": 1819.3570556640625,
            "sbg:y": 128.56698608398438
          },
          {
            "id": "output_reference_majority",
            "outputSource": [
              "bcftools_consensus_1_13_majority/output_reference"
            ],
            "sbg:fileTypes": "FASTA",
            "type": "File?",
            "label": "Output consensus majority sequence",
            "doc": "Output consensus majority sequence in FASTA format.",
            "sbg:x": 1834.1090087890625,
            "sbg:y": 293.6771545410156
          },
          {
            "id": "output_reference_ambiguous",
            "outputSource": [
              "bcftools_consensus_1_13_ambig/output_reference"
            ],
            "sbg:fileTypes": "FASTA",
            "type": "File?",
            "label": "Output consensus ambiguous sequence",
            "doc": "Output consensus ambiguous sequence in FASTA format.",
            "sbg:x": 1836.84130859375,
            "sbg:y": 447.1259765625
          },
          {
            "id": "out_consensus_major_seq",
            "outputSource": [
              "smallgenomeutilities_extract_consensus_0_3_6/out_consensus_major_seq"
            ],
            "sbg:fileTypes": "FASTA",
            "type": "File?",
            "label": "Consensus sequences majority",
            "doc": "Consensus sequences including the majority base as FASTA files.",
            "sbg:x": 1800.7354736328125,
            "sbg:y": 630.50390625
          },
          {
            "id": "out_consensus_major_dels_seq",
            "outputSource": [
              "smallgenomeutilities_extract_consensus_0_3_6/out_consensus_major_dels_seq"
            ],
            "sbg:fileTypes": "FASTA",
            "type": "File?",
            "label": "Consensus sequences majority dels",
            "doc": "Consensus sequences including the majority base as FASTA files.",
            "sbg:x": 1798.003173828125,
            "sbg:y": 770.2913208007812
          },
          {
            "id": "out_consensus_ambig_seq",
            "outputSource": [
              "smallgenomeutilities_extract_consensus_0_3_6/out_consensus_ambig_seq"
            ],
            "sbg:fileTypes": "FASTA",
            "type": "File?",
            "label": "Consensus ambiguous reference sequences",
            "doc": "Consensus sequences including the ambiguous bases as FASTA files.",
            "sbg:x": 1803.4677734375,
            "sbg:y": 904.6141357421875
          },
          {
            "id": "out_consensus_ambig_dels_seq",
            "outputSource": [
              "smallgenomeutilities_extract_consensus_0_3_6/out_consensus_ambig_dels_seq"
            ],
            "sbg:fileTypes": "FASTA",
            "type": "File?",
            "label": "Consensus sequences ambiguous dels",
            "doc": "Consensus sequences including either the majority base or the ambiguous bases as FASTA files.",
            "sbg:x": 1814.39697265625,
            "sbg:y": 1028.0078125
          }
        ],
        "steps": [
          {
            "id": "smallgenomeutilities_aln2basecnt_0_3_6",
            "in": [
              {
                "id": "in_alignments",
                "source": "in_alignments"
              }
            ],
            "out": [
              {
                "id": "out_basecnt"
              },
              {
                "id": "out_coverage"
              },
              {
                "id": "out_stats"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/smallgenomeutilities-aln2basecnt-0-3-6/1",
              "baseCommand": [
                "aln2basecnt"
              ],
              "inputs": [
                {
                  "sbg:category": "File Inputs",
                  "id": "in_alignments",
                  "type": "File",
                  "inputBinding": {
                    "shellQuote": false,
                    "position": 100
                  },
                  "label": "Input BAM/CRAM file",
                  "doc": "Input alignments in BAM or CRAM format.",
                  "sbg:fileTypes": "BAM, CRAM",
                  "secondaryFiles": [
                    {
                      "pattern": ".bai",
                      "required": true
                    }
                  ]
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:altPrefix": "-b",
                  "id": "basecnt",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--basecnt",
                    "shellQuote": false,
                    "position": 1,
                    "valueFrom": "${\n    if (self == 'basecnt.tsv.gz'){\n        return inputs.in_alignments.metadata['sample_id']+'_basecnt.tsv.gz'\n    }\n}"
                  },
                  "label": "Bases count table output file name",
                  "doc": "Bases count table output file name with TSV extension.",
                  "default": "basecnt.tsv.gz"
                },
                {
                  "sbg:altPrefix": "-c",
                  "sbg:category": "Config Inputs",
                  "id": "coverage",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--coverage",
                    "shellQuote": false,
                    "position": 2,
                    "valueFrom": "${\n    if (self == 'coverage.tsv.gz'){\n        return inputs.in_alignments.metadata['sample_id']+'_coverage.tsv.gz'\n    }\n}"
                  },
                  "label": "Coverage table output file name",
                  "doc": "Coverage table output file name with  TSV extension",
                  "default": "coverage.tsv.gz"
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "name",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--name",
                    "shellQuote": false,
                    "position": 3,
                    "valueFrom": "${\n    if (self=='name'){\n        return inputs.in_alignments.metadata['sample_id']\n    }\n}"
                  },
                  "label": "Patient/sample ID",
                  "doc": "Patient/sample identifiers to use in coverage column title instead of 'coverage'.",
                  "default": "name"
                },
                {
                  "sbg:altPrefix": "-A",
                  "sbg:category": "Config Inputs",
                  "id": "alphabet",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--alphabet",
                    "shellQuote": false,
                    "position": 4
                  },
                  "label": "Alphabet to use",
                  "doc": "Alphabet to use."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "stats",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--stats",
                    "shellQuote": false,
                    "position": 5,
                    "valueFrom": "${\n    if (self=='REF_aln_stats.yaml'){\n        return inputs.in_alignments.metadata['sample_id']+'_stats.yaml'\n    }\n}"
                  },
                  "label": "File to write stats to",
                  "doc": "File to write stats to. Extension must be  YAML, JSON or INI.",
                  "default": "REF_aln_stats.yaml"
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "1500",
                  "id": "mem_per_job",
                  "type": "int?",
                  "label": "Memory per job",
                  "doc": "Memory per job [MB]."
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "1",
                  "id": "cpu_per_job",
                  "type": "int?",
                  "label": "CPU per job",
                  "doc": "Number of CPUs per job."
                }
              ],
              "outputs": [
                {
                  "id": "out_basecnt",
                  "doc": "Bases count table.",
                  "label": "Bases count table",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*basecnt.tsv.gz",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "TSV, TSV.GZ"
                },
                {
                  "id": "out_coverage",
                  "doc": "Coverage table.",
                  "label": "Coverage table",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*coverage.tsv.gz",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "TSV, TSV.GZ"
                },
                {
                  "id": "out_stats",
                  "doc": "Stats file.",
                  "label": "Stats file",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*.yaml",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "YAML, JSON, INI"
                }
              ],
              "doc": "**smallgenomeutilities aln2basecnt** extracts base counts and coverage information from a single alignment file.",
              "label": "smallgenomeutilities aln2basecnt",
              "requirements": [
                {
                  "class": "ShellCommandRequirement"
                },
                {
                  "class": "ResourceRequirement",
                  "ramMin": "${\n    if(inputs.mem_per_job){\n        return inputs.mem_per_job\n    }\n    else{\n        return 1500\n    }\n}",
                  "coresMin": "${\n    if(inputs.cpu_per_job){\n        return inputs.cpu_per_job\n    }\n    else{\n        return 1\n    }\n}"
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/smallgenomeutilities-0-3-6:0"
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377146,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377181,
                  "sbg:revisionNotes": "Latest version from dev."
                }
              ],
              "sbg:image_url": null,
              "sbg:toolkit": "smallgenomeutilities",
              "sbg:toolkitVersion": "0.3.6",
              "sbg:toolAuthor": "David Seifert, Susana Posada Cespedes, Ivan Blagoev Topolsky and Lara Fuhrmann",
              "sbg:license": "GNU General Public License v2.0",
              "sbg:links": [
                {
                  "id": "https://github.com/cbg-ethz/smallgenomeutilities",
                  "label": "Homepage"
                },
                {
                  "id": "https://github.com/cbg-ethz/smallgenomeutilities/releases/tag/0.3.6",
                  "label": "Source Code"
                },
                {
                  "id": "https://github.com/cbg-ethz/smallgenomeutilities/archive/refs/tags/0.3.6.tar.gz",
                  "label": "Download"
                }
              ],
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-a4a37ec0/h-9d22d809/h-039be1bd/0",
              "sbg:revision": 1,
              "sbg:revisionNotes": "Latest version from dev.",
              "sbg:modifiedOn": 1650377181,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650377146,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 1,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "ae0448a0e4a23eb89cf09c1ddbd79a4f59cba695c5f07381cbec4163f75453c26",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "smallgenomeutilities aln2basecnt",
            "sbg:x": 300.825927734375,
            "sbg:y": 329.97637939453125
          },
          {
            "id": "smallgenomeutilities_extract_coverage_intervals_0_3_6",
            "in": [
              {
                "id": "in_alignments",
                "source": "in_alignments"
              },
              {
                "id": "in_coverage",
                "source": "smallgenomeutilities_aln2basecnt_0_3_6/out_coverage"
              },
              {
                "id": "min_read_depth",
                "default": 50,
                "source": "min_read_depth_1"
              },
              {
                "id": "liberal_shift",
                "default": true,
                "source": "liberal_shift"
              },
              {
                "id": "overlap",
                "default": "False",
                "source": "overlap"
              },
              {
                "id": "read_length",
                "source": "read_length"
              },
              {
                "id": "shift",
                "default": 3,
                "source": "shift"
              }
            ],
            "out": [
              {
                "id": "coverage_intervals"
              },
              {
                "id": "bash_script"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/smallgenomeutilities-extract-coverage-intervals-0-3-6/9",
              "baseCommand": [],
              "inputs": [
                {
                  "sbg:category": "File Inputs",
                  "id": "in_alignments",
                  "type": "File?",
                  "inputBinding": {
                    "shellQuote": false,
                    "position": 65,
                    "valueFrom": "${\n    return '\"'+ self.path+'\"'\n}"
                  },
                  "label": "Input BAM file",
                  "doc": "Input BAM file.",
                  "sbg:fileTypes": "BAM",
                  "secondaryFiles": [
                    {
                      "pattern": ".bai",
                      "required": true
                    }
                  ]
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_intervals",
                  "type": "File?",
                  "inputBinding": {
                    "prefix": "-r",
                    "shellQuote": false,
                    "position": 50
                  },
                  "label": "Region BED file",
                  "doc": "Region of interested in BED format, e.g. HXB2:2253-3869. Loci are interpreted using 0-based indexing, and a half-open interval is used, i.e, [start:end)(default: None).",
                  "sbg:fileTypes": "BED"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_coverage",
                  "type": "File?",
                  "label": "Coverage file",
                  "doc": "File containing coverage per locus per sample. Samples are expected as columns and loci as rows. This option is not compatible with the read-window overlap thresholding (default: None).",
                  "sbg:fileTypes": "TSV"
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "100",
                  "id": "min_read_depth",
                  "type": "int?",
                  "inputBinding": {
                    "prefix": "-c",
                    "shellQuote": false,
                    "position": 52,
                    "valueFrom": "${\n    return '\"'+ self+'\"'\n}"
                  },
                  "label": "Minimum read depth per window",
                  "doc": "Minimum read depth per window (default: 100)."
                },
                {
                  "sbg:category": "Config Input",
                  "sbg:toolDefaultValue": "0.85",
                  "id": "threshold_overlap",
                  "type": "float?",
                  "inputBinding": {
                    "prefix": "-f",
                    "shellQuote": false,
                    "position": 53
                  },
                  "label": "Threshold on the overlap between each read and the window",
                  "doc": "Threshold on the overlap between each read and the window (default: 0.85)."
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "201",
                  "id": "wind_length",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "-w",
                    "shellQuote": false,
                    "position": 54,
                    "valueFrom": "${\n    if(self=='default'){\n        var calc = Math.floor(((inputs.read_length*4/5+inputs.shift)/inputs.shift))*inputs.shift;\n        return '\"'+ calc +'\"'\n    }\n    return '\"'+ self+'\"'\n}"
                  },
                  "label": "Window length used by ShoRAH",
                  "doc": "Window length used by ShoRAH (default: 201).",
                  "default": "default"
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "67",
                  "id": "wind_shift",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "-s",
                    "shellQuote": false,
                    "position": 55,
                    "valueFrom": "${\n    if(self=='default'){\n        var calc = Math.floor(((inputs.read_length*0.8)+inputs.shift)/inputs.shift);\n        return '\"'+ calc +'\"'\n    }\n    return '\"'+ self+'\"'\n}"
                  },
                  "label": "Window shifts used by ShoRAH",
                  "doc": "Window shifts used by ShoRAH (default: 67).",
                  "default": "default"
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "False",
                  "id": "liberal_shift",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "-e",
                    "shellQuote": false,
                    "position": 57
                  },
                  "label": "Apply a more liberal shift",
                  "doc": "Indicate whether to apply a more liberal shift on intervals' right-endpoint (default: False)."
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "False",
                  "id": "no_shorah",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--no-shorah",
                    "shellQuote": false,
                    "position": 58
                  },
                  "label": "No ShoRAH",
                  "doc": "Inidcate whether to report regions with sufficient coverage rather than windows for SNV calling using ShoRAH (default: False)"
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "1",
                  "id": "threads",
                  "type": "int?",
                  "inputBinding": {
                    "prefix": "-t",
                    "shellQuote": false,
                    "position": 59,
                    "valueFrom": "${\n    return '\"'+ self+'\"'\n}"
                  },
                  "label": "Number of threads",
                  "doc": "Number of threads (default: 1)."
                },
                {
                  "sbg:toolDefaultValue": "coverage_intervals.tsv",
                  "sbg:category": "Config Inputs",
                  "id": "output_name",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "-o",
                    "shellQuote": false,
                    "position": 60
                  },
                  "label": "Output file name",
                  "doc": "Output file name (default: coverage_intervals.tsv).",
                  "default": "temp_intervals.tsv"
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "1500",
                  "id": "mem_per_job",
                  "type": "int?",
                  "label": "Memory per job",
                  "doc": "Memory per job [MB]."
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "1",
                  "id": "cpu_per_job",
                  "type": "int?",
                  "label": "CPU per job",
                  "doc": "Number of CPUs per job."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "overlap",
                  "type": [
                    "null",
                    {
                      "type": "enum",
                      "symbols": [
                        "True",
                        "False"
                      ],
                      "name": "overlap"
                    }
                  ],
                  "inputBinding": {
                    "shellQuote": false,
                    "position": 57,
                    "valueFrom": "${\n    if (self=='False'){\n        return '-cf temp_coverage.tsv'\n    }\n    else{\n        return ''\n    }\n}"
                  },
                  "label": "Overlap",
                  "doc": "Construct intervals based on overlapping windows of the read alignment. By default, regions with high coverage are built based on the position-wise read depth."
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "250",
                  "id": "read_length",
                  "type": "int?",
                  "label": "Read length",
                  "doc": "Read length."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "shift",
                  "type": "int?",
                  "label": "Shift",
                  "doc": "ShoRAH performs local haplotype reconstruction on windows of the read alignment. The overlap between these windows is defined by the window shifts."
                }
              ],
              "outputs": [
                {
                  "id": "coverage_intervals",
                  "doc": "Coverage intervals.",
                  "label": "Coverage intervals",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*coverage_intervals.tsv",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "TSV"
                },
                {
                  "id": "bash_script",
                  "doc": "Executed bash script.",
                  "label": "Executed bash script",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*.sh"
                  },
                  "sbg:fileTypes": "SH"
                }
              ],
              "doc": "**smallgenomeutilities extract_coverage_intervals** extracts regions with sufficient coverage for running ShoRAH. Half-open intervals are returned, [start:end), and 0-based indexing is used.\n\n##Changes introduced by Seven Bridges\n\n*  This wrapper has additional command lines customised for running this tool inside V-pipe workflow.",
              "label": "smallgenomeutilities extract_coverage_intervals",
              "arguments": [
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 49,
                  "valueFrom": "extract_coverage_intervals"
                },
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 0,
                  "valueFrom": "${\n    return '/bin/bash -c \\'gunzip -c ' + inputs.in_coverage.path + ' | cut -f\\'2-\\' > temp_coverage.tsv ; if [[ ${PIPESTATUS[@]} == \"0 0\" ]]; then echo \"Everything OK\"; else exit 1; fi &&'\n}"
                },
                {
                  "prefix": "-N",
                  "shellQuote": false,
                  "position": 56,
                  "valueFrom": "${\n    return '\"'+inputs.in_alignments.metadata['sample_id']+'\"'\n}"
                },
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 100,
                  "valueFrom": "${\n    return '&& bash make_tsv.sh\\''\n}"
                }
              ],
              "requirements": [
                {
                  "class": "ShellCommandRequirement"
                },
                {
                  "class": "ResourceRequirement",
                  "ramMin": "${\n    if(inputs.mem_per_job){\n        return inputs.mem_per_job\n    }\n    else{\n        return 1500\n    }\n}",
                  "coresMin": "${\n    if(inputs.threads){\n        return inputs.threads\n    }\n    else if(inputs.cpu_per_job){\n        return inputs.cpu_per_job\n    }\n    else{\n        return 1\n    }\n}"
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/smallgenomeutilities-0-3-6:0"
                },
                {
                  "class": "InitialWorkDirRequirement",
                  "listing": [
                    {
                      "entryname": "make_tsv.sh",
                      "entry": "${\n    var cmd = '#!/bin/bash\\ncat temp_intervals.tsv > '+inputs.in_alignments.metadata['sample_id']+'_coverage_intervals.out.log\\nread name intervals < temp_intervals.tsv\\nIFS=\\',\\' read -r -a interarray <<< \"$intervals\"\\nprintf \"%s\\\\n\" \"${interarray[@]}\" > ' + inputs.in_alignments.metadata['sample_id'] + '.coverage_intervals.tsv';\n    return cmd\n}",
                      "writable": false
                    }
                  ]
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377272,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377296,
                  "sbg:revisionNotes": "Latest version from dev."
                },
                {
                  "sbg:revision": 2,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650434984,
                  "sbg:revisionNotes": "JS edited."
                },
                {
                  "sbg:revision": 3,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650460030,
                  "sbg:revisionNotes": "Added inputs"
                },
                {
                  "sbg:revision": 4,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650461611,
                  "sbg:revisionNotes": "Removed shell quote for overlap."
                },
                {
                  "sbg:revision": 5,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650466287,
                  "sbg:revisionNotes": "Added calculation for window and shift."
                },
                {
                  "sbg:revision": 6,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650518999,
                  "sbg:revisionNotes": "Removed double -cf parameter."
                },
                {
                  "sbg:revision": 7,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650520828,
                  "sbg:revisionNotes": "in_coverage changed to unbound."
                },
                {
                  "sbg:revision": 8,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1653030041,
                  "sbg:revisionNotes": "Added pipe status check."
                },
                {
                  "sbg:revision": 9,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1653032929,
                  "sbg:revisionNotes": "Added missing single quote"
                }
              ],
              "sbg:image_url": null,
              "sbg:license": "GNU General Public License v2.0",
              "sbg:links": [
                {
                  "id": "https://github.com/cbg-ethz/smallgenomeutilities",
                  "label": "Homepage"
                },
                {
                  "id": "https://github.com/cbg-ethz/smallgenomeutilities/releases/tag/0.3.6",
                  "label": "Source Code"
                },
                {
                  "id": "https://github.com/cbg-ethz/smallgenomeutilities/archive/refs/tags/0.3.6.tar.gz",
                  "label": "Download"
                }
              ],
              "sbg:toolAuthor": "David Seifert, Susana Posada Cespedes, Ivan Blagoev Topolsky and Lara Fuhrmann",
              "sbg:toolkit": "smallgenomeutilities",
              "sbg:toolkitVersion": "0.3.6",
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-ad48a00b/h-3ec9c860/h-46d82022/0",
              "sbg:revision": 9,
              "sbg:revisionNotes": "Added missing single quote",
              "sbg:modifiedOn": 1653032929,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650377272,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 9,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "a8984455979797df6440917a7e468828f8913a41f44277bbae4705943048b288d",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "smallgenomeutilities extract_coverage_intervals",
            "sbg:x": 497.5503234863281,
            "sbg:y": 126.40943908691406
          },
          {
            "id": "smallgenomeutilities_extract_consensus_0_3_6",
            "in": [
              {
                "id": "in_reference",
                "source": "in_reference"
              },
              {
                "id": "min_read_depth",
                "default": 50,
                "source": "min_read_depth"
              },
              {
                "id": "min_phred_qual",
                "default": 15,
                "source": "min_phred_qual"
              },
              {
                "id": "min_freq",
                "default": 0.05,
                "source": "min_freq"
              },
              {
                "id": "read_count",
                "default": 5,
                "source": "read_count"
              },
              {
                "id": "sample_id",
                "default": "default",
                "valueFrom": "${\n    if (self=='default'){\n        return inputs.in_alignments.metadata['sample_id']\n    }\n}"
              },
              {
                "id": "in_alignments",
                "source": "in_alignments"
              }
            ],
            "out": [
              {
                "id": "out_consensus_ambig_seq"
              },
              {
                "id": "out_consensus_ambig_dels_seq"
              },
              {
                "id": "out_consensus_major_seq"
              },
              {
                "id": "out_consensus_major_dels_seq"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/smallgenomeutilities-extract-consensus-0-3-6/3",
              "baseCommand": [
                "extract_consensus"
              ],
              "inputs": [
                {
                  "sbg:category": "File Inputs",
                  "id": "in_reference",
                  "type": "File?",
                  "inputBinding": {
                    "prefix": "-f",
                    "shellQuote": false,
                    "position": 1
                  },
                  "label": "Input reference",
                  "doc": "Reference file.",
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_interval",
                  "type": "File?",
                  "inputBinding": {
                    "prefix": "-r",
                    "shellQuote": false,
                    "position": 2
                  },
                  "label": "BED file",
                  "doc": "Region of interested in BED format, e.g. HXB2:2253-3869. Loci are interpreted using 0-based indexing, and a half-open interval is used, i.e, [start:end) (default: None)",
                  "sbg:fileTypes": "BED"
                },
                {
                  "sbg:toolDefaultValue": "50",
                  "sbg:category": "Config Inputs",
                  "id": "min_read_depth",
                  "type": "int?",
                  "inputBinding": {
                    "prefix": "-c",
                    "shellQuote": false,
                    "position": 3
                  },
                  "label": "Minimum read depth",
                  "doc": "Minimum read depth for reporting variants per locus (default: 50)."
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "15",
                  "id": "min_phred_qual",
                  "type": "int?",
                  "inputBinding": {
                    "prefix": "-q",
                    "shellQuote": false,
                    "position": 4
                  },
                  "label": "Minimum phred quality score",
                  "doc": "Minimum phred quality score a base has to reach to be counted (default: 15)."
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "0.05",
                  "id": "min_freq",
                  "type": "float?",
                  "inputBinding": {
                    "prefix": "-a",
                    "shellQuote": false,
                    "position": 5
                  },
                  "label": "Minimum frequency",
                  "doc": "Minimum frequency for an ambiguous nucleotide (default: 0.05)."
                },
                {
                  "sbg:toolDefaultValue": "None",
                  "sbg:category": "Config Inputs",
                  "id": "read_count",
                  "type": "int?",
                  "inputBinding": {
                    "prefix": "-n",
                    "shellQuote": false,
                    "position": 6
                  },
                  "label": "Read count threshold",
                  "doc": "Read count below which ambiguous base 'n' is reported (default: None)."
                },
                {
                  "sbg:toolDefaultValue": "CONSENSUS",
                  "sbg:category": "Config Inputs",
                  "id": "sample_id",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "-N",
                    "shellQuote": false,
                    "position": 7
                  },
                  "label": "Patient/sample identifier",
                  "doc": "Patient/sample identifier (default: CONSENSUS)."
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "/opt",
                  "id": "output_dir",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "-o",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "Output directory",
                  "doc": "Output directory (default: /opt)"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_alignments",
                  "type": "File?",
                  "inputBinding": {
                    "prefix": "-i",
                    "shellQuote": false,
                    "position": 0
                  },
                  "label": "Input BAM file",
                  "doc": "Input BAM file.",
                  "sbg:fileTypes": "BAM",
                  "secondaryFiles": [
                    {
                      "pattern": ".bai",
                      "required": true
                    }
                  ]
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "1500",
                  "id": "mem_per_job",
                  "type": "int?",
                  "label": "Memory per job",
                  "doc": "Memory per job [MB]."
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "1",
                  "id": "cpu_per_job",
                  "type": "int?",
                  "label": "CPU per job",
                  "doc": "Number of CPUs per job."
                }
              ],
              "outputs": [
                {
                  "id": "out_consensus_ambig_seq",
                  "doc": "Consensus sequences including the ambiguous bases as FASTA files.",
                  "label": "Consensus ambiguous reference sequences",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*ambig.fasta",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "id": "out_consensus_ambig_dels_seq",
                  "doc": "Consensus sequences including either the majority base or the ambiguous bases as FASTA files.",
                  "label": "Consensus sequences ambiguous dels",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*ambig_dels.fasta",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "id": "out_consensus_major_seq",
                  "doc": "Consensus sequences including the majority base as FASTA files.",
                  "label": "Consensus sequences majority",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*majority.fasta",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "id": "out_consensus_major_dels_seq",
                  "doc": "Consensus sequences including the majority base as FASTA files.",
                  "label": "Consensus sequences majority dels",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*majority_dels.fasta",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "FASTA"
                }
              ],
              "doc": "**smallgenomeutilities extract_consensus** builds consensus sequences including either the majority base or the ambiguous bases from an alignment (BAM) file.",
              "label": "smallgenomeutilities extract_consensus",
              "arguments": [
                {
                  "prefix": "&&",
                  "shellQuote": false,
                  "position": 100,
                  "valueFrom": "bash rename.sh"
                }
              ],
              "requirements": [
                {
                  "class": "ShellCommandRequirement"
                },
                {
                  "class": "ResourceRequirement",
                  "ramMin": "${\n    if(inputs.mem_per_job){\n        return inputs.mem_per_job\n    }\n    else{\n        return 1500\n    }\n}",
                  "coresMin": "${\n    if(inputs.cpu_per_job){\n        return inputs.cpu_per_job\n    }\n    else{\n        return 1\n    }\n}"
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/smallgenomeutilities-0-3-6:0"
                },
                {
                  "class": "InitialWorkDirRequirement",
                  "listing": [
                    {
                      "entryname": "rename.sh",
                      "entry": "${\n    var cmd = '#!/bin/bash\\nfor file in *.fasta;\\ndo\\n prefix=\"'+inputs.in_alignments.metadata['sample_id']+'_\"\\n new_file=$prefix$file\\n mv $file $new_file\\ndone';\n    return cmd\n}",
                      "writable": false
                    }
                  ]
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377328,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377354,
                  "sbg:revisionNotes": "Latest version from dev."
                },
                {
                  "sbg:revision": 2,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650433956,
                  "sbg:revisionNotes": "JS edited & added outputs."
                },
                {
                  "sbg:revision": 3,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1651752596,
                  "sbg:revisionNotes": "Edited file type for output."
                }
              ],
              "sbg:image_url": null,
              "sbg:toolkit": "smallgenomeutilities",
              "sbg:toolkitVersion": "0.3.6",
              "sbg:license": "GNU General Public License v2.0",
              "sbg:links": [
                {
                  "id": "https://github.com/cbg-ethz/smallgenomeutilities",
                  "label": "Homepage"
                },
                {
                  "id": "https://github.com/cbg-ethz/smallgenomeutilities/releases/tag/0.3.6",
                  "label": "Source Code"
                },
                {
                  "id": "https://github.com/cbg-ethz/smallgenomeutilities/archive/refs/tags/0.3.6.tar.gz",
                  "label": "Download"
                }
              ],
              "sbg:toolAuthor": "David Seifert, Susana Posada Cespedes, Ivan Blagoev Topolsky and Lara Fuhrmann",
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-2216c224/h-1ee35159/h-dcca2c19/0",
              "sbg:revision": 3,
              "sbg:revisionNotes": "Edited file type for output.",
              "sbg:modifiedOn": 1651752596,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650377328,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 3,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "acb6181393bc71ada308c5c4f566d52392cc738e4b469abec53749a5694b0d290",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "smallgenomeutilities extract_consensus",
            "sbg:x": 814.4951782226562,
            "sbg:y": 597.81884765625
          },
          {
            "id": "shorah_shotgun_1_99_2",
            "in": [
              {
                "id": "in_reference",
                "source": "in_reference"
              },
              {
                "id": "in_alignments",
                "source": "in_alignments"
              },
              {
                "id": "in_intervals",
                "source": "smallgenomeutilities_extract_coverage_intervals_0_3_6/coverage_intervals"
              },
              {
                "id": "read_length",
                "source": "read_length"
              },
              {
                "id": "alpha",
                "default": 0.1,
                "source": "alpha"
              },
              {
                "id": "ignore_indels",
                "source": "ignore_indels"
              },
              {
                "id": "coverage",
                "default": 0,
                "source": "coverage"
              },
              {
                "id": "shift",
                "default": 3,
                "source": "shift"
              },
              {
                "id": "posterior_threshold",
                "default": 0.9,
                "source": "posterior_threshold"
              },
              {
                "id": "covint",
                "default": 50,
                "source": "covint"
              },
              {
                "id": "threads",
                "default": 8,
                "source": "threads"
              }
            ],
            "out": [
              {
                "id": "out_csv"
              },
              {
                "id": "out_vcf"
              },
              {
                "id": "bash_script"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/shorah-shotgun-1-99-2/2",
              "baseCommand": [
                "bash",
                "shorah_vpipe.sh"
              ],
              "inputs": [
                {
                  "sbg:category": "File Inputs",
                  "id": "in_reference",
                  "type": "File?",
                  "label": "Reference file",
                  "doc": "Input reference.",
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "in_alignments",
                  "type": "File?",
                  "label": "Input BAM file",
                  "doc": "Input BAM file.",
                  "sbg:fileTypes": "BAM"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_intervals",
                  "type": "File?",
                  "label": "Coverage intervals",
                  "doc": "Coverage intervals.",
                  "sbg:fileTypes": "TSV"
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "250",
                  "id": "read_length",
                  "type": "int?",
                  "label": "Read length",
                  "doc": "Read length."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "alpha",
                  "type": "float?",
                  "label": "Alpha",
                  "doc": "Hyperparameter used for instantiating a new cluster."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "ignore_indels",
                  "type": "boolean?",
                  "label": "Ignore indels",
                  "doc": "Ignore SNVs adjacent to indels."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "coverage",
                  "type": "int?",
                  "label": "Coverage",
                  "doc": "Omit windows with coverage less than this value."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "shift",
                  "type": "int?",
                  "label": "Shift",
                  "doc": "ShoRAH performs local haplotype reconstruction on windows of the read alignment. The overlap between these windows is defined by the window shifts."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "posterior_threshold",
                  "type": "float?",
                  "label": "Posterior threshold",
                  "doc": "Posterior threshold."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "covint",
                  "type": "int?",
                  "label": "Intervals coverage",
                  "doc": "Minimum read depth. A region spanning the reference genome is returned if `coverage` is set to 0.\"."
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "8",
                  "id": "threads",
                  "type": "int?",
                  "label": "Threads",
                  "doc": "Number of threads."
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "10000",
                  "id": "mem_per_job",
                  "type": "int?",
                  "label": "Memory per job",
                  "doc": "Memory per job [MB]."
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "8",
                  "id": "cpu_per_job",
                  "type": "int?",
                  "label": "CPU per job",
                  "doc": "Number of CPUs per job."
                }
              ],
              "outputs": [
                {
                  "id": "out_csv",
                  "doc": "Variants in CSV format.",
                  "label": "CSV file with variants",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*_snvs.csv",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "CSV"
                },
                {
                  "id": "out_vcf",
                  "doc": "VCF file with variants.",
                  "label": "VCF file with variants",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*_snvs.vcf",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "VCF"
                },
                {
                  "id": "bash_script",
                  "doc": "Bash script with ran commands.",
                  "label": "Bash script with ran commands",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*.sh"
                  },
                  "sbg:fileTypes": "SH"
                }
              ],
              "doc": "**ShoRAH** provides error correction, haplotype reconstruction and estimation of the frequency of the different genetic variants present in a mixed sample. **ShoRAH shotgun** is specifically designed for shotgun sequencing analysis.",
              "label": "ShoRAH shotgun",
              "requirements": [
                {
                  "class": "ResourceRequirement",
                  "ramMin": "${\n    if(inputs.mem_per_job){\n        return inputs.mem_per_job\n    }\n    else{\n        return 10000\n    }\n}",
                  "coresMin": "${\n    if(inputs.threads){\n        return inputs.threads\n    }\n    else if(inputs.cpu_per_job){\n        return inputs.cpu_per_job\n    }\n    else{\n        return 8\n    }\n}"
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/shorah-1-99-2:0"
                },
                {
                  "class": "InitialWorkDirRequirement",
                  "listing": [
                    {
                      "entryname": "shorah_vpipe.sh",
                      "entry": "${\n    var ignore_indels = '';\n    if (inputs.ignore_indels){\n        var ignore_indels = '--ignore_indels';\n    }\n    var cmd = '';\n    cmd = cmd.concat('#!/bin/bash\\nlet \"WINDOW_SHIFTS=('+inputs.read_length+' * 4/5 + '+inputs.shift+') / '+inputs.shift+'\"\\n');\n    cmd = cmd.concat('let \"WINDOW_LEN=WINDOW_SHIFTS * '+inputs.shift+'\"\\n');\n    cmd = cmd.concat('echo \"Windows are shifted by: ${WINDOW_SHIFTS} bp\" > shorah.out.log\\n');\n    cmd = cmd.concat('echo \"The window length is: ${WINDOW_LEN} bp\" >> shorah.out.log\\n');\n    cmd = cmd.concat('## Get absolute path for input files\\nCWD=${PWD}\\nOUTFILE=${PWD}/shorah.out.log\\nERRFILE=${PWD}/shorah.err.log\\nWORK_DIR=${PWD}\\n');\n    cmd = cmd.concat('LINE_COUNTER=0\\nFILES=( )\\nFILES_VCF=( )\\n');\n    cmd = cmd.concat('while read -r region || [[ -n ${region} ]]\\ndo\\n');\n    cmd = cmd.concat('\\techo \"Running ShoRAH on region: ${region}\" >> $OUTFILE\\n\\t(( ++LINE_COUNTER ))\\n\\t# Create directory for running ShoRAH in a corresponding region\\n\\tDIR=${WORK_DIR}/REGION_${LINE_COUNTER}\\n\\techo \"Creating directory ${DIR}\" >> $OUTFILE\\n\\tmkdir -p ${DIR}\\n\\tcd ${DIR}\\n');\n    cmd = cmd.concat('\\tshorah shotgun  -t '+inputs.threads+' -a '+inputs.alpha+' -w ${WINDOW_LEN} -x 100000 '+ignore_indels+' -p '+inputs.posterior_threshold+' -c '+inputs.coverage+' -r ${region} -R 42 -b '+inputs.in_alignments.path+' -f '+inputs.in_reference.path+' >> $OUTFILE 2> >(tee -a $ERRFILE >&2)\\n\\t');\n    cmd = cmd.concat('if [[ -s ${DIR}/reads.fas && -f ${DIR}/snv/SNVs_0.010000_final.csv ]]; then\\n\\t\\t');\n    cmd = cmd.concat('bcftools view ${DIR}/snv/SNVs_0.010000_final.vcf -Oz -o ${DIR}/snv/SNVs_0.010000_final.vcf.gz\\n\\t\\t');\n    cmd = cmd.concat('bcftools index ${DIR}/snv/SNVs_0.010000_final.vcf.gz\\n\\t\\t');\n    cmd = cmd.concat('FILES+=(\"${DIR}/snv/SNVs_0.010000_final.csv\")\\n\\t\\tFILES_VCF+=(\"${DIR}/snv/SNVs_0.010000_final.vcf.gz\")\\n\\t');\n    cmd = cmd.concat('elif (( '+inputs.covint+' == 0 && LINE_COUNTER == 1 )) && [[ -f ${DIR}/reads.fas && ( ! -s ${DIR}/reads.fas ) ]]; then\\n\\t\\t');\n    cmd = cmd.concat('echo \"No reads while coverage intervals disabled (possible negative control sample)\" 2> >(tee -a $ERRFILE >&2)\\n\\t\\tcd ${CWD}\\n\\t\\t(( --LINE_COUNTER )) || true # Strict mode : (( 0 )) = fail\\n\\t\\tbreak\\n\\t');\n    cmd = cmd.concat('else\\n\\t\\techo \"ERROR: unsuccesful execution of ShoRAH\" 2> >(tee -a $ERRFILE >&2)\\n\\t\\texit 1\\n\\tfi\\n\\t');\n    cmd = cmd.concat('cd ${CWD}\\ndone < '+inputs.in_intervals.path+'\\n');\n    cmd = cmd.concat('if (( ${#FILES[@]} )); then\\n\\techo \"Intermediate csv files: ${FILES[*]}\" >> shorah.out.log\\n\\techo \"Intermediate vcf files: ${FILES_VCF[*]}\" >> shorah.out.log\\n\\t');\n    cmd = cmd.concat('(head -n 1 \"${FILES[0]}\"; tail -q -n +2 \"${FILES[@]}\" | sort -t, -nk2) > '+inputs.in_alignments.metadata['sample_id']+'_snvs.csv\\n\\tbcftools concat -o ${WORK_DIR}/snvs_tmp.vcf \"${FILES_VCF[@]}\"\\n\\tbcftools sort ${WORK_DIR}/snvs_tmp.vcf  -o '+inputs.in_alignments.metadata['sample_id']+'_snvs.vcf\\n\\trm -f ${WORK_DIR}/snvs_tmp.vcf\\n');\n    cmd = cmd.concat('elif (( LINE_COUNTER )); then\\n\\techo \"ERROR: unsuccesful execution of ShoRAH\" 2> >(tee -a {log.errfile} >&2)\\n\\texit 1\\n');\n    cmd = cmd.concat('else\\n\\techo \"No alignment region reports sufficient coverage\" >> shorah.out.log\\n\\ttouch '+inputs.in_alignments.metadata['sample_id']+'_snvs.csv\\n\\ttouch '+inputs.in_alignments.metadata['sample_id']+'_snvs.vcf\\nfi');\n    return cmd\n}",
                      "writable": false
                    }
                  ]
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377385,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377403,
                  "sbg:revisionNotes": "Latest version from dev."
                },
                {
                  "sbg:revision": 2,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650435041,
                  "sbg:revisionNotes": "JS edited."
                }
              ],
              "sbg:image_url": null,
              "sbg:toolkit": "ShoRAH",
              "sbg:toolkitVersion": "1.99.2",
              "sbg:license": "GPL-3.0 License",
              "sbg:links": [
                {
                  "id": "http://cbg-ethz.github.io/shorah/",
                  "label": "Homepage"
                },
                {
                  "id": "https://github.com/cbg-ethz/shorah/releases/tag/v1.99.2",
                  "label": "Source Code"
                },
                {
                  "id": "https://github.com/cbg-ethz/shorah/archive/refs/tags/v1.99.2.tar.gz",
                  "label": "Download"
                }
              ],
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-b0b9f446/h-26713126/h-1ac7d66f/0",
              "sbg:revision": 2,
              "sbg:revisionNotes": "JS edited.",
              "sbg:modifiedOn": 1650435041,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650377385,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 2,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "acb33d3ad38f82c47faa52f284754fe03e0027abc147021b0a2c81706a104a863",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "ShoRAH shotgun",
            "sbg:x": 718.7513427734375,
            "sbg:y": -15.433062553405762
          },
          {
            "id": "generate_web_visualization",
            "in": [
              {
                "id": "in_consensus",
                "source": "smallgenomeutilities_extract_consensus_0_3_6/out_consensus_major_seq"
              },
              {
                "id": "in_reference",
                "source": "in_reference"
              },
              {
                "id": "in_coverage",
                "source": "smallgenomeutilities_aln2basecnt_0_3_6/out_coverage"
              },
              {
                "id": "in_variants",
                "source": "shorah_shotgun_1_99_2/out_vcf"
              },
              {
                "id": "in_alignments",
                "source": "in_alignments"
              },
              {
                "id": "gff_files",
                "source": [
                  "gff_files"
                ]
              },
              {
                "id": "primers_file",
                "source": "primers_file"
              },
              {
                "id": "phylogeny_file",
                "source": "phylogeny_file"
              },
              {
                "id": "metainfo_file",
                "source": "metainfo_file"
              }
            ],
            "out": [
              {
                "id": "snv_html_file"
              },
              {
                "id": "alignment_html_file"
              },
              {
                "id": "reference_uri_file"
              },
              {
                "id": "bam_uri_file"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/generate-web-visualization/3",
              "baseCommand": [],
              "inputs": [
                {
                  "sbg:category": "File Inputs",
                  "id": "in_consensus",
                  "type": "File",
                  "label": "Consensus file",
                  "doc": "Consensus file.",
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_reference",
                  "type": "File",
                  "label": "Reference file",
                  "doc": "Reference file.",
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_coverage",
                  "type": "File",
                  "label": "Coverage file",
                  "doc": "Coverage file.",
                  "sbg:fileTypes": "TSV.GZ"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_variants",
                  "type": "File",
                  "label": "VCF file with SNVs",
                  "doc": "VCF file with SNVs.",
                  "sbg:fileTypes": "VCF"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_alignments",
                  "type": "File",
                  "label": "BAM file",
                  "doc": "BAM file.",
                  "sbg:fileTypes": "BAM"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "gff_files",
                  "type": "File[]?",
                  "label": "GFF files",
                  "doc": "GFF files.",
                  "sbg:fileTypes": "GTF, GFF3, GFF"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "primers_file",
                  "type": "File?",
                  "label": "Primers file",
                  "doc": "Primers file.",
                  "sbg:fileTypes": "TSV"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "phylogeny_file",
                  "type": "File?",
                  "label": "Phylogeny file",
                  "doc": "Phylogeny file.",
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "metainfo_file",
                  "type": "File?",
                  "label": "Metainfo file",
                  "doc": "Metainfo file.",
                  "sbg:fileTypes": "YAML"
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "2000",
                  "id": "mem_per_job",
                  "type": "int?",
                  "label": "Memory per job",
                  "doc": "Memory per job [MB]."
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "1",
                  "id": "cpu_per_job",
                  "type": "int?",
                  "label": "CPU per job",
                  "doc": "Number of CPUs per job."
                }
              ],
              "outputs": [
                {
                  "id": "snv_html_file",
                  "doc": "SNV callling HTML report.",
                  "label": "SNV callling HTML report",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*snv_calling.html",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "HTML"
                },
                {
                  "id": "alignment_html_file",
                  "doc": "Alignment HTML report.",
                  "label": "Alignment HTML report",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*alignment.html",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "HTML"
                },
                {
                  "id": "reference_uri_file",
                  "doc": "Reference URI.",
                  "label": "Reference URI",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*reference_uri*",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  }
                },
                {
                  "id": "bam_uri_file",
                  "doc": "BAM URI file",
                  "label": "BAM URI file",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*bam_uri*",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  }
                }
              ],
              "doc": "**Generate web visualization** is a custom script for creating visual representation of results from V-pipe workflow.",
              "label": "Generate web visualization",
              "arguments": [
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 0,
                  "valueFrom": "${\n    var files='';\n    if (inputs.gff_files){\n        for (var i=0; i<inputs.gff_files.length; i++){\n            files = files + inputs.gff_files[i].path + ' '\n        }\n        return 'mkdir gffs && cp ' + files + 'gffs/ &&'\n    }\n}"
                },
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 1,
                  "valueFrom": "${\n    if (inputs.phylogeny_file){\n        return 'augur align --sequences '+inputs.phylogeny_file.path+' '+inputs.in_consensus.path+' --output '+inputs.in_alignments.metadata['sample_id']+ '_alignment.fasta && augur tree --alignment '+inputs.in_alignments.metadata['sample_id']+ '_alignment.fasta --output '+inputs.in_alignments.metadata['sample_id']+ '_tree.nwk &&'\n    }\n}"
                },
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 2,
                  "valueFrom": "${\n    return 'create_datauri '+inputs.in_reference.path+' > ' + inputs.in_alignments.metadata['sample_id']+ '_reference_uri_file && create_datauri ' + inputs.in_alignments.path+ ' > ' + inputs.in_alignments.metadata['sample_id']+ '_bam_uri_file &&' \n}"
                },
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 3,
                  "valueFrom": "${\n    if (inputs.gff_files){\n        var gff=' --gff    \"gffs\"';\n    }\n    else{\n        gff='';\n    }\n    if (inputs.primers_file){\n        var prim=' --primers    \"' + inputs.primers_file.path + '\"';\n    }\n    else{\n        prim='';\n    }\n    if (inputs.metainfo_file){\n        var meta=' --metainfo    \"' + inputs.metainfo_file.path + '\"';\n    }\n    else{\n        meta='';\n    }\n    if (inputs.phylogeny_file){\n        var phyl = '--nwk \"'+inputs.in_alignments.metadata['sample_id']+ '_tree.nwk\"';\n    }\n    else{\n        phyl = '';\n    }\n    return 'python3 \"assemble_visualization_webpage.py\" --consensus  \"'+inputs.in_consensus.path+'\" --coverage    \"'+inputs.in_coverage.path+'\" --vcf    \"'+inputs.in_variants.path +'\"' + gff + prim + meta + ' --snv_calling_template    \"/opt/snv_calling_visualization.html\" --alignment_template    \"/opt/alignment_visualization.html\" --html_out_snv_calling    \"'+inputs.in_alignments.metadata['sample_id']+'_snv_calling.html\" --html_out_alignment    \"'+inputs.in_alignments.metadata['sample_id']+'_alignment.html\" --reference    \"'+inputs.in_reference.path+'\" --reference_uri_file \"' + inputs.in_alignments.metadata['sample_id']+ '_reference_uri_file\" --wildcards '+ inputs.in_alignments.metadata['sample_id'] +' --bam_uri_file \"' + inputs.in_alignments.metadata['sample_id']+ '_bam_uri_file\" ' + phyl\n}"
                }
              ],
              "requirements": [
                {
                  "class": "ShellCommandRequirement"
                },
                {
                  "class": "ResourceRequirement",
                  "ramMin": "${\n    if(inputs.mem_per_job){\n        return inputs.mem_per_job\n    }\n    else{\n        return 2000\n    }\n}",
                  "coresMin": "${\n    if(inputs.cpu_per_job){\n        return inputs.cpu_per_job\n    }\n    else{\n        return 1\n    }\n}"
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/v-pipe-visualization:0"
                },
                {
                  "class": "InitialWorkDirRequirement",
                  "listing": [
                    {
                      "entryname": "assemble_visualization_webpage.py",
                      "entry": "import os\nimport re\nimport sys\nimport json\nimport yaml\nimport argparse\nfrom pathlib import Path\n\nimport numpy as np\nimport pandas as pd\n\nimport vcf\nfrom BCBio import GFF\nfrom Bio import SeqIO\nfrom Bio.Seq import Seq\n\n\ndef convert_vcf(fname):\n    \"\"\"Convert VCF to JSON.\"\"\"\n    output = []\n\n    if os.path.getsize(fname) == 0:\n        print(f'Empty VCF: \"{fname}\"')\n        return output\n\n    print(f'Parsing VCF: \"{fname}\"')\n    with open(fname) as fd:\n        vcf_reader = vcf.Reader(fd)\n\n        # check caller\n        caller_source = vcf_reader.metadata[\"source\"][0].lower()\n        if caller_source.startswith(\"lofreq\"):\n            mode = \"lofreq\"\n        elif caller_source.startswith(\"shorah\"):\n            mode = \"shorah\"\n        else:\n            raise RuntimeError(f\"Invalid variant caller: {caller_source}\")\n\n        # parse records\n        for record in vcf_reader:\n            if mode == \"lofreq\":\n                freq = round(record.INFO[\"AF\"], 3)\n            elif mode == \"shorah\":\n                freq = round(\n                    np.mean(\n                        [v for k, v in record.INFO.items() if k.startswith(\"Freq\")]\n                    ),\n                    3,\n                )\n\n            output.append(\n                {\n                    \"position\": record.POS,\n                    \"reference\": record.REF,\n                    \"variant\": [v.sequence for v in record.ALT],\n                    \"frequency\": freq,\n                    \"posterior\": round(1 - 10 ** (-record.QUAL / 10), 3),\n                }\n            )\n\n    return json.dumps(output)\n\n\ndef get_metainfo(metainfo_yaml):\n    \"\"\"load metainformation for the GFF and primers from YAML file\"\"\"\n\n    if metainfo_yaml:\n        print(f'Parsing metainformation: \"{metainfo_yaml}\"')\n        with open(metainfo_yaml) as fd:\n            metainfo = yaml.load(fd.read(), Loader=yaml.SafeLoader)\n        assert (\n            type(metainfo) is dict\n        ), f\"Probable syntax error in {metainfo_yaml} - need a dictionnary at top level, got {type(metainfo)} instead.\"\n        return metainfo\n    else:\n        print(\"No metainformation YAML provided, skipping.\")\n        return {}\n\n\ndef parse_gff(fname):\n    \"\"\"Convert GFF to map.\"\"\"\n    features = []\n\n    print(f'Parsing GFF: \"{fname}\"')\n    with open(fname) as fd:\n        for record in GFF.parse(fd):\n            for feature in record.features:\n                features.append(\n                    {\n                        \"id\": record.id,\n                        \"type\": feature.type,\n                        \"name\": feature.qualifiers.get(\"Name\", [feature.id])[0],\n                        \"start\": int(feature.location.start),\n                        \"end\": int(feature.location.end),\n                    }\n                )\n    return features\n\n\ndef arrange_gff_data(features):\n    \"\"\"Add row number to each feature.\"\"\"\n    features.sort(key=lambda f: f[\"start\"])\n\n    rows = []\n    for feature in features:\n        if not rows:\n            feature[\"row_cnt\"] = 0\n            rows.append([feature])\n        else:\n            found = False\n            for idx, row in enumerate(rows):\n                if row[-1][\"end\"] <= feature[\"start\"]:\n                    feature[\"row_cnt\"] = idx\n                    row.append(feature)\n                    found = True\n                    break\n            if not found:\n                feature[\"row_cnt\"] = len(rows)\n                rows.append([feature])\n\n    return [item for row in rows for item in row]\n\n\ndef get_gff_data(gff_dir, gff_metainfo={}):\n    \"\"\"Returns a map with filename key and gff json data.\"\"\"\n    if gff_metainfo == None:\n        gff_metainfo = {}\n    assert (\n        type(gff_metainfo) is dict\n    ), f\"Probable syntax error in metainfo YAML - need a dictionnary at [gff], got {type(gff_metainfo)} instead.\"\n\n    gff_map = {}\n    if not gff_dir:\n        print(\"No gff directory provided, skipping.\")\n        return gff_map\n    for path in os.listdir(gff_dir):\n        full_path = os.path.join(gff_dir, path)\n        description = os.path.splitext(path)[0]\n        if description in gff_metainfo:\n            description = gff_metainfo[description]\n        gff_map[description] = arrange_gff_data(parse_gff(full_path))\n    return gff_map\n\n\ndef get_primers_data(full_path, consensus, primers_metainfo={}):\n    \"\"\"Returns a map with filename key and primers json data.\"\"\"\n    if primers_metainfo == None:\n        primers_metainfo = {}\n    assert (\n        type(primers_metainfo) is dict\n    ), f\"Probable syntax error in metainfo YAML - need a dictionnary at [primers], got {type(primers_metainfo)} instead.\"\n\n    primers_map = {}\n    if not full_path:\n        print(\"No primers table provided, skipping.\")\n        return primers_map\n    else:\n        print(f'Parsing GFF: \"{full_path}\"')\n    consensus_upper = consensus.upper()\n    description = os.path.splitext(os.path.basename(full_path))[0]\n    if description in primers_metainfo:\n        description = primers_metainfo[description]\n    csv = pd.read_csv(full_path, sep=\",\")\n    primers = [\n        {\"name\": row[0], \"seq\": row[1].upper()} for row in csv[[\"name\", \"seq\"]].values\n    ]\n    primer_locations = []\n    for entry in primers:\n        lookup_sequence = entry[\"seq\"]\n        # If the sequence corresponds to a `right` primer, then reverse and\n        # complement.\n        if \"RIGHT\" in entry[\"name\"].upper():\n            seq = Seq(lookup_sequence)\n            lookup_sequence = str(seq.reverse_complement())\n        offsets = [\n            m.start()\n            for m in re.finditer(\"(?=\" + lookup_sequence + \")\", consensus_upper)\n        ]\n        for offset in offsets:\n            primer_locations.append(\n                {\n                    \"name\": entry[\"name\"],\n                    \"seq\": entry[\"seq\"],\n                    \"start\": offset,\n                    \"end\": offset + len(entry[\"seq\"]) - 1,\n                }\n            )\n    if primer_locations:\n        primers_map[description] = arrange_gff_data(primer_locations)\n    else:\n        print(f'No primer was mapped from \"{full_path}\".')\n    return primers_map\n\n\ndef convert_coverage(fname, sample_name=None):\n    \"\"\"Convert the read coverage to bp coverage.\"\"\"\n    print(f'Parsing coverage: \"{fname}\"')\n    csv = pd.read_csv(\n        fname, sep=\"\\t\", compression=\"infer\", index_col=[\"ref\", \"pos\"], header=0\n    )\n    col = None\n    if len(csv.columns) == 1:\n        if sample_name is not None and sample_name != csv.columns[0]:\n            print(\n                f'Ooops: column name \"{csv.columns[0]}\" in file is different from requested sample name \"{sample_name}\"!'\n            )\n        col = csv[csv.columns[0]]\n    else:\n        assert (\n            sample_name is not None\n        ), \"Sample name is required when using combined coverage TSV.\"\n        col = csv[sample_name]\n    return col.values.tolist()\n\n\ndef assemble_html_page(html_file_in, html_file_out, placeholder_replacement_map):\n\n    # assemble webpage\n    with open(html_file_in, encoding='utf8') as fd:\n        raw_html = fd.read()\n\n    # TODO: make this more robust\n    mod_html = raw_html\n    for key, value in placeholder_replacement_map.items():\n        mod_html = mod_html.replace(key, value)\n\n    with open(html_file_out, \"w\", encoding='utf8') as fd:\n        fd.write(mod_html)\n\n\ndef assemble_snv_calling_visualization_webpage(\n    sample_name,\n    consensus_file,\n    coverage_file,\n    vcf_file,\n    gff_directory,\n    primers_file,\n    html_file_in,\n    html_file_out,\n    reference_file,\n    metainfo_yaml,\n):\n\n    # parse the consensus sequence\n    print(f'Parsing consensus: \"{consensus_file}\"')\n    consensus = next(SeqIO.parse(consensus_file, \"fasta\")).seq.upper()\n\n    # parse coverage file\n    coverage = convert_coverage(coverage_file, sample_name.replace(\"/\", \"-\"))\n\n    # load biodata in json format\n    vcf_json = convert_vcf(vcf_file)\n    metainfo = get_metainfo(metainfo_yaml)\n    gff_map = get_gff_data(\n        gff_directory, gff_metainfo=metainfo[\"gff\"] if \"gff\" in metainfo else {}\n    )\n    primers_map = get_primers_data(\n        primers_file,\n        str(consensus),\n        primers_metainfo=metainfo[\"primers\"] if \"primers\" in metainfo else {},\n    )\n\n    # parse the reference name\n    reference_name = (\n        re.search(r\"(.+)\\.fa.*\", os.path.basename(reference_file))\n        .group(1)\n        .replace(\"_\", \"&nbsp;\")\n    )\n\n    embed_code = f\"\"\"\n        var sample_name = \\\"{sample_name}\\\"\n        var consensus = \\\"{consensus}\\\"\n        var coverage = {coverage}\n        var vcfData = {vcf_json}\n        var gffData = {gff_map}\n        var primerData = {primers_map}\n        var reference_name = \\\"{reference_name}\\\"\n    \"\"\"\n\n    assemble_html_page(\n        html_file_in, html_file_out, {\"{EXTERNAL_SNAKEMAKE_CODE_MARKER}\": embed_code}\n    )\n\n\ndef assemble_alignment_visualization_webpage(\n    sample_name, nwk_file, reference_uri_file, bam_uri_file, html_file_in, html_file_out\n):\n\n    nwk_tree = \"\"\n    if nwk_file:\n        with open(nwk_file) as fd:\n            nwk_tree = fd.read().rstrip(\"\\n\")\n\n    embed_code = f\"\"\"\n        var sample_name = \\\"{sample_name}\\\"\n        var phylogenyData = \\\"{nwk_tree}\\\"\n    \"\"\"\n\n    # read the reference uri file\n    with open(reference_uri_file) as fd:\n        reference_uri = fd.read().rstrip(\"\\n\")\n\n    # read the BAM uri file\n    with open(bam_uri_file) as fd:\n        bam_uri = fd.read().rstrip(\"\\n\")\n\n    assemble_html_page(\n        html_file_in,\n        html_file_out,\n        {\n            \"{EXTERNAL_SNAKEMAKE_CODE_MARKER}\": embed_code,\n            \"{EXTERNAL_FASTA_URI}\": reference_uri,\n            \"{EXTERNAL_BAM_URI}\": bam_uri,\n        },\n    )\n\n\ndef main():\n    \"\"\"Parse command line, run default functions.\"\"\"\n    # parse command line\n    parser = argparse.ArgumentParser(\n        description=\"Generate HTML visual report from VCF variants\",\n        epilog=\"at minimum, either provide `-v` and `-c` or provide `-w`\",\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--consensus\",\n        metavar=\"FASTA\",\n        required=False,\n        type=str,\n        dest=\"consensus_file\",\n        help=\"consensus sequence of this sample\",\n    )\n    parser.add_argument(\n        \"-c\",\n        \"--coverage\",\n        metavar=\"TSV\",\n        required=False,\n        default=\"variants/coverage.tsv\",\n        type=str,\n        dest=\"coverage_file\",\n        help=\"global coverage table\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--vcf\",\n        metavar=\"VCF\",\n        required=False,\n        type=str,\n        dest=\"vcf_file\",\n        help=\"VCF containing the SNPs to be visualised\",\n    )\n    parser.add_argument(\n        \"-g\",\n        \"--gff\",\n        metavar=\"DIR\",\n        required=False,\n        type=str,\n        dest=\"gff_directory\",\n        help=\"directory containing GFF annotations\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--primers\",\n        metavar=\"CSV\",\n        required=False,\n        type=str,\n        dest=\"primers_file\",\n        help=\"table with primers\",\n    )\n    parser.add_argument(\n        \"-m\",\n        \"--metainfo\",\n        metavar=\"YAML\",\n        required=False,\n        type=str,\n        dest=\"metainfo_yaml\",\n        help=\"metainformation for the GFF and primers\",\n    )\n    parser.add_argument(\n        \"-x\",\n        \"--snv_calling_template\",\n        metavar=\"HTML\",\n        required=False,\n        default=f\"{os.path.dirname(__file__)}/snv_calling_visualization.html\",\n        type=str,\n        dest=\"html_template_snv\",\n        help=\"HTML template used to generate visual report for snv calling\",\n    )\n    parser.add_argument(\n        \"-y\",\n        \"--alignment_template\",\n        metavar=\"HTML\",\n        required=False,\n        default=f\"{os.path.dirname(__file__)}/alignment_visualization.html\",\n        type=str,\n        dest=\"html_template_alignment\",\n        help=\"HTML template used to generate visual report for alignments\",\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--html_out_snv_calling\",\n        metavar=\"HTML\",\n        required=False,\n        type=str,\n        dest=\"html_out_snv_calling\",\n        help=\"produced HTML report for SNV calling\",\n    )\n    parser.add_argument(\n        \"-a\",\n        \"--html_out_alignment\",\n        metavar=\"HTML\",\n        required=False,\n        type=str,\n        dest=\"html_out_alignment\",\n        help=\"produced HTML report for phylogeny and read alignment\",\n    )\n    parser.add_argument(\n        \"-w\",\n        \"--wildcards\",\n        metavar=\"SAMPLE/DATE\",\n        required=False,\n        type=str,\n        dest=\"wildcards_dataset\",\n        help=\"sample's two-level directory hierarchy prefix\",\n    )\n    parser.add_argument(\n        \"-r\",\n        \"--reference\",\n        metavar=\"FASTA\",\n        required=False,\n        default=\"variants/cohort_consensus.fasta\",\n        type=str,\n        dest=\"reference_file\",\n        help=\"reference against which SNVs were called (e.g.: cohort's consensus)\",\n    )\n    parser.add_argument(\n        \"-n\",\n        \"--nwk\",\n        metavar=\"NWK\",\n        required=False,\n        type=str,\n        dest=\"nwk_file\",\n        help=\"phylogenetic tree in NWK format\",\n    )\n    parser.add_argument(\n        \"-u\",\n        \"--reference_uri_file\",\n        metavar=\"FILE\",\n        required=False,\n        type=str,\n        dest=\"reference_uri_file\",\n        help=\"reference file uri\",\n    )\n    parser.add_argument(\n        \"-b\",\n        \"--bam_uri_file\",\n        metavar=\"FILE\",\n        required=False,\n        type=str,\n        dest=\"bam_uri_file\",\n        help=\"bam file uri\",\n    )\n\n    args = parser.parse_args()\n\n    # defaults which can be guess from one another\n    if (\n        args.vcf_file == None\n    ):  # e.g.: samples/140074_395_D02/20200615_J6NRK/variants/SNVs/snvs.vcf\n        assert (\n            args.wildcards_dataset != None\n        ), \"cannot automatically find VCF without wildcards\"\n        args.vcf_file = os.path.join(\n            args.wildcards_dataset, \"variants\", \"SNVs\", \"snvs.vcf\"\n        )\n\n    if (\n        args.consensus_file == None\n    ):  # e.g.: samples/140074_395_D02/20200615_J6NRK/references/ref_majority.fasta\n        assert (\n            args.wildcards_dataset != None\n        ), \"cannot automatically find consensus without wildcards\"\n        args.consensus_file = os.path.join(\n            args.wildcards_dataset, \"references\", \"ref_majority.fasta\"\n        )\n\n    if args.wildcards_dataset == None:\n        assert (\n            args.vcf_file != None and args.consensus_file != None\n        ), \"cannot deduce wilcards without a consensus and a vcf\"\n        try1 = \"/\".join(os.path.normpath(args.vcf_file).split(os.path.sep)[-5:-3])\n        try2 = \"/\".join(os.path.normpath(args.consensus_file).split(os.path.sep)[-4:-2])\n        assert (\n            try1 == try2\n        ), f\"cannot deduce wildcards automatically from <{args.vcf_file}> and <{args.consensus_file}>, please specify explicitly using `--wirdcards`\"\n        args.wildcards_dataset = try1\n\n    if args.html_out_snv_calling == None:\n        args.html_out_snv_calling = os.path.join(\n            args.wildcards_dataset, \"visualization\", \"snv_calling.html\"\n        )\n\n    if args.html_out_alignment == None:\n        args.html_out_alignment = os.path.join(\n            args.wildcards_dataset, \"visualization\", \"alignment.html\"\n        )\n\n    # check mandatory files exist\n    for n, f in {\n        \"vcf\": args.vcf_file,\n        \"consensus\": args.consensus_file,\n        \"coverage\": args.coverage_file,\n        \"snv_calling_template\": args.html_template_snv,\n        \"alignment_template\": args.html_template_alignment,\n    }.items():\n        if not os.path.exists(f):\n            parser.error(f\"{n} file <{f}> does not exist!\")\n\n    # check optional files exist if specified\n    for n, f in {\n        \"gff\": args.gff_directory,\n        \"primers\": args.primers_file,\n        \"metainfo\": args.metainfo_yaml,\n    }.items():\n        if f and not os.path.exists(f):\n            parser.error(f\"{n} file <{f}> does not exist!\")\n\n    if (\n        args.reference_uri_file == None\n    ):  # e.g.: samples/140074_395_D02/20200615_J6NRK/visualization/reference_uri_file\n        assert (\n            args.wildcards_dataset != None\n        ), \"cannot automatically find reference_uri_file without wildcards\"\n        args.reference_uri_file = os.path.join(\n            args.wildcards_dataset, \"visualization\", \"reference_uri_file\"\n        )\n\n    if (\n        args.bam_uri_file == None\n    ):  # e.g.: samples/140074_395_D02/20200615_J6NRK/visualization/bam_uri_file\n        assert (\n            args.wildcards_dataset != None\n        ), \"cannot automatically find bam_uri_file without wildcards\"\n        args.bam_uri_file = os.path.join(\n            args.wildcards_dataset, \"visualization\", \"bam_uri_file\"\n        )\n\n    # parse the sample name\n    path_components = os.path.normpath(args.wildcards_dataset).split(os.path.sep)\n    sample_name = \"/\".join(path_components[-2:])\n\n    # run the visual report generator for SNV calling\n    assemble_snv_calling_visualization_webpage(\n        sample_name,\n        consensus_file=args.consensus_file,\n        coverage_file=args.coverage_file,\n        vcf_file=args.vcf_file,\n        gff_directory=args.gff_directory,\n        primers_file=args.primers_file,\n        html_file_in=args.html_template_snv,\n        html_file_out=args.html_out_snv_calling,\n        reference_file=args.reference_file,\n        metainfo_yaml=args.metainfo_yaml,\n    )\n\n    # run the visual report generator for read alignment and phylogeny\n\n    assemble_alignment_visualization_webpage(\n        sample_name,\n        nwk_file=args.nwk_file,\n        reference_uri_file=args.reference_uri_file,\n        bam_uri_file=args.bam_uri_file,\n        html_file_in=args.html_template_alignment,\n        html_file_out=args.html_out_alignment,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n",
                      "writable": false
                    }
                  ]
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377439,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377469,
                  "sbg:revisionNotes": "Latest version from dev project."
                },
                {
                  "sbg:revision": 2,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650435083,
                  "sbg:revisionNotes": "JS edited."
                },
                {
                  "sbg:revision": 3,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650466184,
                  "sbg:revisionNotes": "Added use case for when phylogeny file is not provided."
                }
              ],
              "sbg:image_url": null,
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-69d1759a/h-47830e4c/h-5cc8a51f/0",
              "sbg:revision": 3,
              "sbg:revisionNotes": "Added use case for when phylogeny file is not provided.",
              "sbg:modifiedOn": 1650466184,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650377439,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 3,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "a8d0e21142925034ee4c1c49a1b55c8b516e33f656c87405cdcf0e30de7bae819",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "Generate web visualization",
            "sbg:x": 1079.0101318359375,
            "sbg:y": 161.43309020996094
          },
          {
            "id": "bcftools_mpileup_call_norm_filter_1_13",
            "in": [
              {
                "id": "in_alignments",
                "source": "in_alignments"
              },
              {
                "id": "in_reference",
                "source": "in_reference"
              },
              {
                "id": "max_coverage",
                "default": 10000,
                "source": "max_coverage"
              },
              {
                "id": "threads",
                "default": 1
              }
            ],
            "out": [
              {
                "id": "out_bcf"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/bcftools-mpileup-call-norm-filter-1-13/4",
              "baseCommand": [],
              "inputs": [
                {
                  "sbg:category": "File Inputs",
                  "id": "in_alignments",
                  "type": "File?",
                  "label": "Input alignments",
                  "doc": "Input alignments.",
                  "sbg:fileTypes": "BAM"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_reference",
                  "type": "File?",
                  "label": "Input reference",
                  "doc": "Input reference.",
                  "sbg:fileTypes": "FASTA, FA"
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "max_coverage",
                  "type": "int?",
                  "label": "Maximum coverage",
                  "doc": "Maximum coverage."
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "1",
                  "id": "threads",
                  "type": "int?",
                  "label": "Threads",
                  "doc": "Number of threads."
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "1500",
                  "id": "mem_per_job",
                  "type": "int?",
                  "label": "Memory per job",
                  "doc": "Memory per job [MB]."
                },
                {
                  "sbg:category": "Platform Options",
                  "sbg:toolDefaultValue": "1",
                  "id": "cpu_per_job",
                  "type": "int?",
                  "label": "CPU per job",
                  "doc": "Number of CPUs per job."
                }
              ],
              "outputs": [
                {
                  "id": "out_bcf",
                  "doc": "Consensus BCF.",
                  "label": "Consensus BCF",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*.bcftools.bcf.gz",
                    "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
                  },
                  "sbg:fileTypes": "BCF.GZ"
                }
              ],
              "doc": "**Bcftools Mpileup/Call/Norm/Filter** is piped tool customised for use in V-pipe workflow.",
              "label": "Bcftools Mpileup/Call/Norm/Filter",
              "arguments": [
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 0,
                  "valueFrom": "${\n    var cmd = '/bin/bash -c \\'bcftools mpileup --threads '+inputs.threads+' -Ou -f '+inputs.in_reference.path+' --max-depth '+inputs.max_coverage+' --max-idepth '+inputs.max_coverage+' --annotate FORMAT/AD,FORMAT/DP,INFO/AD '+inputs.in_alignments.path+' | bcftools call --threads '+inputs.threads+' -Ou -mv --keep-alts | bcftools norm --threads '+inputs.threads+' -Ou -f '+inputs.in_reference.path+' | bcftools filter --threads '+inputs.threads+' -e \\'\"\\'TYPE=\"\\'\"INDEL\"\\'\" & INFO/AD[1]<INFO/AD[0]\\'\"\\' -Ob --output '+inputs.in_alignments.metadata['sample_id']+'.temp.consensus.bcftools.bcf.gz; if [[ ${PIPESTATUS[@]} == \"0 0 0 0\" ]]; then echo \"Everything OK\"; else exit 1; fi\\'';\n    return cmd\n}"
                }
              ],
              "requirements": [
                {
                  "class": "ShellCommandRequirement"
                },
                {
                  "class": "ResourceRequirement",
                  "ramMin": "${\n    if(inputs.mem_per_job){\n        return inputs.mem_per_job\n    }\n    else{\n        return 1500\n    }\n}",
                  "coresMin": "${\n    if(inputs.threads){\n        return inputs.threads\n    }\n    else if(inputs.cpu_per_job){\n        return inputs.cpu_per_job\n    }\n    else{\n        return 1\n    }\n}"
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/bcftools-1-13:0"
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377499,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377523,
                  "sbg:revisionNotes": "Latest version from dev."
                },
                {
                  "sbg:revision": 2,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650435158,
                  "sbg:revisionNotes": "JS edited."
                },
                {
                  "sbg:revision": 3,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1651741990,
                  "sbg:revisionNotes": "Edited for cwltool."
                },
                {
                  "sbg:revision": 4,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1653029938,
                  "sbg:revisionNotes": "Added pipe status check."
                }
              ],
              "sbg:image_url": null,
              "sbg:toolkit": "bcftools",
              "sbg:toolkitVersion": "1.13",
              "sbg:license": "MIT License",
              "sbg:links": [
                {
                  "id": "http://samtools.github.io/bcftools/",
                  "label": "Homepage"
                },
                {
                  "id": "https://github.com/samtools/bcftools",
                  "label": "Source code"
                },
                {
                  "id": "https://github.com/samtools/bcftools/wiki",
                  "label": "Wiki"
                },
                {
                  "id": "https://github.com/samtools/bcftools/archive/develop.zip",
                  "label": "Download"
                }
              ],
              "sbg:toolAuthor": "Petr Danecek, Shane McCarthy, John Marshall",
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-f77c1ca1/h-fc6c4f4f/h-957d8f68/0",
              "sbg:revision": 4,
              "sbg:revisionNotes": "Added pipe status check.",
              "sbg:modifiedOn": 1653029938,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650377499,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 4,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "a72a765f318f8354f7c0ae63854026c689c05c380a1b6b2338a2cfc7a02984e54",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "Bcftools Mpileup/Call/Norm/Filter",
            "sbg:x": 743.455810546875,
            "sbg:y": 406.0630187988281
          },
          {
            "id": "gunzip_and_enhance_bcf",
            "in": [
              {
                "id": "in_coverage",
                "source": "smallgenomeutilities_aln2basecnt_0_3_6/out_coverage"
              },
              {
                "id": "in_consensus",
                "source": "bcftools_mpileup_call_norm_filter_1_13/out_bcf"
              },
              {
                "id": "mask_coverage_threshold",
                "default": 10,
                "source": "mask_coverage_threshold"
              },
              {
                "id": "ambiguous_base_coverage_threshold",
                "default": 0.05,
                "source": "ambiguous_base_coverage_threshold"
              }
            ],
            "out": [
              {
                "id": "out_lowcoverage"
              },
              {
                "id": "out_consensus"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/gunzip-and-enhance-bcf/3",
              "baseCommand": [],
              "inputs": [
                {
                  "sbg:category": "File Inputs",
                  "id": "in_coverage",
                  "type": "File?",
                  "label": "Coverage file",
                  "doc": "Coverage file.",
                  "sbg:fileTypes": "TSV.GZ"
                },
                {
                  "sbg:category": "File Inputs",
                  "id": "in_consensus",
                  "type": "File?",
                  "label": "Consensus file",
                  "doc": "Consensus file.",
                  "sbg:fileTypes": "BCF.GZ"
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "10",
                  "id": "mask_coverage_threshold",
                  "type": "int?",
                  "label": "Mask coverage threshold",
                  "doc": "Mask coverage threshold. Default is 10."
                },
                {
                  "sbg:category": "Config Inputs",
                  "sbg:toolDefaultValue": "0.05",
                  "id": "ambiguous_base_coverage_threshold",
                  "type": "float?",
                  "label": "Ambiguous base coverage threshold",
                  "doc": "Frequency threshold to include a variant in computation of ambiguous code."
                }
              ],
              "outputs": [
                {
                  "id": "out_lowcoverage",
                  "doc": "Coverage mask lowcoverage.",
                  "label": "Coverage mask lowcoverage",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "*.bed",
                    "outputEval": "$(inheritMetadata(self, inputs.in_coverage))"
                  },
                  "sbg:fileTypes": "BED"
                },
                {
                  "id": "out_consensus",
                  "doc": "Consensus file.",
                  "label": "Consensus file",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "${ \n    return inputs.in_consensus.metadata['sample_id']+'.consensus.bcftools.bcf.gz'\n}",
                    "outputEval": "$(inheritMetadata(self, inputs.in_consensus))"
                  },
                  "sbg:fileTypes": "BCF.GZ"
                }
              ],
              "doc": "**Gunzip and enhance BCF** is a custom tool prepared as a part of the consensus bcftools step in V-pipe workflow.",
              "label": "Gunzip and enhance BCF",
              "arguments": [
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 0,
                  "valueFrom": "${\n    return '/bin/bash -c \\'gunzip -c ' + inputs.in_coverage.path + ' | tail -n +2 | awk -v base=0 \\'\"\\'\\\\$3 < ' + inputs.mask_coverage_threshold + ' {printf \"\\'\"%s\\\\t%d\\\\t%d\\\\n\"\\'\", \\\\$1, \\\\$2 - base, \\\\$2 - base + 1}\\'\"\\' > '+inputs.in_coverage.metadata['sample_id']+'.coverage_mask_lowcoverage.bed ; if [[ ${PIPESTATUS[@]} == \"0 0 0\" ]]; then echo \"Everything OK\"; else exit 1; fi && python3.8 enhance_bcf.py ' + inputs.in_consensus.path + ' '+ inputs.in_consensus.metadata['sample_id']+'.consensus.bcftools.bcf.gz ' + inputs.ambiguous_base_coverage_threshold +'\\''\n}"
                }
              ],
              "requirements": [
                {
                  "class": "ShellCommandRequirement"
                },
                {
                  "class": "ResourceRequirement",
                  "ramMin": 1500,
                  "coresMin": 1
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/python-3-8:0"
                },
                {
                  "class": "InitialWorkDirRequirement",
                  "listing": [
                    {
                      "entryname": "enhance_bcf.py",
                      "entry": "#!/usr/bin/env python3\n\"\"\"Amend genotype field to contain all variants.\"\"\"\n\nimport sys\n\nfrom cyvcf2 import VCF, Writer\n\n\ndef main(fname_in, fname_out, ambiguous_base_coverage_threshold):\n    \"\"\"\n    ambiguous_base_coverage_threshold:\n        frequency threshold to include a variant in computation of ambiguous code\n    \"\"\"\n    vcf_reader = VCF(fname_in)\n    vcf_writer = Writer(fname_out, vcf_reader)\n\n    for variant in vcf_reader:\n        base_list = [variant.REF] + variant.ALT\n        coverage_list = variant.INFO.get(\"AD\")\n\n        total_coverage = sum(coverage_list)\n        assert len(base_list) == len(coverage_list)\n\n        # genotype 0 is reference (base is not really needed)\n        genotype = [\n            i\n            for i, (base, coverage) in enumerate(zip(base_list, coverage_list))\n            if coverage / total_coverage >= ambiguous_base_coverage_threshold\n        ]\n\n        variant.genotypes = [[*genotype, False]]\n\n        vcf_writer.write_record(variant)\n\n    vcf_writer.close()\n    vcf_reader.close()\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2], float(sys.argv[3]))\n",
                      "writable": false
                    }
                  ]
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650376858,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650376888,
                  "sbg:revisionNotes": "Latest version from dev."
                },
                {
                  "sbg:revision": 2,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650518122,
                  "sbg:revisionNotes": "Corrected printf command."
                },
                {
                  "sbg:revision": 3,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1653030288,
                  "sbg:revisionNotes": "Pipe status check added."
                }
              ],
              "sbg:image_url": null,
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-140f52ea/h-8b7f5bf8/h-70616b2b/0",
              "sbg:revision": 3,
              "sbg:revisionNotes": "Pipe status check added.",
              "sbg:modifiedOn": 1653030288,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650376858,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 3,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "ab1d25bab83bd0bf5757673dbca87e58eef737a8ce83782d612c7f350af0da74c",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "Gunzip and enhance BCF",
            "sbg:x": 1180.5072021484375,
            "sbg:y": 398.8267822265625
          },
          {
            "id": "bcftools_index_1_13",
            "in": [
              {
                "id": "in_variants",
                "source": "gunzip_and_enhance_bcf/out_consensus"
              },
              {
                "id": "threads",
                "default": 1
              },
              {
                "id": "output_vcf_with_index",
                "default": true
              }
            ],
            "out": [
              {
                "id": "out_variants"
              },
              {
                "id": "index_file"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/bcftools-index-1-13/3",
              "baseCommand": [],
              "inputs": [
                {
                  "sbg:category": "File Input",
                  "id": "in_variants",
                  "type": "File",
                  "inputBinding": {
                    "shellQuote": false,
                    "position": 43,
                    "valueFrom": "${\n    var fname = inputs.in_variants.basename;\n    var fext = inputs.in_variants.nameext;\n    var froot = inputs.in_variants.nameroot;\n    if (fext != '.gz') {\n        if (inputs.compress_input){\n            fname = froot;\n            if (inputs.tbi_index) {\n                return fname + fext + \".gz\"} \n            else {\n                return fname + fext + \".gz\"}}\n        else{\n            return fname\n        }\n        \n        \n    } \n    else {\n        return fname}\n\n    \n}"
                  },
                  "label": "Input variants file",
                  "doc": "Input file which will be indexed.",
                  "sbg:fileTypes": "VCF.GZ, VCF"
                },
                {
                  "sbg:toolDefaultValue": "10",
                  "sbg:category": "Execution",
                  "id": "threads",
                  "type": "int?",
                  "inputBinding": {
                    "prefix": "--threads",
                    "shellQuote": false,
                    "position": 28
                  },
                  "label": "Threads",
                  "doc": "Number of threads."
                },
                {
                  "sbg:category": "Execution",
                  "sbg:toolDefaultValue": "1",
                  "id": "cpu_per_job",
                  "type": "int?",
                  "label": "CPU per job",
                  "doc": "Number of CPUs per job. Appropriate instance will be chosen based on this parameter."
                },
                {
                  "sbg:category": "Execution",
                  "sbg:toolDefaultValue": "1000",
                  "id": "mem_per_job",
                  "type": "int?",
                  "label": "Memory per job",
                  "doc": "Memory per job in MB. Appropriate instance will be chosen based on this parameter."
                },
                {
                  "sbg:category": "Indexing options",
                  "sbg:altPrefix": "-c",
                  "id": "csi_index",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--csi",
                    "shellQuote": false,
                    "position": 4
                  },
                  "label": "Generate CSI Index",
                  "doc": "Generate CSI-format index for VCF/BCF files [default]."
                },
                {
                  "sbg:category": "Indexing options",
                  "sbg:altPrefix": "-f",
                  "id": "force",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--force",
                    "shellQuote": false,
                    "position": 5
                  },
                  "label": "Overwrite index",
                  "doc": "Overwrite index if it already exists"
                },
                {
                  "sbg:toolDefaultValue": "14",
                  "sbg:category": "Indexing options",
                  "sbg:altPrefix": "-m",
                  "id": "min_interval",
                  "type": "int?",
                  "inputBinding": {
                    "prefix": "--min-shift",
                    "shellQuote": false,
                    "position": 6
                  },
                  "label": "Minimal interval",
                  "doc": "Set minimal interval size for CSI indices to 2^INT."
                },
                {
                  "sbg:category": "Indexing options",
                  "sbg:altPrefix": "-t",
                  "id": "tbi_index",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--tbi",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "Generate TBI Index",
                  "doc": "Generate TBI-format index for VCF files."
                },
                {
                  "sbg:category": "Stats options",
                  "sbg:altPrefix": "-n",
                  "id": "nrecords",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--nrecords",
                    "shellQuote": false,
                    "position": 9
                  },
                  "label": "Number of records",
                  "doc": "Print the number of records based on the CSI or TBI index files."
                },
                {
                  "sbg:category": "Stats options",
                  "sbg:altPrefix": "-s",
                  "id": "stats",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--stats",
                    "shellQuote": false,
                    "position": 11
                  },
                  "label": "Print stats",
                  "doc": "Print per contig stats based on the CSI or TBI index files. Output format is three tab-delimited columns listing the contig name, contig length (. if unknown) and number of records for the contig. Contigs with zero records are not printed."
                },
                {
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "General options",
                  "id": "output_vcf_with_index",
                  "type": "boolean?",
                  "label": "Output VCF file with index",
                  "doc": "Output VCF file with index."
                },
                {
                  "sbg:toolDefaultValue": "True",
                  "id": "compress_input",
                  "type": "boolean?",
                  "label": "Compress input file",
                  "doc": "For `tbi` indexing input variants file should be compressed, if uncompressed VCF is given on input this input should be set to true."
                }
              ],
              "outputs": [
                {
                  "id": "out_variants",
                  "doc": "Output file with its secondary index file.",
                  "label": "Output VCF file",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "${\n    var fname = inputs.in_variants;\n    var fext = inputs.in_variants.nameext;\n    if (inputs.output_vcf_with_index == true) {\n        if (inputs.tbi_index) {return [\"*.vcf.gz\",\"*.bcf.gz\"]} \n        else if (fext == '.gz') {return [\"*.vcf.gz\",\"*.bcf.gz\"]} \n        else {return [\"*.vcf.gz\",\"*.bcf.gz\"]}\n    } \n    else {\n        return \"\"}\n\n}",
                    "outputEval": "$(inheritMetadata(self, inputs.in_variants))"
                  },
                  "secondaryFiles": [
                    {
                      "pattern": ".tbi",
                      "required": false
                    },
                    {
                      "pattern": ".csi",
                      "required": false
                    }
                  ],
                  "sbg:fileTypes": "VCF, VCF.GZ, BCF, BCF.GZ"
                },
                {
                  "id": "index_file",
                  "doc": "Index file.",
                  "label": "Index file",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "${\n    if (inputs.tbi_index) {\n        return \"*.tbi\"\n    } else {\n        return \"*.csi\"\n    }\n\n}",
                    "outputEval": "$(inheritMetadata(self, inputs.in_variants))"
                  },
                  "sbg:fileTypes": "TBI, CSI"
                }
              ],
              "doc": "**BCFtools Index**: Creates index for bgzip-compressed VCF/BCF files for random access. CSI (coordinate-sorted index) is created by default. \n\n**BCFtools** is a set of utilities that manipulate variant calls in the Variant Call Format (VCF) and its binary counterpart BCF. All commands work transparently with both VCFs and BCFs, both uncompressed and BGZF-compressed. Most commands accept VCF, bgzipped VCF and BCF with filetype detected automatically even when streaming from a pipe. Indexed VCF and BCF will work in all situations. Un-indexed VCF and BCF and streams will work in most, but not all situations. In general, whenever multiple VCFs are read simultaneously, they must be indexed and therefore also compressed. [1]\n\nA list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.\n\n### Common Use Cases\n\nThe **CSI** format supports indexing of chromosomes up to 2^31 in length with **Generate CSI Index** (`--csi`). When loading an index file, BCFtools will try the **CSI** first and then the **TBI**.\n```\n$bcftools index --csi file.vcf.gz\n```\n**TBI** (tabix index) index files, which support chromosome lengths up to 2^29, can be created by using the **Generate TBI Index** (`--tbi`) option or using the tabix program packaged with **htslib**.\n```\n$bcftools index --tbi file.vcf.gz\n```\n\n### Changes Introduced by Seven Bridges\n\n* Since this tool creates `tbi` index for compressed VCF files, if regular uncompressed VCF file is given on input, file needs to be compressed with `compress_input` parameter and then it will be indexed.\n\n* **Output VCF file with index** option is added which allows user to get the index file along with the VCF on the output, to be used in tools that require VCFs with a corresponding secondary index file.\n\n### Common Issues and Important Notes\n\n * Only bgzip compressed VCF file could be indexed, parameter `compress_input` should be set to True, otherwise tool will fail.  \n\n### Performance Benchmarking\n\nIt took 3 minutes to execute this tool on AWS c4.2xlarge instance using an input of 7 MB. The price is negligible ($0.02).\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n### References\n[1 - BCFtools page](https://samtools.github.io/bcftools/bcftools.html)",
              "label": "Bcftools Index",
              "arguments": [
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 0,
                  "valueFrom": "${\n    var fname = inputs.in_variants.basename;\n    var fext = inputs.in_variants.nameext;\n    var froot = inputs.in_variants.nameroot;\n    if (fext != '.gz') {\n        if (inputs.compress_input){\n            var froot_ext = fname.split('.').pop();\n            if (inputs.tbi_index) {\n                return \"bgzip -c -f \" + froot + \".\" + froot_ext + \" > \" + froot + \".\" + froot_ext + \".gz &&\" }\n            else if (inputs.csi_index) {\n                return  \"bgzip -c -f \" + froot + \".\" + froot_ext + \" > \" + froot + \".\" + froot_ext + \".gz &&\" }\n            \n        }\n        else {return \"\"}\n    }\n    else {return \"\"}\n\n    \n}"
                },
                {
                  "shellQuote": false,
                  "position": 1,
                  "valueFrom": "bcftools"
                },
                {
                  "shellQuote": false,
                  "position": 2,
                  "valueFrom": "index"
                }
              ],
              "requirements": [
                {
                  "class": "ShellCommandRequirement"
                },
                {
                  "class": "ResourceRequirement",
                  "ramMin": "${\n    if (inputs.mem_per_job) {\n        return inputs.mem_per_job} \n    else {\n        return 1000}\n\n}",
                  "coresMin": "${\n    if (inputs.cpu_per_job) {\n        return inputs.cpu_per_job} \n    else {\n        return 1}\n}"
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/bcftools-1-13:0"
                },
                {
                  "class": "InitialWorkDirRequirement",
                  "listing": [
                    "$(inputs.in_variants)"
                  ]
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:toolkitVersion": "1.13",
              "sbg:toolAuthor": "Petr Danecek, Shane McCarthy, John Marshall",
              "sbg:categories": [
                "VCF-Processing"
              ],
              "sbg:links": [
                {
                  "id": "http://samtools.github.io/bcftools/",
                  "label": "Homepage"
                },
                {
                  "id": "https://github.com/samtools/bcftools",
                  "label": "Source code"
                },
                {
                  "id": "https://github.com/samtools/bcftools/wiki",
                  "label": "Wiki"
                },
                {
                  "id": "https://github.com/samtools/bcftools/archive/1.9.zip",
                  "label": "Download"
                }
              ],
              "sbg:cmdPreview": "bgzip -c -f annotated_input_file.vcf > annotated_input_file.vcf.gz && bcftools index  annotated_input_file.vcf.gz",
              "sbg:toolkit": "bcftools",
              "sbg:image_url": null,
              "sbg:license": "MIT License",
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650376802,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650376827,
                  "sbg:revisionNotes": "Latest version from dev."
                },
                {
                  "sbg:revision": 2,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650434074,
                  "sbg:revisionNotes": "JS edited."
                },
                {
                  "sbg:revision": 3,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1651741942,
                  "sbg:revisionNotes": "Updated for cwltool."
                }
              ],
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-0cff930c/h-49154d91/h-f6ae95fb/0",
              "sbg:revision": 3,
              "sbg:revisionNotes": "Updated for cwltool.",
              "sbg:modifiedOn": 1651741942,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650376802,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 3,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "a1ee6ebf5e17a7c820e1afea30a83df7a3f68f5650544e1b9a2b4ab86e9be54e9",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "Bcftools Index",
            "sbg:x": 1376.828857421875,
            "sbg:y": 399.74017333984375
          },
          {
            "id": "bcftools_consensus_1_13_majority",
            "in": [
              {
                "id": "in_variants",
                "source": [
                  "bcftools_index_1_13/out_variants"
                ],
                "valueFrom": "$(self ? [self] : self)"
              },
              {
                "id": "include_expression",
                "default": "\"INFO/AD[0]<INFO/AD[*]\""
              },
              {
                "id": "output_name",
                "valueFrom": "${\n    return inputs.in_variants.metadata['sample_id']+'.consensus.bcftools'\n}"
              },
              {
                "id": "chain",
                "valueFrom": "${\n    return inputs.in_variants.metadata['sample_id']+'.consensus.bcftools.chain'\n}"
              },
              {
                "id": "in_reference",
                "source": "in_reference"
              },
              {
                "id": "haplotype",
                "default": "A"
              },
              {
                "id": "mask_file",
                "source": "gunzip_and_enhance_bcf/out_lowcoverage"
              },
              {
                "id": "mark_del",
                "default": "-"
              },
              {
                "id": "mask_with",
                "default": "n"
              }
            ],
            "out": [
              {
                "id": "output_reference"
              },
              {
                "id": "output_chain"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/bcftools-consensus-1-13/5",
              "baseCommand": [],
              "inputs": [
                {
                  "sbg:category": "File Input",
                  "id": "in_variants",
                  "type": "File[]",
                  "inputBinding": {
                    "shellQuote": false,
                    "position": 43,
                    "valueFrom": "${\n    var files_array = [].concat(inputs.in_variants);\n    var in_file = files_array[0];\n    var fname = in_file.basename;\n    var fext = in_file.nameext;\n    var froot = in_file.nameroot;\n    if (fext == '.gz') {\n        return froot + \".gz\"} \n    else {\n        if(fname.split('.').pop() == 'bcf'){\n            var index_csi_file = fname + '.csi';\n            if (inputs.in_variants[0].secondaryFiles[0]){\n                var secondary_given = in_file.secondaryFiles[0].path.replace(/^.*[\\\\\\/]/, '');}\n                if(secondary_given == index_csi_file){\n                    return fname;}\n            \n        }\n        return fname + \".gz\"\n    }\n}"
                  },
                  "label": "Input variants file",
                  "doc": "Input variants file.",
                  "sbg:fileTypes": "VCF, VCF.GZ, BCF, BCF.GZ",
                  "secondaryFiles": [
                    {
                      "pattern": "${ \n    if(self.basename.split('.').pop() == 'gz'){\n    if(self.nameroot.split('.').pop() == 'bcf'){\n        return self.nameroot + \".gz.csi\"}\n    else{\n        return self.nameroot + \".gz.tbi\"\n    }\n}  else{\n    if(self.basename.split('.').pop() == 'bcf'){\n        return self.basename + \".csi\"\n    }\n    else{\n    return self.basename + \".tbi\"}\n}\n\n}",
                      "required": true
                    }
                  ]
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-i",
                  "id": "include_expression",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--include",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "Include expression",
                  "doc": "Include only sites for which the expression is true."
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-e",
                  "id": "exclude_expression",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--exclude",
                    "shellQuote": false,
                    "position": 4
                  },
                  "label": "Exclude expression",
                  "doc": "Exclude sites for which the expression is true."
                },
                {
                  "sbg:category": "Configuration",
                  "id": "output_name",
                  "type": "string?",
                  "label": "Output file name",
                  "doc": "Name of the output file."
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-s",
                  "id": "sample",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--sample",
                    "shellQuote": false,
                    "position": 23
                  },
                  "label": "Sample",
                  "doc": "Apply variants of the given sample."
                },
                {
                  "sbg:category": "Execution",
                  "sbg:toolDefaultValue": "1",
                  "id": "cpu_per_job",
                  "type": "int?",
                  "label": "CPU per job",
                  "doc": "Number of CPUs per job. Appropriate instance will be chosen based on this parameter."
                },
                {
                  "sbg:category": "Execution",
                  "sbg:toolDefaultValue": "1000",
                  "id": "mem_per_job",
                  "type": "int?",
                  "label": "Memory per job",
                  "doc": "Memory per job in MB. Appropriate instance will be chosen based on this parameter."
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-c",
                  "id": "chain",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--chain",
                    "shellQuote": false,
                    "position": 3
                  },
                  "label": "Chain file name",
                  "doc": "Write a chain file for liftover."
                },
                {
                  "sbg:altPrefix": "-f",
                  "sbg:category": "File Input",
                  "id": "in_reference",
                  "type": "File",
                  "inputBinding": {
                    "prefix": "--fasta-ref",
                    "shellQuote": false,
                    "position": 5
                  },
                  "label": "Reference Genome",
                  "doc": "Reference sequence in fasta format.",
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-H",
                  "id": "haplotype",
                  "type": [
                    "null",
                    {
                      "type": "enum",
                      "symbols": [
                        "1",
                        "2",
                        "R",
                        "A",
                        "LR",
                        "LA",
                        "SR",
                        "SA",
                        "1pIu",
                        "2pIu",
                        "I"
                      ],
                      "name": "haplotype"
                    }
                  ],
                  "inputBinding": {
                    "prefix": "--haplotype",
                    "shellQuote": false,
                    "position": 7,
                    "valueFrom": "${\n    if (self == 0) {\n        self = null;\n        inputs.haplotype = null;\n    };\n\n\n\n    if (inputs.haplotype == '1') {\n        return \"1\"\n    }\n    if (inputs.haplotype == '2') {\n        return \"2\"\n    }\n    if (inputs.haplotype == 'R') {\n        return \"R\"\n    }\n    if (inputs.haplotype == 'A') {\n        return \"A\"\n    }\n    if (inputs.haplotype == 'LR') {\n        return \"LR\"\n    }\n    if (inputs.haplotype == 'LA') {\n        return \"LA\"\n    }\n    if (inputs.haplotype == 'SR') {\n        return \"SR\"\n    }\n    if (inputs.haplotype == 'SA') {\n        return \"SA\"\n    }\n    if (inputs.haplotype == '1pIu') {\n        return \"1pIu\"\n    }\n    if (inputs.haplotype == '2pIu') {\n        return \"2pIu\"\n    }\n    if (inputs.haplotype == 'I') {\n        return \"I\"\n    }\n\n\n\n\n}"
                  },
                  "label": "Haplotype",
                  "doc": "Choose which allele to use from the FORMAT/GT field: \n1: the first allele, regardless of phasing\n2: the second allele, regardless of phasing\nR: the REF allele (in heterozygous genotypes)\nA: the ALT allele (in heterozygous genotypes)\nLR, LA: the longer allele. If both have the same length, use the REF allele (LR), or the ALT allele (LA)\nSR, SA: the shorter allele. If both have the same length, use the REF allele (SR), or the ALT allele (SA)\n1pIu, 2pIu: first/second allele for phased genotypes and IUPAC code for unphased genotypes.",
                  "default": 0
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-I",
                  "id": "iupac",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--iupac-codes",
                    "shellQuote": false,
                    "position": 9
                  },
                  "label": "Output in IUPAC",
                  "doc": "Output variants in the form of IUPAC ambiguity codes."
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-m",
                  "id": "mask_file",
                  "type": "File?",
                  "inputBinding": {
                    "prefix": "--mask",
                    "shellQuote": false,
                    "position": 10
                  },
                  "label": "Mask file",
                  "doc": "Replace regions with N.",
                  "sbg:fileTypes": "BED, TSV"
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-M",
                  "id": "missing",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--missing",
                    "shellQuote": false,
                    "position": 12
                  },
                  "label": "Missing genotypes",
                  "doc": "Output <char> instead of skipping the missing genotypes."
                },
                {
                  "sbg:altPrefix": "-p",
                  "sbg:category": "General Options",
                  "id": "prefix",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--prefix",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "Prefix",
                  "doc": "Prefix to add to output sequence names."
                },
                {
                  "id": "mark_del",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--mark-del",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "Mark deletions",
                  "doc": "Instead of removing sequence, insert CHAR for deletions."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "mask_with",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--mask-with",
                    "shellQuote": false,
                    "position": 11
                  },
                  "label": "Mask with string",
                  "doc": "Replace sequence from --mask with CHAR, skipping overlapping variants, or change to lowercase (lc) or uppercase (uc)."
                },
                {
                  "id": "iupac-codes",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--iupac-codes",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "IUPAC ambiguity codes",
                  "doc": "Output variants in the form of IUPAC ambiguity codes."
                }
              ],
              "outputs": [
                {
                  "id": "output_reference",
                  "doc": "Output consensus sequence in FASTA format.",
                  "label": "Output consensus sequence",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "${\n    var in_files_array = [].concat(inputs.in_variants);\n    var in_file = in_files_array[0];\n    var fname = in_file.basename;\n    var fname_ext = in_file.nameext;\n    var froot = in_file.nameroot;\n    var out_name = '';\n    if (fname_ext == '.gz') {\n        if (froot.split('.').pop() == 'vcf'){\n        out_name = froot.split('.vcf')[0];}\n        else if (froot.split('.').pop() == 'bcf'){\n        out_name = froot.split('.bcf')[0];}\n    }\n\n    if(in_file.metadata.sample_id){\n        var froot = in_file.metadata.sample_id;}\n        \n    if (inputs.output_name) {\n        var out_name = inputs.output_name;}\n\n    else {\n        var out_name = froot;}\n\n        // return out_name\n    return out_name + \".fasta\"\n}",
                    "outputEval": "$(inheritMetadata(self, inputs.in_variants))"
                  },
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "id": "output_chain",
                  "doc": "Chain file.",
                  "label": "Chain file",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "${\n    return '*'+inputs.chain\n}",
                    "outputEval": "$(inheritMetadata(self, inputs.in_variants))"
                  },
                  "sbg:fileTypes": "CHAIN"
                }
              ],
              "doc": "**BCFtools Consensus**: Create a consensus sequence by applying VCF variants to a reference FASTA file. \n\n\n**BCFtools** is a set of utilities that manipulate variant calls in the Variant Call Format (VCF) and its binary counterpart BCF. All commands work transparently with both VCFs and BCFs, both uncompressed and BGZF-compressed. Most commands accept VCF, bgzipped VCF and BCF with filetype detected automatically even when streaming from a pipe. Indexed VCF and BCF will work in all situations. Un-indexed VCF and BCF and streams will work in most, but not all situations. In general, whenever multiple VCFs are read simultaneously, they must be indexed and therefore also compressed. [1]\n\nA list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.\n\n\n### Common Use Cases\n\nBy default, the program will apply all ALT variants to the reference FASTA to obtain the consensus sequence. Can be also used with the **SAMtools Faidx** tool where the desired part of reference can be extracted and then provided  to this tool.\n\n\nUsing the **Sample** (`--sample`) (and, optionally, **Haplotype** (`--haplotype`) option will apply genotype (haplotype) calls from FORMAT/GT. \n```\n$bcftools consensus -s NA001 -f in.fa in.vcf.gz > out.fa\n```\n\nApply variants present in sample \"NA001\", output IUPAC codes using **Output in IUPAC** (`--iupac-codes`) option\n```\nbcftools consensus --iupac-codes -s NA001 -f in.fa in.vcf.gz > out.fa\n```\n\n### Changes Introduced by Seven Bridges\n\n* BCFtools works in all cases with gzipped and indexed VCF/BCF files. To be sure BCFtools works in all cases, we added subsequet `bgzip` and `index` commands if a VCF file is provided on input. If VCF.GZ is given on input only indexing will be done. Index file `.tbi` is added as secondary file of `in_variants` input which means if VCF.GZ is provided on input, tool will look for index file in project or previous tool (in case of usage in workflow) and if present, it will not perform nor compressing nor indexing.\n\n\n### Common Issues and Important Notes\n\n* By default, the program will apply all ALT variants to the reference FASTA to obtain the consensus sequence. \n\n * If the FASTA sequence does not match the REF allele at a given position, the tool will fail.\n\n### Performance Benchmarking\n\nIt took 5 minutes to execute this tool on AWS c4.2xlarge instance with a 56 KB VCF and a 3 GB reference FASTA file. The price is negligible ($0.02).\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n### References\n[1 - BCFtools page](https://samtools.github.io/bcftools/bcftools.html)",
              "label": "Bcftools Consensus",
              "arguments": [
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 0,
                  "valueFrom": "${\n    var in_files_array = [].concat(inputs.in_variants);\n    var in_file = in_files_array[0];\n    var fname = in_file.basename;\n    var fname_ext = in_file.nameext;\n    var froot = in_file.nameroot;\n    if (fname_ext == '.gz') {\n        var index_tbi_file = fname + '.tbi';\n        var index_csi_file = fname + '.csi';\n        if (in_file.secondaryFiles[0]){\n        var secondary_given = in_file.secondaryFiles[0].path.replace(/^.*[\\\\\\/]/, '');}\n            if(secondary_given == index_tbi_file || secondary_given == index_csi_file){\n                return \"\";\n        }\n        else {\n            if(froot.split('.').pop() == 'bcf'){\n                return \"bcftools index  -f -c \" + froot + \".gz &&\";\n            }\n            else{\n            return \"bcftools index  -f -t \" + froot + \".gz &&\";}\n        }\n    } else {\n        if(fname.split('.').pop() == 'bcf'){\n            var index_csi_file = fname + '.csi';\n            if (in_file.secondaryFiles[0]){\n                var secondary_given = in_file.secondaryFiles[0].path.replace(/^.*[\\\\\\/]/, '');}\n                if(secondary_given == index_csi_file){\n                return \"\";}\n            else{\n                return \"bgzip -c -f \" + fname + \" > \" + fname + \".gz\" + \" && bcftools index -f -c \" + fname + \".gz &&\";}\n            }    \n        return \"bgzip -c -f \" + fname + \" > \" + fname + \".gz\" + \" && bcftools index -f -t \" + fname + \".gz &&\";\n\n    }\n}"
                },
                {
                  "shellQuote": false,
                  "position": 1,
                  "valueFrom": "bcftools"
                },
                {
                  "shellQuote": false,
                  "position": 2,
                  "valueFrom": "consensus"
                },
                {
                  "prefix": "--output",
                  "shellQuote": false,
                  "position": 6,
                  "valueFrom": "${\n    var in_files_array = [].concat(inputs.in_variants);\n    var in_file = in_files_array[0];\n    var fname = in_file.basename;\n    var fname_ext = in_file.nameext;\n    var froot = in_file.nameroot;\n    var out_name = '';\n    if (fname_ext == '.gz') {\n        if (froot.split('.').pop() == 'vcf'){\n            out_name = froot.split('.vcf')[0];}\n        else if (froot.split('.').pop() == 'bcf'){\n            out_name = froot.split('.bcf')[0];}\n    }\n    if(in_file.metadata.sample_id){\n        var froot = in_file.metadata.sample_id;}\n        \n    if (inputs.output_name) {\n        var out_name = inputs.output_name;}\n\n    else {\n        var out_name = froot;}\n\n        // return out_name\n    return out_name + \".fasta\"\n}"
                }
              ],
              "requirements": [
                {
                  "class": "ShellCommandRequirement"
                },
                {
                  "class": "ResourceRequirement",
                  "ramMin": "${\n    if (inputs.mem_per_job) {\n        return inputs.mem_per_job\n    } else {\n        return 1000\n    }\n}",
                  "coresMin": "${\n    if (inputs.cpu_per_job) {\n        return inputs.cpu_per_job\n    } else {\n        return 1\n    }\n}"
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/bcftools-1-13:0"
                },
                {
                  "class": "InitialWorkDirRequirement",
                  "listing": [
                    "$(inputs.in_variants)"
                  ]
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};",
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:toolkitVersion": "1.13",
              "sbg:toolAuthor": "Petr Danecek, Shane McCarthy, John Marshall",
              "sbg:categories": [
                "VCF Processing"
              ],
              "sbg:links": [
                {
                  "id": "http://samtools.github.io/bcftools/",
                  "label": "Homepage"
                },
                {
                  "id": "https://github.com/samtools/bcftools",
                  "label": "Source code"
                },
                {
                  "id": "https://github.com/samtools/bcftools/wiki",
                  "label": "Wiki"
                },
                {
                  "id": "https://github.com/samtools/bcftools/archive/1.9.zip",
                  "label": "Download"
                }
              ],
              "sbg:cmdPreview": "bcftools index  -f -t input_file.vcf.gz && bcftools consensus --fasta-ref /path/to/reference.ext --output input_file.fa  input_file.vcf.gz",
              "sbg:toolkit": "bcftools",
              "sbg:image_url": null,
              "sbg:license": "MIT License",
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377553,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377577,
                  "sbg:revisionNotes": "Latest version from dev."
                },
                {
                  "sbg:revision": 2,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650435220,
                  "sbg:revisionNotes": "JS edited."
                },
                {
                  "sbg:revision": 3,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650474833,
                  "sbg:revisionNotes": "Removed secondary file for reference."
                },
                {
                  "sbg:revision": 4,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650517411,
                  "sbg:revisionNotes": "Added chain output."
                },
                {
                  "sbg:revision": 5,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1651742034,
                  "sbg:revisionNotes": "Edited for cwltool."
                }
              ],
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-300f073a/h-e6d59b67/h-0551f5bd/0",
              "sbg:revision": 5,
              "sbg:revisionNotes": "Edited for cwltool.",
              "sbg:modifiedOn": 1651742034,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650377553,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 5,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "a3aaca3a34a5103b834d22ef6f5fb802c111885583f489f1499a0825d096a776f",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "Bcftools Consensus Majority",
            "sbg:x": 1567.9869384765625,
            "sbg:y": 307
          },
          {
            "id": "bcftools_consensus_1_13_ambig",
            "in": [
              {
                "id": "in_variants",
                "source": [
                  "bcftools_index_1_13/out_variants"
                ],
                "valueFrom": "$(self ? [self] : self)"
              },
              {
                "id": "output_name",
                "valueFrom": "${\n    return inputs.in_variants.metadata['sample_id']+'.consensus_ambig.bcftools'\n}"
              },
              {
                "id": "chain",
                "valueFrom": "${\n    return inputs.in_variants.metadata['sample_id']+'.consensus_ambig.bcftools.chain'\n}"
              },
              {
                "id": "in_reference",
                "source": "in_reference"
              },
              {
                "id": "haplotype",
                "default": "I"
              },
              {
                "id": "mask_file",
                "source": "gunzip_and_enhance_bcf/out_lowcoverage"
              },
              {
                "id": "mark_del",
                "default": "-"
              },
              {
                "id": "mask_with",
                "default": "n"
              },
              {
                "id": "iupac-codes",
                "default": true
              }
            ],
            "out": [
              {
                "id": "output_reference"
              },
              {
                "id": "output_chain"
              }
            ],
            "run": {
              "class": "CommandLineTool",
              "cwlVersion": "v1.2",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/bcftools-consensus-1-13/5",
              "baseCommand": [],
              "inputs": [
                {
                  "sbg:category": "File Input",
                  "id": "in_variants",
                  "type": "File[]",
                  "inputBinding": {
                    "shellQuote": false,
                    "position": 43,
                    "valueFrom": "${\n    var files_array = [].concat(inputs.in_variants);\n    var in_file = files_array[0];\n    var fname = in_file.basename;\n    var fext = in_file.nameext;\n    var froot = in_file.nameroot;\n    if (fext == '.gz') {\n        return froot + \".gz\"} \n    else {\n        if(fname.split('.').pop() == 'bcf'){\n            var index_csi_file = fname + '.csi';\n            if (inputs.in_variants[0].secondaryFiles[0]){\n                var secondary_given = in_file.secondaryFiles[0].path.replace(/^.*[\\\\\\/]/, '');}\n                if(secondary_given == index_csi_file){\n                    return fname;}\n            \n        }\n        return fname + \".gz\"\n    }\n}"
                  },
                  "label": "Input variants file",
                  "doc": "Input variants file.",
                  "sbg:fileTypes": "VCF, VCF.GZ, BCF, BCF.GZ",
                  "secondaryFiles": [
                    {
                      "pattern": "${ \n    if(self.basename.split('.').pop() == 'gz'){\n    if(self.nameroot.split('.').pop() == 'bcf'){\n        return self.nameroot + \".gz.csi\"}\n    else{\n        return self.nameroot + \".gz.tbi\"\n    }\n}  else{\n    if(self.basename.split('.').pop() == 'bcf'){\n        return self.basename + \".csi\"\n    }\n    else{\n    return self.basename + \".tbi\"}\n}\n\n}",
                      "required": true
                    }
                  ]
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-i",
                  "id": "include_expression",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--include",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "Include expression",
                  "doc": "Include only sites for which the expression is true."
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-e",
                  "id": "exclude_expression",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--exclude",
                    "shellQuote": false,
                    "position": 4
                  },
                  "label": "Exclude expression",
                  "doc": "Exclude sites for which the expression is true."
                },
                {
                  "sbg:category": "Configuration",
                  "id": "output_name",
                  "type": "string?",
                  "label": "Output file name",
                  "doc": "Name of the output file."
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-s",
                  "id": "sample",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--sample",
                    "shellQuote": false,
                    "position": 23
                  },
                  "label": "Sample",
                  "doc": "Apply variants of the given sample."
                },
                {
                  "sbg:category": "Execution",
                  "sbg:toolDefaultValue": "1",
                  "id": "cpu_per_job",
                  "type": "int?",
                  "label": "CPU per job",
                  "doc": "Number of CPUs per job. Appropriate instance will be chosen based on this parameter."
                },
                {
                  "sbg:category": "Execution",
                  "sbg:toolDefaultValue": "1000",
                  "id": "mem_per_job",
                  "type": "int?",
                  "label": "Memory per job",
                  "doc": "Memory per job in MB. Appropriate instance will be chosen based on this parameter."
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-c",
                  "id": "chain",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--chain",
                    "shellQuote": false,
                    "position": 3
                  },
                  "label": "Chain file name",
                  "doc": "Write a chain file for liftover."
                },
                {
                  "sbg:altPrefix": "-f",
                  "sbg:category": "File Input",
                  "id": "in_reference",
                  "type": "File",
                  "inputBinding": {
                    "prefix": "--fasta-ref",
                    "shellQuote": false,
                    "position": 5
                  },
                  "label": "Reference Genome",
                  "doc": "Reference sequence in fasta format.",
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-H",
                  "id": "haplotype",
                  "type": [
                    "null",
                    {
                      "type": "enum",
                      "symbols": [
                        "1",
                        "2",
                        "R",
                        "A",
                        "LR",
                        "LA",
                        "SR",
                        "SA",
                        "1pIu",
                        "2pIu",
                        "I"
                      ],
                      "name": "haplotype"
                    }
                  ],
                  "inputBinding": {
                    "prefix": "--haplotype",
                    "shellQuote": false,
                    "position": 7,
                    "valueFrom": "${\n    if (self == 0) {\n        self = null;\n        inputs.haplotype = null;\n    };\n\n\n\n    if (inputs.haplotype == '1') {\n        return \"1\"\n    }\n    if (inputs.haplotype == '2') {\n        return \"2\"\n    }\n    if (inputs.haplotype == 'R') {\n        return \"R\"\n    }\n    if (inputs.haplotype == 'A') {\n        return \"A\"\n    }\n    if (inputs.haplotype == 'LR') {\n        return \"LR\"\n    }\n    if (inputs.haplotype == 'LA') {\n        return \"LA\"\n    }\n    if (inputs.haplotype == 'SR') {\n        return \"SR\"\n    }\n    if (inputs.haplotype == 'SA') {\n        return \"SA\"\n    }\n    if (inputs.haplotype == '1pIu') {\n        return \"1pIu\"\n    }\n    if (inputs.haplotype == '2pIu') {\n        return \"2pIu\"\n    }\n    if (inputs.haplotype == 'I') {\n        return \"I\"\n    }\n\n\n\n\n}"
                  },
                  "label": "Haplotype",
                  "doc": "Choose which allele to use from the FORMAT/GT field: \n1: the first allele, regardless of phasing\n2: the second allele, regardless of phasing\nR: the REF allele (in heterozygous genotypes)\nA: the ALT allele (in heterozygous genotypes)\nLR, LA: the longer allele. If both have the same length, use the REF allele (LR), or the ALT allele (LA)\nSR, SA: the shorter allele. If both have the same length, use the REF allele (SR), or the ALT allele (SA)\n1pIu, 2pIu: first/second allele for phased genotypes and IUPAC code for unphased genotypes.",
                  "default": 0
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-I",
                  "id": "iupac",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--iupac-codes",
                    "shellQuote": false,
                    "position": 9
                  },
                  "label": "Output in IUPAC",
                  "doc": "Output variants in the form of IUPAC ambiguity codes."
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-m",
                  "id": "mask_file",
                  "type": "File?",
                  "inputBinding": {
                    "prefix": "--mask",
                    "shellQuote": false,
                    "position": 10
                  },
                  "label": "Mask file",
                  "doc": "Replace regions with N.",
                  "sbg:fileTypes": "BED, TSV"
                },
                {
                  "sbg:category": "General Options",
                  "sbg:altPrefix": "-M",
                  "id": "missing",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--missing",
                    "shellQuote": false,
                    "position": 12
                  },
                  "label": "Missing genotypes",
                  "doc": "Output <char> instead of skipping the missing genotypes."
                },
                {
                  "sbg:altPrefix": "-p",
                  "sbg:category": "General Options",
                  "id": "prefix",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--prefix",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "Prefix",
                  "doc": "Prefix to add to output sequence names."
                },
                {
                  "id": "mark_del",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--mark-del",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "Mark deletions",
                  "doc": "Instead of removing sequence, insert CHAR for deletions."
                },
                {
                  "sbg:category": "Config Inputs",
                  "id": "mask_with",
                  "type": "string?",
                  "inputBinding": {
                    "prefix": "--mask-with",
                    "shellQuote": false,
                    "position": 11
                  },
                  "label": "Mask with string",
                  "doc": "Replace sequence from --mask with CHAR, skipping overlapping variants, or change to lowercase (lc) or uppercase (uc)."
                },
                {
                  "id": "iupac-codes",
                  "type": "boolean?",
                  "inputBinding": {
                    "prefix": "--iupac-codes",
                    "shellQuote": false,
                    "position": 8
                  },
                  "label": "IUPAC ambiguity codes",
                  "doc": "Output variants in the form of IUPAC ambiguity codes."
                }
              ],
              "outputs": [
                {
                  "id": "output_reference",
                  "doc": "Output consensus sequence in FASTA format.",
                  "label": "Output consensus sequence",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "${\n    var in_files_array = [].concat(inputs.in_variants);\n    var in_file = in_files_array[0];\n    var fname = in_file.basename;\n    var fname_ext = in_file.nameext;\n    var froot = in_file.nameroot;\n    var out_name = '';\n    if (fname_ext == '.gz') {\n        if (froot.split('.').pop() == 'vcf'){\n        out_name = froot.split('.vcf')[0];}\n        else if (froot.split('.').pop() == 'bcf'){\n        out_name = froot.split('.bcf')[0];}\n    }\n\n    if(in_file.metadata.sample_id){\n        var froot = in_file.metadata.sample_id;}\n        \n    if (inputs.output_name) {\n        var out_name = inputs.output_name;}\n\n    else {\n        var out_name = froot;}\n\n        // return out_name\n    return out_name + \".fasta\"\n}",
                    "outputEval": "$(inheritMetadata(self, inputs.in_variants))"
                  },
                  "sbg:fileTypes": "FASTA"
                },
                {
                  "id": "output_chain",
                  "doc": "Chain file.",
                  "label": "Chain file",
                  "type": "File?",
                  "outputBinding": {
                    "glob": "${\n    return '*'+inputs.chain\n}",
                    "outputEval": "$(inheritMetadata(self, inputs.in_variants))"
                  },
                  "sbg:fileTypes": "CHAIN"
                }
              ],
              "doc": "**BCFtools Consensus**: Create a consensus sequence by applying VCF variants to a reference FASTA file. \n\n\n**BCFtools** is a set of utilities that manipulate variant calls in the Variant Call Format (VCF) and its binary counterpart BCF. All commands work transparently with both VCFs and BCFs, both uncompressed and BGZF-compressed. Most commands accept VCF, bgzipped VCF and BCF with filetype detected automatically even when streaming from a pipe. Indexed VCF and BCF will work in all situations. Un-indexed VCF and BCF and streams will work in most, but not all situations. In general, whenever multiple VCFs are read simultaneously, they must be indexed and therefore also compressed. [1]\n\nA list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.\n\n\n### Common Use Cases\n\nBy default, the program will apply all ALT variants to the reference FASTA to obtain the consensus sequence. Can be also used with the **SAMtools Faidx** tool where the desired part of reference can be extracted and then provided  to this tool.\n\n\nUsing the **Sample** (`--sample`) (and, optionally, **Haplotype** (`--haplotype`) option will apply genotype (haplotype) calls from FORMAT/GT. \n```\n$bcftools consensus -s NA001 -f in.fa in.vcf.gz > out.fa\n```\n\nApply variants present in sample \"NA001\", output IUPAC codes using **Output in IUPAC** (`--iupac-codes`) option\n```\nbcftools consensus --iupac-codes -s NA001 -f in.fa in.vcf.gz > out.fa\n```\n\n### Changes Introduced by Seven Bridges\n\n* BCFtools works in all cases with gzipped and indexed VCF/BCF files. To be sure BCFtools works in all cases, we added subsequet `bgzip` and `index` commands if a VCF file is provided on input. If VCF.GZ is given on input only indexing will be done. Index file `.tbi` is added as secondary file of `in_variants` input which means if VCF.GZ is provided on input, tool will look for index file in project or previous tool (in case of usage in workflow) and if present, it will not perform nor compressing nor indexing.\n\n\n### Common Issues and Important Notes\n\n* By default, the program will apply all ALT variants to the reference FASTA to obtain the consensus sequence. \n\n * If the FASTA sequence does not match the REF allele at a given position, the tool will fail.\n\n### Performance Benchmarking\n\nIt took 5 minutes to execute this tool on AWS c4.2xlarge instance with a 56 KB VCF and a 3 GB reference FASTA file. The price is negligible ($0.02).\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n### References\n[1 - BCFtools page](https://samtools.github.io/bcftools/bcftools.html)",
              "label": "Bcftools Consensus",
              "arguments": [
                {
                  "prefix": "",
                  "shellQuote": false,
                  "position": 0,
                  "valueFrom": "${\n    var in_files_array = [].concat(inputs.in_variants);\n    var in_file = in_files_array[0];\n    var fname = in_file.basename;\n    var fname_ext = in_file.nameext;\n    var froot = in_file.nameroot;\n    if (fname_ext == '.gz') {\n        var index_tbi_file = fname + '.tbi';\n        var index_csi_file = fname + '.csi';\n        if (in_file.secondaryFiles[0]){\n        var secondary_given = in_file.secondaryFiles[0].path.replace(/^.*[\\\\\\/]/, '');}\n            if(secondary_given == index_tbi_file || secondary_given == index_csi_file){\n                return \"\";\n        }\n        else {\n            if(froot.split('.').pop() == 'bcf'){\n                return \"bcftools index  -f -c \" + froot + \".gz &&\";\n            }\n            else{\n            return \"bcftools index  -f -t \" + froot + \".gz &&\";}\n        }\n    } else {\n        if(fname.split('.').pop() == 'bcf'){\n            var index_csi_file = fname + '.csi';\n            if (in_file.secondaryFiles[0]){\n                var secondary_given = in_file.secondaryFiles[0].path.replace(/^.*[\\\\\\/]/, '');}\n                if(secondary_given == index_csi_file){\n                return \"\";}\n            else{\n                return \"bgzip -c -f \" + fname + \" > \" + fname + \".gz\" + \" && bcftools index -f -c \" + fname + \".gz &&\";}\n            }    \n        return \"bgzip -c -f \" + fname + \" > \" + fname + \".gz\" + \" && bcftools index -f -t \" + fname + \".gz &&\";\n\n    }\n}"
                },
                {
                  "shellQuote": false,
                  "position": 1,
                  "valueFrom": "bcftools"
                },
                {
                  "shellQuote": false,
                  "position": 2,
                  "valueFrom": "consensus"
                },
                {
                  "prefix": "--output",
                  "shellQuote": false,
                  "position": 6,
                  "valueFrom": "${\n    var in_files_array = [].concat(inputs.in_variants);\n    var in_file = in_files_array[0];\n    var fname = in_file.basename;\n    var fname_ext = in_file.nameext;\n    var froot = in_file.nameroot;\n    var out_name = '';\n    if (fname_ext == '.gz') {\n        if (froot.split('.').pop() == 'vcf'){\n            out_name = froot.split('.vcf')[0];}\n        else if (froot.split('.').pop() == 'bcf'){\n            out_name = froot.split('.bcf')[0];}\n    }\n    if(in_file.metadata.sample_id){\n        var froot = in_file.metadata.sample_id;}\n        \n    if (inputs.output_name) {\n        var out_name = inputs.output_name;}\n\n    else {\n        var out_name = froot;}\n\n        // return out_name\n    return out_name + \".fasta\"\n}"
                }
              ],
              "requirements": [
                {
                  "class": "ShellCommandRequirement"
                },
                {
                  "class": "ResourceRequirement",
                  "ramMin": "${\n    if (inputs.mem_per_job) {\n        return inputs.mem_per_job\n    } else {\n        return 1000\n    }\n}",
                  "coresMin": "${\n    if (inputs.cpu_per_job) {\n        return inputs.cpu_per_job\n    } else {\n        return 1\n    }\n}"
                },
                {
                  "class": "DockerRequirement",
                  "dockerPull": "images.sbgenomics.com/lea_lenhardt_ackovic/bcftools-1-13:0"
                },
                {
                  "class": "InitialWorkDirRequirement",
                  "listing": [
                    "$(inputs.in_variants)"
                  ]
                },
                {
                  "class": "InlineJavascriptRequirement",
                  "expressionLib": [
                    "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};",
                    "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
                  ]
                }
              ],
              "sbg:toolkitVersion": "1.13",
              "sbg:toolAuthor": "Petr Danecek, Shane McCarthy, John Marshall",
              "sbg:categories": [
                "VCF Processing"
              ],
              "sbg:links": [
                {
                  "id": "http://samtools.github.io/bcftools/",
                  "label": "Homepage"
                },
                {
                  "id": "https://github.com/samtools/bcftools",
                  "label": "Source code"
                },
                {
                  "id": "https://github.com/samtools/bcftools/wiki",
                  "label": "Wiki"
                },
                {
                  "id": "https://github.com/samtools/bcftools/archive/1.9.zip",
                  "label": "Download"
                }
              ],
              "sbg:cmdPreview": "bcftools index  -f -t input_file.vcf.gz && bcftools consensus --fasta-ref /path/to/reference.ext --output input_file.fa  input_file.vcf.gz",
              "sbg:toolkit": "bcftools",
              "sbg:image_url": null,
              "sbg:license": "MIT License",
              "sbg:projectName": "V-pipe tools - Demo",
              "sbg:revisionsInfo": [
                {
                  "sbg:revision": 0,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377553,
                  "sbg:revisionNotes": null
                },
                {
                  "sbg:revision": 1,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650377577,
                  "sbg:revisionNotes": "Latest version from dev."
                },
                {
                  "sbg:revision": 2,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650435220,
                  "sbg:revisionNotes": "JS edited."
                },
                {
                  "sbg:revision": 3,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650474833,
                  "sbg:revisionNotes": "Removed secondary file for reference."
                },
                {
                  "sbg:revision": 4,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1650517411,
                  "sbg:revisionNotes": "Added chain output."
                },
                {
                  "sbg:revision": 5,
                  "sbg:modifiedBy": "lea_lenhardt_ackovic",
                  "sbg:modifiedOn": 1651742034,
                  "sbg:revisionNotes": "Edited for cwltool."
                }
              ],
              "sbg:appVersion": [
                "v1.2"
              ],
              "sbg:id": "h-7334764f/h-907b70fc/h-13bea1c7/0",
              "sbg:revision": 5,
              "sbg:revisionNotes": "Edited for cwltool.",
              "sbg:modifiedOn": 1651742034,
              "sbg:modifiedBy": "lea_lenhardt_ackovic",
              "sbg:createdOn": 1650377553,
              "sbg:createdBy": "lea_lenhardt_ackovic",
              "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
              "sbg:sbgMaintained": false,
              "sbg:validationErrors": [],
              "sbg:contributors": [
                "lea_lenhardt_ackovic"
              ],
              "sbg:latestRevision": 5,
              "sbg:publisher": "sbg",
              "sbg:content_hash": "a3aaca3a34a5103b834d22ef6f5fb802c111885583f489f1499a0825d096a776f",
              "sbg:workflowLanguage": "CWL"
            },
            "label": "Bcftools Consensus Ambiguous",
            "sbg:x": 1573.451416015625,
            "sbg:y": 477.5196838378906
          }
        ],
        "requirements": [
          {
            "class": "InlineJavascriptRequirement"
          },
          {
            "class": "StepInputExpressionRequirement"
          }
        ],
        "sbg:projectName": "V-pipe tools - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650467052,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650467073,
            "sbg:revisionNotes": "Latest version from dev project."
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1650522039,
            "sbg:revisionNotes": "Added additional consensus tools and prepared inputs."
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651745722,
            "sbg:revisionNotes": "Edited for cwltool compatibility."
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651753050,
            "sbg:revisionNotes": "Updated extract_consensus"
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651753480,
            "sbg:revisionNotes": "File type changed for output."
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1653031331,
            "sbg:revisionNotes": "Updated tools with added pipe status check."
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1653032954,
            "sbg:revisionNotes": "Updated extract intervals"
          }
        ],
        "sbg:image_url": "https://igor.sbgenomics.com/ns/brood/images/lea_lenhardt_ackovic/v-pipe-tools-demo/v-pipe-basecount-consensus-sequence-snv-visualisation/7.png",
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "h-18ac7c6f/h-d1825fda/h-194e84b5/0",
        "sbg:revision": 7,
        "sbg:revisionNotes": "Updated extract intervals",
        "sbg:modifiedOn": 1653032954,
        "sbg:modifiedBy": "lea_lenhardt_ackovic",
        "sbg:createdOn": 1650467052,
        "sbg:createdBy": "lea_lenhardt_ackovic",
        "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "lea_lenhardt_ackovic"
        ],
        "sbg:latestRevision": 7,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a75bda7aea9a0108266fb44055e3c36dd18140967a4b41b05559581487668d3f9",
        "sbg:workflowLanguage": "CWL"
      },
      "label": "V-pipe Basecount/Consensus sequence/SNV/Visualisation ",
      "scatter": [
        "in_alignments"
      ],
      "sbg:x": 742.12841796875,
      "sbg:y": 191.49122619628906
    },
    {
      "id": "bwa_mem_bundle_0_7_17_cwl1_2",
      "in": [
        {
          "id": "reference_index_tar",
          "source": "reference_index_tar"
        },
        {
          "id": "input_reads",
          "source": [
            "sbg_pair_fastqs_by_metadata_1/tuple_list"
          ],
          "valueFrom": "$(self ? [].concat(self) : self)"
        },
        {
          "id": "minimum_seed_length",
          "source": "minimum_seed_length"
        },
        {
          "id": "dropoff",
          "source": "dropoff"
        },
        {
          "id": "select_seeds",
          "source": "select_seeds"
        },
        {
          "id": "seed_occurrence_for_the_3rd_round",
          "source": "seed_occurrence_for_the_3rd_round"
        },
        {
          "id": "skip_seeds",
          "source": "skip_seeds"
        },
        {
          "id": "drop_chains_fraction",
          "source": "drop_chains_fraction"
        },
        {
          "id": "discard_chain_length",
          "source": "discard_chain_length"
        },
        {
          "id": "mate_rescue_rounds",
          "source": "mate_rescue_rounds"
        },
        {
          "id": "skip_mate_rescue",
          "source": "skip_mate_rescue"
        },
        {
          "id": "skip_pairing",
          "source": "skip_pairing"
        },
        {
          "id": "discard_exact_matches",
          "source": "discard_exact_matches"
        },
        {
          "id": "score_for_a_sequence_match",
          "source": "score_for_a_sequence_match"
        },
        {
          "id": "mismatch_penalty",
          "source": "mismatch_penalty"
        },
        {
          "id": "smart_pairing_in_input_fastq",
          "source": "smart_pairing_in_input_fastq"
        },
        {
          "id": "insert_string_to_header",
          "source": "insert_string_to_header"
        },
        {
          "id": "ignore_alt_file",
          "source": "ignore_alt_file"
        },
        {
          "id": "minimum_output_score",
          "source": "minimum_output_score"
        },
        {
          "id": "output_alignments",
          "source": "output_alignments"
        },
        {
          "id": "append_comment",
          "source": "append_comment"
        },
        {
          "id": "output_header",
          "source": "output_header"
        },
        {
          "id": "use_soft_clipping",
          "source": "use_soft_clipping"
        },
        {
          "id": "mark_shorter",
          "source": "mark_shorter"
        },
        {
          "id": "gap_open_penalties",
          "source": [
            "gap_open_penalties"
          ]
        },
        {
          "id": "gap_extension_penalties",
          "source": [
            "gap_extension_penalties"
          ]
        },
        {
          "id": "clipping_penalty",
          "source": [
            "clipping_penalty"
          ]
        },
        {
          "id": "unpaired_read_penalty",
          "source": "unpaired_read_penalty"
        },
        {
          "id": "read_type",
          "source": "read_type"
        },
        {
          "id": "output_in_xa",
          "source": [
            "output_in_xa"
          ]
        },
        {
          "id": "speficy_distribution_parameters",
          "source": [
            "speficy_distribution_parameters"
          ]
        },
        {
          "id": "band_width",
          "source": "band_width"
        },
        {
          "id": "output_format",
          "default": "SAM"
        },
        {
          "id": "deduplication",
          "source": "deduplication"
        },
        {
          "id": "split_alignment_primary",
          "source": "split_alignment_primary"
        },
        {
          "id": "mapQ_of_suplementary",
          "source": "mapQ_of_suplementary"
        },
        {
          "id": "num_input_bases_in_each_batch",
          "source": "num_input_bases_in_each_batch"
        },
        {
          "id": "create_rg",
          "source": "create_rg"
        }
      ],
      "out": [
        {
          "id": "aligned_reads"
        },
        {
          "id": "dups_metrics"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.2",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "lea_lenhardt_ackovic/v-pipe-tools-demo/bwa-mem-bundle-0-7-17-cwl1-2/4",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Input files",
            "id": "reference_index_tar",
            "type": "File",
            "label": "Reference Index TAR",
            "doc": "Reference fasta file with its BWA index files packed in a TAR archive.",
            "sbg:fileTypes": "TAR"
          },
          {
            "sbg:category": "Input files",
            "id": "input_reads",
            "type": "File[]",
            "inputBinding": {
              "shellQuote": false,
              "position": 105,
              "valueFrom": "${\n    /// Set input reads in the correct order depending of the paired end from metadata\n\n    // Set output file name\n    function flatten(files){\n        var a = [];\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null;})\n        return b;}\n    var files1 = [].concat(inputs.input_reads);\n    var in_reads=flatten(files1);\n\n    // Read metadata for input reads\n    var read_metadata = in_reads[0].metadata;\n    if (!read_metadata) read_metadata = [];\n\n    var order = 0; // Consider this as normal order given at input: pe1 pe2\n\n    // Check if paired end 1 corresponds to the first given read\n    if (read_metadata == []) order = 0;\n    else if ('paired_end' in read_metadata) {\n        var pe1 = read_metadata.paired_end;\n        if (pe1 != 1) order = 1; // change order\n    }\n\n    // Return reads in the correct order\n    if (in_reads.length == 1) return in_reads[0].path; // Only one read present\n    else if (in_reads.length == 2) {\n        if (order == 0) return in_reads[0].path + ' ' + in_reads[1].path;\n        else return in_reads[1].path + ' ' + in_reads[0].path;\n    }\n}"
            },
            "label": "Input reads",
            "doc": "Input sequence reads.",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FQ, FQ.GZ"
          },
          {
            "sbg:category": "Input files",
            "id": "fasta_index",
            "type": "File?",
            "inputBinding": {
              "shellQuote": false,
              "position": 4,
              "valueFrom": "${\n    return \"\";\n}"
            },
            "label": "Fasta Index file for CRAM output",
            "doc": "Fasta index file is required for CRAM output when no PCR Deduplication is selected.",
            "sbg:fileTypes": "FAI",
            "secondaryFiles": [
              {
                "pattern": "$(inputs.fasta_index)",
                "required": true
              }
            ]
          },
          {
            "sbg:category": "Execution options",
            "sbg:toolDefaultValue": "8",
            "id": "threads",
            "type": "int?",
            "label": "Threads",
            "doc": "The number of threads for BWA and Biobambam2 sort processes (both will use the given number)."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "19",
            "id": "minimum_seed_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "-k",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum seed length",
            "doc": "Minimum seed length for BWA MEM."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "100",
            "id": "dropoff",
            "type": "int?",
            "inputBinding": {
              "prefix": "-d",
              "shellQuote": false,
              "position": 4
            },
            "label": "Dropoff",
            "doc": "Off-diagonal X-dropoff."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "1.5",
            "id": "select_seeds",
            "type": "float?",
            "inputBinding": {
              "prefix": "-r",
              "shellQuote": false,
              "position": 4
            },
            "label": "Select seeds",
            "doc": "Look for internal seeds inside a seed longer than {-k} * FLOAT."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "20",
            "id": "seed_occurrence_for_the_3rd_round",
            "type": "int?",
            "inputBinding": {
              "prefix": "-y",
              "shellQuote": false,
              "position": 4
            },
            "label": "Seed occurrence",
            "doc": "Seed occurrence for the 3rd round seeding."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "500",
            "id": "skip_seeds",
            "type": "int?",
            "inputBinding": {
              "prefix": "-c",
              "shellQuote": false,
              "position": 4
            },
            "label": "Skip seeds",
            "doc": "Skip seeds with more than a given number (INT) of occurrences."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "0.50",
            "id": "drop_chains_fraction",
            "type": "float?",
            "inputBinding": {
              "prefix": "-D",
              "shellQuote": false,
              "position": 4
            },
            "label": "Drop chains fraction",
            "doc": "Drop chains shorter than a given fraction (FLOAT) of the longest overlapping chain."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "0",
            "id": "discard_chain_length",
            "type": "int?",
            "inputBinding": {
              "prefix": "-W",
              "shellQuote": false,
              "position": 4
            },
            "label": "Discard chain length",
            "doc": "Discard a chain if seeded bases are shorter than a given number (INT)."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "50",
            "id": "mate_rescue_rounds",
            "type": "string?",
            "inputBinding": {
              "prefix": "-m",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mate rescue rounds",
            "doc": "Perform at the most a given number (INT) of rounds of mate rescues for each read."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "id": "skip_mate_rescue",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-S",
              "shellQuote": false,
              "position": 4
            },
            "label": "Skip mate rescue",
            "doc": "Skip mate rescue."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "id": "skip_pairing",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-P",
              "shellQuote": false,
              "position": 4
            },
            "label": "Skip pairing",
            "doc": "Skip pairing; mate rescue is performed unless -S also in use."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "id": "discard_exact_matches",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-e",
              "shellQuote": false,
              "position": 4
            },
            "label": "Discard exact matches",
            "doc": "Discard full-length exact matches."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "1",
            "id": "score_for_a_sequence_match",
            "type": "int?",
            "inputBinding": {
              "prefix": "-A",
              "shellQuote": false,
              "position": 4
            },
            "label": "Score for a sequence match",
            "doc": "Score for a sequence match, which scales options -TdBOELU unless overridden."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "4",
            "id": "mismatch_penalty",
            "type": "int?",
            "inputBinding": {
              "prefix": "-B",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mismatch penalty",
            "doc": "Penalty for a mismatch."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "smart_pairing_in_input_fastq",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-p",
              "shellQuote": false,
              "position": 4
            },
            "label": "Smart pairing",
            "doc": "Smart pairing in input FASTQ file (ignoring in2.fq)."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Constructed from per-attribute parameters or inferred from metadata.",
            "id": "read_group_header",
            "type": "string?",
            "label": "Read group header",
            "doc": "Read group header line such as '@RG\\tID:foo\\tSM:bar'.  This value takes precedence over per-attribute parameters."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "insert_string_to_header",
            "type": "string?",
            "inputBinding": {
              "prefix": "-H",
              "shellQuote": false,
              "position": 4
            },
            "label": "Insert string to header",
            "doc": "Insert STR to output header if it starts with \"@\"."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "ignore_alt_file",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-j",
              "shellQuote": false,
              "position": 4
            },
            "label": "Ignore ALT file",
            "doc": "Treat ALT contigs as part of the primary assembly (i.e. ignore <idxbase>.alt file)."
          },
          {
            "sbg:category": "BWA Input/output options",
            "sbg:toolDefaultValue": "3",
            "id": "verbose_level",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "1",
                  "2",
                  "3",
                  "4"
                ],
                "name": "verbose_level"
              }
            ],
            "inputBinding": {
              "prefix": "-v",
              "shellQuote": false,
              "position": 4
            },
            "label": "Verbose level",
            "doc": "Select verbose level: 1=error, 2=warning, 3=message, 4+=debugging."
          },
          {
            "sbg:category": "BWA Input/output options",
            "sbg:toolDefaultValue": "30",
            "id": "minimum_output_score",
            "type": "int?",
            "inputBinding": {
              "prefix": "-T",
              "shellQuote": false,
              "position": 4
            },
            "label": "Minimum alignment score",
            "doc": "Minimum alignment score for a read to be outputted in SAM/BAM/CRAM."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "output_alignments",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-a",
              "shellQuote": false,
              "position": 4
            },
            "label": "Output alignments",
            "doc": "Output all alignments for SE or unpaired PE."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "append_comment",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-C",
              "shellQuote": false,
              "position": 4
            },
            "label": "Append comment",
            "doc": "Append FASTA/FASTQ comment to the output file."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "output_header",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-V",
              "shellQuote": false,
              "position": 4
            },
            "label": "Output header",
            "doc": "Output the reference FASTA header in the XR tag."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "use_soft_clipping",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-Y",
              "shellQuote": false,
              "position": 4
            },
            "label": "Use soft clipping",
            "doc": "Use soft clipping for supplementary alignments."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "mark_shorter",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-M",
              "shellQuote": false,
              "position": 4
            },
            "label": "Mark shorter",
            "doc": "Mark shorter split hits as secondary."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "[6,6]",
            "id": "gap_open_penalties",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-O",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gap open penalties",
            "doc": "Gap open penalties for deletions and insertions. \nThis array can't have more than two values."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "[1,1]",
            "id": "gap_extension_penalties",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-E",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Gap extension",
            "doc": "Gap extension penalty; a gap of size k cost '{-O} + {-E}*k'. \nThis array can't have more than two values."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "[5,5]",
            "id": "clipping_penalty",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-L",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Clipping penalty",
            "doc": "Penalty for 5'- and 3'-end clipping."
          },
          {
            "sbg:category": "BWA Scoring options",
            "sbg:toolDefaultValue": "17",
            "id": "unpaired_read_penalty",
            "type": "int?",
            "inputBinding": {
              "prefix": "-U",
              "shellQuote": false,
              "position": 4
            },
            "label": "Unpaired read penalty",
            "doc": "Penalty for an unpaired read pair."
          },
          {
            "sbg:category": "BWA Scoring options",
            "id": "read_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "pacbio",
                  "ont2d",
                  "intractg"
                ],
                "name": "read_type"
              }
            ],
            "inputBinding": {
              "prefix": "-x",
              "shellQuote": false,
              "position": 4
            },
            "label": "Sequencing technology-specific settings",
            "doc": "Sequencing technology-specific settings; Setting -x changes multiple parameters unless overridden. \npacbio: -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0  (PacBio reads to ref). \nont2d: -k14 -W20 -r10 -A1 -B1 -O1 -E1 -L0  (Oxford Nanopore 2D-reads to ref).\nintractg: -B9 -O16 -L5  (intra-species contigs to ref)."
          },
          {
            "sbg:category": "BWA Input/output options",
            "sbg:toolDefaultValue": "[5, 200]",
            "id": "output_in_xa",
            "type": "int[]?",
            "inputBinding": {
              "prefix": "-h",
              "separate": false,
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Output in XA",
            "doc": "If there are < number (INT) of hits with a score >80% of the max score, output all in XA. \nThis array should have no more than two values."
          },
          {
            "sbg:category": "BWA Input/output options",
            "id": "speficy_distribution_parameters",
            "type": "float[]?",
            "inputBinding": {
              "prefix": "-I",
              "itemSeparator": ",",
              "shellQuote": false,
              "position": 4
            },
            "label": "Specify distribution parameters",
            "doc": "Specify the mean, standard deviation (10% of the mean if absent), max (4 sigma from the mean if absent), and min of the insert size distribution. \nFR orientation only. \nThis array can have maximum of four values, where the first two should be specified as FLOAT and the last two as INT."
          },
          {
            "sbg:category": "BWA Algorithm options",
            "sbg:toolDefaultValue": "100",
            "id": "band_width",
            "type": "int?",
            "inputBinding": {
              "prefix": "-w",
              "shellQuote": false,
              "position": 4
            },
            "label": "Band width",
            "doc": "Band width for banded alignment."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata or set to default (\"Illumina\")",
            "id": "rg_platform",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "454",
                  "Helicos",
                  "Illumina",
                  "Solid",
                  "IonTorrent"
                ],
                "name": "rg_platform"
              }
            ],
            "label": "Platform",
            "doc": "Specify the version of the technology that was used for sequencing, which will be placed in RG line."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata, input name or set to default",
            "id": "rg_sample_id",
            "type": "string?",
            "label": "Sample ID",
            "doc": "Specify the sample ID for RG line - A human readable identifier for a sample or specimen, which could contain some metadata information. A sample or specimen is material taken from a biological entity for testing, diagnosis, propagation, treatment, or research purposes, including but not limited to tissues, body fluids, cells, organs, embryos, body excretory products, etc."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_library_id",
            "type": "string?",
            "label": "Library ID",
            "doc": "Specify the identifier for the sequencing library preparation, which will be placed in RG line."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_platform_unit_id",
            "type": "string?",
            "label": "Platform unit ID",
            "doc": "Specify the platform unit (lane/slide) for RG line - An identifier for lanes (Illumina), or for slides (SOLiD) in the case that a library was split and ran over multiple lanes on the flow cell or slides."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "id": "rg_data_submitting_center",
            "type": "string?",
            "label": "Data submitting center",
            "doc": "Specify the data submitting center for RG line."
          },
          {
            "sbg:category": "BWA Read Group Options",
            "id": "rg_median_fragment_length",
            "type": "string?",
            "label": "Median fragment length",
            "doc": "Specify the median fragment length for RG line."
          },
          {
            "sbg:category": "Execution options",
            "sbg:toolDefaultValue": "BAM",
            "id": "output_format",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "SAM",
                  "BAM",
                  "CRAM",
                  "Queryname Sorted BAM",
                  "Queryname Sorted SAM"
                ],
                "name": "output_format"
              }
            ],
            "label": "Output format",
            "doc": "Coordinate sorted BAM file (option BAM) is the default output."
          },
          {
            "sbg:category": "Execution options",
            "id": "sort_memory",
            "type": "int?",
            "label": "Memory for BAM sorting",
            "doc": "Amount of RAM [Gb] to give to the sorting algorithm (if not provided will be set to one-third of the total memory)."
          },
          {
            "sbg:category": "Biobambam2 parameters",
            "sbg:toolDefaultValue": "None",
            "id": "deduplication",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "None",
                  "MarkDuplicates",
                  "RemoveDuplicates"
                ],
                "name": "deduplication"
              }
            ],
            "label": "PCR duplicate detection",
            "doc": "Use Biobambam2 for finding duplicates on sequence reads."
          },
          {
            "sbg:category": "Execution options",
            "sbg:toolDefaultValue": "15",
            "id": "total_memory",
            "type": "int?",
            "label": "Total memory",
            "doc": "Total memory to be used by the tool in GB. It's the sum of BWA and BIOBAMBAM2 processes. For FASTQ files of a total size less than 10GB, we suggest using the default setting of 15GB, for larger files, we suggest using 58GB of memory (and 32CPU cores)."
          },
          {
            "sbg:category": "Configuration",
            "id": "output_name",
            "type": "string?",
            "label": "Output alignements file name",
            "doc": "Name for the output alignments (SAM, BAM, or CRAM) file."
          },
          {
            "sbg:category": "Configuration",
            "sbg:toolDefaultValue": "1",
            "id": "reserved_threads",
            "type": "int?",
            "label": "Reserved number of threads on the instance",
            "doc": "Reserved number of threads on the instance used by scheduler."
          },
          {
            "sbg:category": "Configuration",
            "sbg:toolDefaultValue": "1",
            "id": "rg_id",
            "type": "string?",
            "label": "Read group ID",
            "doc": "Set read group ID."
          },
          {
            "sbg:category": "Execution options",
            "sbg:toolDefaultValue": "False",
            "id": "wgs_hg38_mode_threads",
            "type": "int?",
            "label": "Optimize threads for HG38",
            "doc": "Lower the number of threads if HG38 reference genome is used."
          },
          {
            "id": "split_alignment_primary",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-5",
              "shellQuote": false,
              "position": 4
            },
            "label": "Split alignment - smallest coordinate as primary",
            "doc": "For split alignment, take the alignment with the smallest coordinate as primary."
          },
          {
            "id": "mapQ_of_suplementary",
            "type": "boolean?",
            "inputBinding": {
              "prefix": "-q",
              "shellQuote": false,
              "position": 4
            },
            "label": "Don't modify mapQ",
            "doc": "Don't modify mapQ of supplementary alignments."
          },
          {
            "id": "num_input_bases_in_each_batch",
            "type": "int?",
            "inputBinding": {
              "prefix": "-K",
              "shellQuote": false,
              "position": 4
            },
            "label": "Number of input bases to process",
            "doc": "Process a given number (INT) of input bases in each batch regardless of nThreads (for reproducibility)."
          },
          {
            "sbg:category": "Config Inputs",
            "id": "create_rg",
            "type": "boolean?",
            "label": "Create RG from file metadata",
            "doc": "If set to True, the RG string will be created from values pulled from file metadata."
          }
        ],
        "outputs": [
          {
            "id": "aligned_reads",
            "doc": "Output SAM/BAM/CRAM file containing aligned reads.",
            "label": "Output alignments",
            "type": "File?",
            "outputBinding": {
              "glob": "${ \n    return [\"*.sam\", \"*.bam\", \"*.cram\"] \n}",
              "outputEval": "${  \n    /// Set metadata from input parameters, metadata or default value\n\n    function flatten(files){\n        var a = []\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null});\n        return b;\n    }\n    function sharedStart(array){\n        var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n        while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n        return a1.substring(0, i);\n    }\n    /// Key-setting functions\n    // Reference genome \n    var add_metadata_key_reference_genome = function(self, inputs) {\n        var reference_file = inputs.reference_index_tar.basename;\n        var ref_list = reference_file.split('.');\n        var  a = '';\n        var ref_gen='';\n        if (reference_file.includes(\".bwa-0.7.17-index-archive.tar\")){\n            a = ref_list.pop();\n            a = ref_list.pop();\n            a = ref_list.pop();\n            a = ref_list.pop(); // strip '.bwa-0.7.17-index-archive.tar'\n        }else{\n            a = ref_list.pop();\n            a = ref_list.pop(); // strip '.tar'\n        } \n        if (read_metadata.reference_genome) {\n            ref_gen = read_metadata.reference_genome;\n        }else {ref_gen=ref_list.join('.');}\n        return ref_gen\n    };\n    // Platform \n    var add_metadata_key_platform = function(self, inputs) {\n        /// Set platform from input parameters/input metadata/default value\n        var platform = '';\n        var pl = '';\n        // Find PL from header\n        if (inputs.read_group_header){\n            var header = inputs.read_group_header;\n            header = header.split(\"'\").join(\"\") //remove single quotes\n            var a = header.split('\\\\t');\n            for (var i = 0; i < a.length; i++){ //find PL field\n                if (a[i].includes(\"PL:\")) pl= a[i];\n                else;\n            }}\n        else;\n        \n        if (pl) platform = pl.split(':')[1];\n        else if (inputs.rg_platform) platform = inputs.rg_platform;\n        else if (read_metadata.platform) platform = read_metadata.platform;\n        else platform = 'Illumina';\n        \n        return platform\n    };\n    // Sample ID \n    var add_metadata_key_sample_id = function(self, inputs) {\n        /// Set sample ID from input parameters/input metadata/default value from input reads file names\n        var sample_id = '';\n        var sm = '';\n        // Find SM from header\n        if (inputs.read_group_header){\n            var header = inputs.read_group_header;\n            header = header.split(\"'\").join(\"\") //remove single quotes\n            var a = header.split('\\\\t');\n            for (var i = 0; i < a.length; i++){ //find SM field\n                if (a[i].includes(\"SM:\")) var sm= a[i];\n                else;\n            }}\n        else;\n        \n        if (sm) sample_id = sm.split(':')[1];\n        else if (inputs.rg_sample_id) sample_id = inputs.rg_sample_id;\n        else if (read_metadata.sample_id) sample_id = read_metadata.sample_id;\n        else {\n            var read_names = [];\n            var files1 = [].concat(inputs.input_reads);\n            var files=flatten(files1);\n            \n            for (var i=0;i<files.length;i++) {\n                var file_ext=files[i].nameext;\n                var file_base=files[i].basename;\n                \n                if (file_ext === '.gz' || file_ext === '.GZ')\n                    file_base = file_base.slice(0, -3);\n                    file_ext= '.'+ file_base.split('.').pop();\n                if (file_ext === '.fq' || file_ext === '.FQ')\n                    file_base = file_base.slice(0, -3);\n                if (file_ext === '.fastq' || file_ext === '.FASTQ')\n                    file_base = file_base.slice(0, -6);\n                \n                read_names.push(file_base.replace(/pe1|pe2|pe\\.1|pe\\.2|pe\\_1|pe\\_2|\\_pe1|\\_pe2|\\_pe\\.1|\\_pe\\.2|\\_pe\\_1|\\_pe\\_2|\\.pe1|\\.pe2|\\.pe\\.1|\\.pe\\.2|\\.pe\\_1|\\.pe\\_2/,''));\n              }\n              ////strip out any trailing dashes/dots/underscores...\n              var unique_prefix = sharedStart(read_names).replace( /\\-$|\\_$|\\.$/, '');\n              var tmp_prefix = unique_prefix.replace( /^\\_|\\.pe$|\\.R$|\\_pe$|\\_R$/,'');\n              var final_prefix = tmp_prefix.replace( /^_\\d(\\d)?_/, '' );\n              \n              var fname=final_prefix;\n            sample_id = fname;\n        }\n        return sample_id\n    };\n    \n   \n    var files1 = [].concat(inputs.input_reads);\n    var files=flatten(files1);\n    var read_metadata = files[0].metadata;\n    if (!read_metadata) read_metadata = [];\n    \n    self = inheritMetadata(self, files);\n\n    for (var i = 0; i < self.length; i++) {\n        var out_metadata = {\n            'reference_genome': add_metadata_key_reference_genome(self[i], inputs),\n            'platform': add_metadata_key_platform(self[i], inputs),\n            'sample_id': add_metadata_key_sample_id(self[i], inputs)\n        };\n        self[i] = setMetadata(self[i], out_metadata);\n    }\n\n    return self;\n\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              },
              {
                "pattern": "^.bai",
                "required": false
              },
              {
                "pattern": ".crai",
                "required": false
              },
              {
                "pattern": "^.crai",
                "required": false
              }
            ],
            "sbg:fileTypes": "SAM, BAM, CRAM"
          },
          {
            "id": "dups_metrics",
            "doc": "Metrics file for Biobambam2 Mark Duplicates.",
            "label": "Sormadup metrics",
            "type": "File?",
            "outputBinding": {
              "glob": "*.sormadup_metrics.log"
            },
            "sbg:fileTypes": "LOG"
          }
        ],
        "doc": "BWA-MEM is an algorithm designed for aligning sequence reads onto a large reference genome. BWA-MEM is implemented as a component of BWA. The algorithm can automatically choose between performing end-to-end and local alignments. BWA-MEM is capable of outputting multiple alignments, and finding chimeric reads. It can be applied to a wide range of read lengths, from 70 bp to several megabases. \n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n\n## Common Use Cases\nIn order to obtain possibilities for additional fast processing of aligned reads, the **Biobambam2 sortmadup** (2.0.87) tool is embedded together into the same package with BWA-MEM (0.7.17).\n\nIn order to obtain possibilities for additional fast processing of aligned reads, **Biobambam2** (2.0.87) is embedded together with the BWA 0.7.17 toolkit into the **BWA-MEM Bundle 0.7.17 CWL1.0**.  Two tools are used (**bamsort** and **bamsormadup**) to allow the selection of three output formats (SAM, BAM, or CRAM), different modes of sorting (Quarryname/Coordinate sorting), and Marking/Removing duplicates that can arise during sample preparation e.g. library construction using PCR. This is done by setting the **Output format** and **PCR duplicate detection** parameters.\n- Additional notes:\n    - The default **Output format** is coordinate sorted BAM (option **BAM**).\n    - SAM and BAM options are query name sorted, while CRAM format is not advisable for data sorted by query name.\n    - Coordinate Sorted BAM file in all options and CRAM Coordinate sorted output with Marked Duplicates come with the accompanying index file. The generated index name will be the same as the output alignments file, with the extension BAM.BAI or CRAM.CRAI. However, when selecting the CRAM Coordinate sorted and CRAM Coordinate sorted output with Removed Duplicates, the generated files will not have the index file generated. This is a result of the usage of different Biobambam2 tools - **bamsort** does not have the ability to write CRAI files (only supports outputting BAI index files), while **bamsormadup** can write CRAI files.\n    - Passing data from BWA-MEM to Biobambam2 tools has been done through  Linux piping which saves processing times (up to an hour of the execution time for a whole-genome sample) of reading and writing of aligned reads into the hard drive. \n    - **BWA-MEM Bundle 0.7.17 CWL1** first needs to construct the FM-index  (Full-text index in Minute space) for the reference genome using the **BWA INDEX 0.7.17 CWL1.0** tool. The two BWA versions are compatible.\n\n### Changes Introduced by Seven Bridges\n\n- **Aligned SAM/BAM/CRAM** file will be prefixed using the **Output SAM/BAM/CRAM file name** parameter. In case **Output SAM/BAM/CRAM file name** is not provided, the output prefix will be the same as the **Sample ID** metadata field from the file if the **Sample ID** metadata field exists. Otherwise, the output prefix will be inferred from the **Input reads** file names.\n-  The **Platform** metadata field for the output alignments will be automatically set to \"Illumina\" unless it is present in **Input reads** metadata, or given through **Read group header** or **Platform** input parameters. This will prevent possible errors in downstream analysis using the GATK toolkit.\n- If the **Read group ID** parameter is not defined, by default it will be set to \u20181\u2019. If the tool is scattered within a workflow it will assign the **Read Group ID** according to the order of the scattered folders. This ensures a unique **Read Group ID** when processing multi-read group input data from one sample.\n\n### Common Issues and Important Notes \n \n- For input reads FASTQ files of total size less than 10 GB we suggest using the default setting of of 15GB for the parameter **Total memory**, for larger files we suggest using 58 GB of memory and 32 CPU cores.\n- When the desired output is a CRAM file without deduplication of PCR duplicates, it is necessary to provide the FASTA Index file (FAI) as input.\n- Human reference genome version 38 comes with ALT contigs, a collection of diverged alleles present in some humans but not the others. Making effective use of these contigs will help reduce mapping artifacts, however, to facilitate mapping these ALT contigs to the primary assembly, GRC decided to add to each contig long flanking sequences almost identical to the primary assembly. As a result, a naive mapping against GRCh38+ALT will lead to many mapQ-zero mappings in these flanking regions. Please use post-processing steps to fix these alignments or implement [steps](https://sourceforge.net/p/bio-bwa/mailman/message/32845712/) described by the author of the BWA toolkit.  \n- Inputs **Read group header** and **Insert string to header** need to be given in the correct format - under single-quotes.\n- BWA-MEM is not a splice aware aligner, so it is not the appropriate tool for mapping RNAseq to the genome. For RNAseq reads **Bowtie2 Aligner** and **STAR** are recommended tools. \n- Input paired reads need to have the identical read names - if not, the tool will throw a ``[mem_sam_pe] paired reads have different names`` error.\n- This wrapper was tested and is fully compatible with cwltool v3.0.\n\n### Performance Benchmarking\n\nBelow is a table describing the runtimes and task costs on on-demand instances for a set of samples with different file sizes :\n\n| Input reads       | Size [GB] | Output format | Instance (AWS)           | Duration  | Cost   | Threads |\n|-------------------|-----------|---------------|--------------------------|-----------|--------|---------|\n| HG001-NA12878-30x | 2 x 23.8  | SAM           | c5.9xlarge (36CPU, 72GB) | 5h 12min  | $7.82  | 36      |\n| HG001-NA12878-30x | 2 x 23.8  | BAM           | c5.9xlarge (36CPU, 72GB) | 5h 16min  | $8.06  | 36      |\n| HG002-NA24385-50x | 2 x 66.4  | SAM           | c5.9xlarge (36CPU, 72GB) | 8h 33min  | $13.08 | 36      |\n\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*",
        "label": "BWA MEM Bundle 0.7.17 CWL1.2",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": -1,
            "valueFrom": "${\n    /// Check number of input FASTQ files ///\n    \n    function flatten(files){\n    var a = []\n    for(var i=0;i<files.length;i++){\n        if(files[i]){\n            if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n            else a = a.concat(files[i])}}\n        var b = a.filter(function (el) {return el != null})\n        return b\n    }\n    \n    var files1 = [].concat(inputs.input_reads);\n    var in_reads=flatten(files1);\n    \n    if ( in_reads.length > 2 ) return 'ERROR: Number of input FASTQ files needs to be one (if single-end/interleaved file) or two (if paired-end files)';\n    else return '';\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd = \"/bin/bash -c \\\"\";\n    return cmd + \" export REF_CACHE=${PWD} && \";\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    /// Unpack Reference TAR archive ///\n    \n    var in_index=[].concat(inputs.reference_index_tar)[0];\n    var reference_file = in_index.basename;\n    return 'tar -tvf ' + reference_file + ' 1>&2 && tar -xf ' + reference_file + ' && ';\n    \n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 2,
            "valueFrom": "bwa mem"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "${\n    /// Set RG header ///\n\n    function add_param(key, val) {\n        if (!val) return;\n        param_list.push(key + ':' + val);}\n        \n    function flatten(files){\n        var a = [];\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null;});\n        return b;}\n        \n    function sharedStart(array){\n        var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n        while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n        return a1.substring(0, i);}\n\n    \n    /// If it exists - return input read group header from input parameter\n    if (inputs.read_group_header) return '-R ' + inputs.read_group_header;\n\n    // Flatten input reads\n    var in_reads1 = [].concat(inputs.input_reads);\n    var in_reads = flatten(in_reads1)\n    var input_1=in_reads[0];\n\n    var param_list = [];\n    //Read metadata for input reads\n    var read_metadata = input_1.metadata;\n    if (!read_metadata) read_metadata = [];\n\n    // Set CN\n    if (inputs.rg_data_submitting_center) add_param('CN', inputs.rg_data_submitting_center);\n    else if ('data_submitting_center' in read_metadata) add_param('CN', read_metadata.data_submitting_center);\n    else;\n\n    // Set LB\n    if (inputs.rg_library_id) add_param('LB', inputs.rg_library_id);\n    else if ('library_id' in read_metadata) add_param('LB', read_metadata.library_id);\n    else;\n\n    // Set PI\n    if (inputs.rg_median_fragment_length) add_param('PI', inputs.rg_median_fragment_length);\n    else;\n\n    // Set PL (default Illumina)\n    var rg_platform = '';\n    if (inputs.rg_platform) add_param('PL', inputs.rg_platform);\n    else if ('platform' in read_metadata) {\n        if (read_metadata.platform == 'HiSeq X Ten') rg_platform = 'Illumina';\n        else rg_platform = read_metadata.platform;\n        add_param('PL', rg_platform);}\n    else add_param('PL', 'Illumina');\n\n    // Set PU\n    if (inputs.rg_platform_unit_id) add_param('PU', inputs.rg_platform_unit_id);\n    else if ('platform_unit_id' in read_metadata) add_param('PU', read_metadata.platform_unit_id);\n    else;\n    \n    // Set RG_ID\n    var folder = input_1.path.split('/').slice(-2,-1).toString();\n    var suffix = \"_s\";\n    var rg='';\n    //if RG ID set by user \n    if (inputs.rg_id) add_param('ID', inputs.rg_id);\n    //If BWA or sub wf containing is scattered\n    else if(folder.indexOf(suffix) !==-1){\n        if(folder.indexOf(suffix, folder.length - suffix.length) !== -1){\n            for(var i=0; i<folder.length; i++){\n                if(folder[i]=='_' && folder[i+1]=='s' && folder[i+2]=='_') rg+=folder[i-1];\n                else rg+='';\n                \n            }\n            rg+=folder.split(\"_\").slice(-2)[0];\n        }\n        else{\n            for(var i=0; i<folder.length; i++){\n                if(folder[i]=='_' && folder[i+1]=='s' && folder[i+2]=='_') rg+=folder[i-1];\n                else rg+='';\n                \n            }\n            \n        }\n        //remove all non-int chars \n        rg=rg.replace(/\\D/g,'')\n        if (rg) add_param('ID', rg);\n        else add_param('ID', 1);\n        \n    }// If no other conditions add ID 1\n    else  add_param('ID', 1);\n\n    // Set SM from input/metadata/filename\n    if (inputs.rg_sample_id) add_param('SM', inputs.rg_sample_id);\n    else if ('sample_id' in read_metadata) add_param('SM', read_metadata.sample_id);\n    else {\n        var read_names = [];\n        for (var i=0;i<in_reads.length;i++) {\n            var file_ext=in_reads[i].nameext;\n            var file_base=in_reads[i].basename;\n            \n            if (file_ext === '.gz' || file_ext === '.GZ')\n                file_base = file_base.slice(0, -3);\n                file_ext= '.'+ file_base.split('.').pop();\n            if (file_ext === '.fq' || file_ext === '.FQ')\n                file_base = file_base.slice(0, -3);\n            if (file_ext === '.fastq' || file_ext === '.FASTQ')\n                file_base = file_base.slice(0, -6);\n            \n            read_names.push(file_base.replace(/pe1|pe2|pe\\.1|pe\\.2|pe\\_1|pe\\_2|\\_pe1|\\_pe2|\\_pe\\.1|\\_pe\\.2|\\_pe\\_1|\\_pe\\_2|\\.pe1|\\.pe2|\\.pe\\.1|\\.pe\\.2|\\.pe\\_1|\\.pe\\_2/,''));}\n          \n        ////strip out any trailing dashes/dots/underscores...\n        var unique_prefix = sharedStart(read_names).replace( /\\-$|\\_$|\\.$/, '');\n        var tmp_prefix = unique_prefix.replace( /^\\_|\\.pe$|\\.R$|\\_pe$|\\_R$/,'');\n        var final_prefix = tmp_prefix.replace( /^_\\d(\\d)?_/, '' );\n      \n        var sample_id=final_prefix;\n        add_param('SM', sample_id);\n    };\n    \n    if (inputs.create_rg){\n    // Create RG header\n        return \"-R '@RG\\\\t\" + param_list.join('\\\\t') + \"'\";\n    }\n    else {\n        return ''\n    }\n\n}"
          },
          {
            "prefix": "-t",
            "shellQuote": false,
            "position": 6,
            "valueFrom": "${\n    /// Set BWA2 threads ///\n\n    var  MAX_THREADS = 36;\n    var  suggested_threads = 8;\n    var threads  = 0;\n  \n    if (inputs.threads) threads = inputs.threads;\n    else if (inputs.wgs_hg38_mode_threads) {\n        var ref_name = inputs.reference_index_tar.basename;\n        if (ref_name.search('38') >= 0) threads = inputs.wgs_hg38_mode_threads;\n        else threads = MAX_THREADS;\n    } else threads = suggested_threads;\n    \n    return threads;\n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 14,
            "valueFrom": "${\n    /// Extract common prefix for Index files ///\n    \n    var reference_tar = [].concat(inputs.reference_index_tar)[0];\n    \n    var prefix = \"$(tar -tf \" + reference_tar.basename + \" --wildcards '*.bwt' | rev | cut -c 5- | rev)\";\n    return prefix;\n\n}"
          },
          {
            "prefix": "",
            "separate": false,
            "shellQuote": false,
            "position": 116,
            "valueFrom": "${\n    ///  BIOBAMBAM2  ///\n      \n     // Get shared start and flatten input reads\n    function sharedStart(array){\n        var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n        while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n        return a1.substring(0, i);\n    }\n    function flatten(files){\n        var a = [];\n        for(var i=0;i<files.length;i++){\n            if(files[i]){\n                if(files[i].constructor == Array) a = a.concat(flatten(files[i]));\n                else a = a.concat(files[i]);}}\n        var b = a.filter(function (el) {return el != null;});\n        return b;}\n   \n    var input_reads = [].concat(inputs.input_reads);\n    var files=flatten(input_reads);\n\n    // Set output file name\n    var fname = '';\n    \n    /// from given prefix\n    if (inputs.output_name) fname = inputs.output_name;\n    /// from sample_id metadata\n    else if (files[0].metadata && files[0].metadata['sample_id']) fname=files[0].metadata['sample_id'];\n    /// from common prefix, and strip out any unnecessary characters\n    else {\n        var read_names = [];\n        for (var i=0;i<files.length;i++) {\n            var file_ext=files[i].nameext;\n            var file_base=files[i].basename;\n            \n            if (file_ext === '.gz' || file_ext === '.GZ')\n                file_base = file_base.slice(0, -3);\n                file_ext= '.'+ file_base.split('.').pop();\n            if (file_ext === '.fq' || file_ext === '.FQ')\n                file_base = file_base.slice(0, -3);\n            if (file_ext === '.fastq' || file_ext === '.FASTQ')\n                file_base = file_base.slice(0, -6);\n            \n            read_names.push(file_base.replace(/pe1|pe2|pe\\.1|pe\\.2|pe\\_1|pe\\_2|\\_pe1|\\_pe2|\\_pe\\.1|\\_pe\\.2|\\_pe\\_1|\\_pe\\_2|\\.pe1|\\.pe2|\\.pe\\.1|\\.pe\\.2|\\.pe\\_1|\\.pe\\_2/,''));\n              \n          }\n          ////strip out any trailing dashes/dots/underscores...\n          var unique_prefix = sharedStart(read_names).replace( /\\-$|\\_$|\\.$/, '');\n          var tmp_prefix = unique_prefix.replace( /^\\_|\\.pe$|\\.R$|\\_pe$|\\_R$/,'');\n          var final_prefix = tmp_prefix.replace( /^_\\d(\\d)?_/, '' );\n          \n          fname=final_prefix;}\n\n\n    // Read number of threads if defined\n    var threads = 0;\n    var MAX_THREADS = 0;\n    var ref_name = '';\n    if (inputs.threads) threads = inputs.threads;\n    else if (inputs.wgs_hg38_mode_threads) {\n        MAX_THREADS = 36;\n        ref_name = inputs.reference_index_tar.basename;\n        if (ref_name.search('38') >= 0) threads = inputs.wgs_hg38_mode_threads;\n        else threads = MAX_THREADS;\n        } \n    else threads = 8;\n\n    var tool = '';\n    var dedup = '';\n    if (inputs.deduplication == \"MarkDuplicates\") {\n        tool = 'bamsormadup';\n        dedup = ' markduplicates=1';\n    } else {\n        if (inputs.output_format == 'CRAM') tool = 'bamsort index=0';\n        else tool = 'bamsort index=1';\n        if (inputs.deduplication == \"RemoveDuplicates\") dedup = ' rmdup=1';\n        else dedup = '';\n    }\n    var sort_path = tool + dedup;\n\n    var indexfilename = '';\n    var out_format = '';\n    var extension  = '';\n    // Coordinate Sorted BAM is default\n    if (inputs.output_format == 'CRAM') {\n        out_format = ' outputformat=cram SO=coordinate';\n        ref_name = inputs.reference_index_tar.basename.split('.tar')[0];\n        out_format += ' reference=' + ref_name;\n        if (sort_path != 'bamsort index=0') indexfilename = ' indexfilename=' + fname + '.cram.crai';\n        extension = '.cram';\n    } else if (inputs.output_format == 'SAM') {\n        out_format = ' outputformat=sam SO=coordinate';\n        extension = '.sam';\n    } else if (inputs.output_format == 'Queryname Sorted BAM') {\n        out_format = ' outputformat=bam SO=queryname';\n        extension = '.bam';\n    } else if (inputs.output_format == 'Queryname Sorted SAM') {\n        out_format = ' outputformat=sam SO=queryname';\n        extension = '.sam';\n    } else {\n        out_format = ' outputformat=bam SO=coordinate';\n        indexfilename = ' indexfilename=' + fname + '.bam.bai';\n        extension = '.bam';\n    }\n    var cmd = \" | \" + sort_path + \" threads=\" + threads + \" level=1 tmplevel=-1 inputformat=sam\";\n    cmd += out_format;\n    cmd += indexfilename;\n    // capture metrics file\n    cmd += \" M=\" + fname + \".sormadup_metrics.log\";\n\n    if (inputs.output_format == 'SAM') cmd = '';\n    \n    return cmd + ' > ' + fname + extension;\n    \n}"
          },
          {
            "prefix": "",
            "shellQuote": false,
            "position": 10004,
            "valueFrom": "${\n    /// Get pipe status ///\n    \n    var  cmd = \";declare -i pipe_statuses=(\\\\${PIPESTATUS[*]});len=\\\\${#pipe_statuses[@]};declare -i tot=0;echo \\\\${pipe_statuses[*]};for (( i=0; i<\\\\${len}; i++ ));do if [ \\\\${pipe_statuses[\\\\$i]} -ne 0 ];then tot=\\\\${pipe_statuses[\\\\$i]}; fi;done;if [ \\\\$tot -ne 0 ]; then >&2 echo Error in piping. Pipe statuses: \\\\${pipe_statuses[*]};fi; if [ \\\\$tot -ne 0 ]; then false;fi\\\"\";\n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var reads_size =0;\n    // Calculate suggested number of CPUs depending of the input reads size\n    if (inputs.input_reads.constructor == Array) {\n        if (inputs.input_reads[1]) reads_size = inputs.input_reads[0].size + inputs.input_reads[1].size;\n        else reads_size = inputs.input_reads[0].size;\n    } else reads_size = inputs.input_reads.size;\n    if (!reads_size) reads_size = 0;\n\n    var GB_1 = 1024 * 1024 * 1024;\n    var  suggested_memory = 0;\n    if (reads_size < GB_1) suggested_memory = 4;\n    else if (reads_size < 10 * GB_1) suggested_memory = 15;\n    else suggested_memory = 58;\n    \n    if (inputs.total_memory) return inputs.total_memory * 1024;\n    else if (inputs.sort_memory) return inputs.sort_memory * 1024;\n    else return suggested_memory * 1024;\n    \n}",
            "coresMin": "${\n    var reads_size = 0\n    // Calculate suggested number of CPUs depending of the input reads size\n    if (inputs.input_reads.constructor == Array) {\n        if (inputs.input_reads[1]) reads_size = inputs.input_reads[0].size + inputs.input_reads[1].size;\n        else reads_size = inputs.input_reads[0].size;\n    } else reads_size = inputs.input_reads.size;\n    \n    if (!reads_size) reads_size = 0;\n    \n    var GB_1 = 1024 * 1024 * 1024;\n    var suggested_cpus = 0;\n    if (reads_size < GB_1) suggested_cpus = 1;\n    else if (reads_size < 10 * GB_1) suggested_cpus = 8;\n    else suggested_cpus = 31;\n    \n    if (inputs.reserved_threads) return inputs.reserved_threads;\n    else if (inputs.threads) return inputs.threads;\n    else if (inputs.sambamba_threads) return inputs.sambamba_threads;\n    else return suggested_cpus;\n    \n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/vladimirk/bwa_biobambam2:0.7.17"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.reference_index_tar)",
              "$(inputs.input_reads)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};\n"
            ]
          }
        ],
        "sbg:toolAuthor": "Heng Li",
        "sbg:toolkit": "BWA",
        "sbg:license": "BWA: GNU Affero General Public License v3.0, MIT License; Biobambam2: GNU General Public License v3.0",
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolkitVersion": "0.7.17",
        "sbg:image_url": null,
        "sbg:cmdPreview": "/bin/bash -c \" export REF_CACHE=${PWD} ;  tar -tvf reference.HG38.fasta.gz.tar 1>&2; tar -xf reference.HG38.fasta.gz.tar ;  bwa mem  -R '@RG\\tID:1\\tPL:Illumina\\tSM:dnk_sample' -t 10  reference.HG38.fasta.gz  /path/to/LP6005524-DNA_C01_lane_7.sorted.converted.filtered.pe_2.gz /path/to/LP6005524-DNA_C01_lane_7.sorted.converted.filtered.pe_1.gz  | bamsormadup threads=10 level=1 tmplevel=-1 inputformat=sam outputformat=cram SO=coordinate reference=reference.HG38.fasta.gz indexfilename=LP6005524-DNA_C01_lane_7.sorted.converted.filtered.cram.crai M=LP6005524-DNA_C01_lane_7.sorted.converted.filtered.sormadup_metrics.log > LP6005524-DNA_C01_lane_7.sorted.converted.filtered.cram  ;declare -i pipe_statuses=(\\${PIPESTATUS[*]});len=\\${#pipe_statuses[@]};declare -i tot=0;echo \\${pipe_statuses[*]};for (( i=0; i<\\${len}; i++ ));do if [ \\${pipe_statuses[\\$i]} -ne 0 ];then tot=\\${pipe_statuses[\\$i]}; fi;done;if [ \\$tot -ne 0 ]; then >&2 echo Error in piping. Pipe statuses: \\${pipe_statuses[*]};fi; if [ \\$tot -ne 0 ]; then false;fi\"",
        "sbg:links": [
          {
            "id": "http://bio-bwa.sourceforge.net/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/lh3/bwa",
            "label": "Source code"
          },
          {
            "id": "http://bio-bwa.sourceforge.net/bwa.shtml",
            "label": "Wiki"
          },
          {
            "id": "http://sourceforge.net/projects/bio-bwa/",
            "label": "Download"
          },
          {
            "id": "http://arxiv.org/abs/1303.3997",
            "label": "Publication"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/19451168",
            "label": "Publication BWA Algorithm"
          }
        ],
        "sbg:projectName": "V-pipe tools - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651752668,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651752742,
            "sbg:revisionNotes": "Edited only for cwltool compatibility."
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651843633,
            "sbg:revisionNotes": "Added RG input string."
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1651845401,
            "sbg:revisionNotes": "Shell quote added for -R."
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "lea_lenhardt_ackovic",
            "sbg:modifiedOn": 1652082980,
            "sbg:revisionNotes": "Added RG boolean input."
          }
        ],
        "sbg:appVersion": [
          "v1.2"
        ],
        "sbg:id": "h-39fdf6c2/h-2df10d40/h-35b292fb/0",
        "sbg:revision": 4,
        "sbg:revisionNotes": "Added RG boolean input.",
        "sbg:modifiedOn": 1652082980,
        "sbg:modifiedBy": "lea_lenhardt_ackovic",
        "sbg:createdOn": 1651752668,
        "sbg:createdBy": "lea_lenhardt_ackovic",
        "sbg:project": "lea_lenhardt_ackovic/v-pipe-tools-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "lea_lenhardt_ackovic"
        ],
        "sbg:latestRevision": 4,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a7b4d8e1735765a817a33b1d6b563870bd1d6ced78742659876d8add99c4a1d77",
        "sbg:workflowLanguage": "CWL"
      },
      "label": "BWA MEM Bundle 0.7.17 CWL1.2",
      "scatter": [
        "input_reads"
      ],
      "sbg:x": -93.84479522705078,
      "sbg:y": -84.57958221435547
    }
  ],
  "requirements": [
    {
      "class": "SubworkflowFeatureRequirement"
    },
    {
      "class": "ScatterFeatureRequirement"
    },
    {
      "class": "InlineJavascriptRequirement"
    },
    {
      "class": "StepInputExpressionRequirement"
    }
  ],
  "sbg:projectName": "SBG Public data",
  "sbg:revisionsInfo": [
    {
      "sbg:revision": 0,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567780,
      "sbg:revisionNotes": null
    },
    {
      "sbg:revision": 1,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567781,
      "sbg:revisionNotes": "Latest revision from dev project."
    },
    {
      "sbg:revision": 2,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567781,
      "sbg:revisionNotes": "Edited description."
    },
    {
      "sbg:revision": 3,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567781,
      "sbg:revisionNotes": "Label changed."
    },
    {
      "sbg:revision": 4,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567782,
      "sbg:revisionNotes": "Description edited and added SARS-CoV-2 category."
    },
    {
      "sbg:revision": 5,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567782,
      "sbg:revisionNotes": "Edited default values and description."
    },
    {
      "sbg:revision": 6,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567782,
      "sbg:revisionNotes": "CWLtool Tested category added."
    },
    {
      "sbg:revision": 7,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567782,
      "sbg:revisionNotes": "Description edited."
    },
    {
      "sbg:revision": 8,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567782,
      "sbg:revisionNotes": "Edited description after review."
    },
    {
      "sbg:revision": 9,
      "sbg:modifiedBy": "admin",
      "sbg:modifiedOn": 1653567783,
      "sbg:revisionNotes": "Updated after review."
    }
  ],
  "sbg:image_url": "https://cgc.sbgenomics.com/ns/brood/images/admin/sbg-public-data/v-pipe-2-99-2-for-sars-cov-2/9.png",
  "sbg:license": "Apache-2.0 License",
  "sbg:toolAuthor": "Ivan Topolsky, Kim Philipp Jablonski, Lara Fuhrmann, Uwe Schmitt, Monica Dragan, Susana Posada C\u00e9spedes, David Seifert, Tobias Marschall, Niko Beerenwinkel",
  "sbg:categories": [
    "Variant Calling",
    "SARS-CoV-2",
    "CWLtool Tested"
  ],
  "sbg:links": [
    {
      "id": "https://cbg-ethz.github.io/V-pipe/sars-cov-2/",
      "label": "Homepage"
    },
    {
      "id": "https://academic.oup.com/bioinformatics/article/37/12/1673/6104816",
      "label": "Publication"
    },
    {
      "id": "https://cbg-ethz.github.io/V-pipe/tutorial/sars-cov2/",
      "label": "Documentation"
    },
    {
      "id": "https://github.com/cbg-ethz/V-pipe/releases/tag/v2.99.2",
      "label": "Source Code"
    },
    {
      "id": "https://github.com/cbg-ethz/V-pipe/archive/refs/tags/v2.99.2.tar.gz",
      "label": "Download"
    }
  ],
  "sbg:expand_workflow": false,
  "sbg:appVersion": [
    "v1.2",
    "v1.0"
  ],
  "id": "https://cgc-api.sbgenomics.com/v2/apps/admin/sbg-public-data/v-pipe-2-99-2-for-sars-cov-2/9/raw/",
  "sbg:id": "admin/sbg-public-data/v-pipe-2-99-2-for-sars-cov-2/9",
  "sbg:revision": 9,
  "sbg:revisionNotes": "Updated after review.",
  "sbg:modifiedOn": 1653567783,
  "sbg:modifiedBy": "admin",
  "sbg:createdOn": 1653567780,
  "sbg:createdBy": "admin",
  "sbg:project": "admin/sbg-public-data",
  "sbg:sbgMaintained": false,
  "sbg:validationErrors": [],
  "sbg:contributors": [
    "admin"
  ],
  "sbg:latestRevision": 9,
  "sbg:publisher": "sbg",
  "sbg:content_hash": "ad54a611039810549519dd07318ac887af133612274d16218e8a3850e4788e6ff",
  "sbg:workflowLanguage": "CWL"
}