{
  "$namespaces": {
    "sbg": "https://sevenbridges.com"
  },
  "sbg:links": [
    {
      "label": "Homepage",
      "id": "https://software.broadinstitute.org/gatk/"
    },
    {
      "label": "Source Code",
      "id": "https://github.com/broadinstitute/gatk/"
    },
    {
      "label": "Download",
      "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
    },
    {
      "label": "Publications",
      "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
    },
    {
      "label": "Documentation",
      "id": "https://software.broadinstitute.org/gatk/documentation/article.php?id=3891"
    }
  ],
  "requirements": [
    {
      "class": "ScatterFeatureRequirement"
    }
  ],
  "doc": "This workflow represents the GATK Best Practices for SNP and INDEL calling on RNA-Seq data. \n\nStarting from an unmapped BAM file, it performs alignment to the reference genome, followed by marking duplicates, reassigning mapping qualities, base recalibration, variant calling and variant filtering. On the [GATK website](https://software.broadinstitute.org/gatk/documentation/article.php?id=3891), you can find more detailed information about calling variants in RNA-Seq.\n\n###Common Use Cases\n- If you have raw sequencing reads in FASTQ format, you should convert them to an unmapped BAM file using the **Picard FastqToSam** app before running the workflow.\n- **BaseRecalibrator** uses **Known indels** and **Known SNPs** databases to mask out polymorphic sites when creating a model for adjusting quality scores. Also, the **HaplotypeCaller** uses the **Known SNPs** database to populate the ID column of the VCF output.\n- The **HaplotypeCaller** app uses **Intervals list** to restrict processing to specific genomic intervals. You can set the **Scatter count** value in order to split **Intervals list** into smaller intervals. **HaplotypeCaller** processes these intervals in parallel, which will significantly reduce workflow execution time  in some cases.\n- You can provide a pre-generated **STAR** reference index file or a genome reference file to the **Reference or STAR index** input.\n- **Running a batch task**: Batching is performed by **Sample ID** metadata field on the **Unmapped BAM** input port. For running analyses in batches, it is necessary to set **Sample ID** metadata for each unmapped BAM file.\n\n\n###Changes Introduced by Seven Bridges\nThis workflow represents the GATK Best Practices for SNP and indel calling on RNA-Seq data, and there are no modifications to the original workflow.\n\n\n###Common Issues and Important Notes\n- As the *(--known-sites)* is the required option for GATK BaseRecalibrator tool, it is necessary to provide at least one database file to the **Known INDELs** or **Known SNPs** input port.\n- If you are providing pre-generated STAR reference index make sure it is created using the adequate version of STAR (check the STAR version in the original [WDL file](https://github.com/gatk-workflows/gatk3-4-rnaseq-germline-snps-indels/blob/master/rna-germline-variant-calling.wdl)).\n- When converting FASTQ files to an unmapped BAM file using **Picard FastqToSam**, it is required to set the **Platform** (`PLATFORM=`) parameter.\n- This workflow allows you to process one sample per task execution. If you are planning to process more than one sample, it is required to run multiple task executions in batch mode. More about batch analyses can be found [here](https://docs.sevenbridges.com/docs/about-batch-analyses).\n \n\n###Performance Benchmarking\nThe default memory and CPU requirements for each app in the workflow are the same as in the original [GATK Best Practices WDL](https://github.com/gatk-workflows/gatk3-4-rnaseq-germline-snps-indels/blob/master/rna-germline-variant-calling.wdl). You can change the default runtime requirements for **STAR GenomeGenerate** and **STAR Align** apps. \n\n| Experiment type |  Input size | Paired-end | # of reads | Read length | Duration |  AWS Instance Cost (spot) | AWS Instance Cost (on-demand) | \n|:--------------:|:------------:|:--------:|:-------:|:---------:|:----------:|:------:|:------:|\n|     RNA-Seq     |  1.3 GB |     Yes    |     16M     |     101     |   2h44min   | 0.79$ | 1.79$ | \n|     RNA-Seq     |  3.9 GB |     Yes    |     50M     |     101     |   4h38min   | 1.29$ | 2.71$ | \n|     RNA-Seq     | 6.5 GB |     Yes    |     82M    |     101     |  6h44min  | 1.85$ | 3.84$ | \n|     RNA-Seq     | 12.9 GB |     Yes    |     164M    |     101     |  12h4min  | 3.30$ | 6.99$ |\n\n\n###API Python Implementation\nThe workflow's draft task can also be submitted via the API. To learn how to get your Authentication token and API endpoint for the corresponding platform, visit our [documentation](https://github.com/sbg/sevenbridges-python#authentication-and-configuration).\n```python\nfrom sevenbridges import Api\n\nauthentication_token, api_endpoint = \"enter_your_token\", \"enter_api_endpoint\"\napi = Api(token=authentication_token, url=api_endpoint)\n# Get project_id/workflow_id from your address bar. Example: https://igor.sbgenomics.com/u/your_username/project/workflow\nproject_id = \"your_username/project\"\nworkflow_id = \"your_username/project/workflow\"\n# Get file names from files in your project.\ninputs = {\n        \"input\": api.files.query(project=project_id, names=['Homo_sapiens_assembly19_1000genomes_decoy.whole_genome.interval_list']),\n        \"in_alignments\": api.files.query(project=project_id, names=['G26234.HCC1187_1Mreads.bam'])[0],\n        \"in_reference\": api.files.query(project=project_id, names=['Homo_sapiens_assembly19_1000genomes_decoy.fasta'])[0],\n        \"in_gene_annotation\": api.files.query(project=project_id, names=['star.gencode.v19.transcripts.patched_contigs.gtf'])[0],\n        \"in_reference_or_index\": api.files.query(project=project_id, names=['Homo_sapiens_assembly19_1000genomes_decoy.star.gencode.v19.transcripts.patched_contigs.star-2.5.3a_modified-index-archive.tar'])[0],\n        \"known_indels\": api.files.query(project=project_id, names=['Mills_and_1000G_gold_standard.indels.b37.sites.vcf',\n                                                                   'Homo_sapiens_assembly19_1000genomes_decoy.known_indels.vcf']),\n        \"known_snps\": api.files.query(project=project_id, names=['Homo_sapiens_assembly19_1000genomes_decoy.dbsnp138.vcf']),\n}\n\ntask = api.tasks.create(name='GATK4 RNA-Seq Workflow - API Example', project=project_id, app=workflow_id, inputs=inputs, run=False)\n#For running a batch task\ntask = api.tasks.create(name='GATK4 RNA-Seq Workflow - API Batch Example', project=project_id, app=workflow_id, inputs=inputs, run=False, batch_input='in_alignments', batch_by = { 'type': 'CRITERIA', 'criteria': [ 'metadata.sample_id'] })\n```\n\nInstructions for installing and configuring the API Python client are provided on GitHub. For more information about using the API Python client, consult [sevenbridges-python documentation](http://sevenbridges-python.readthedocs.io/en/latest/). More examples are available [here](https://github.com/sbg/okAPI).\n\nAdditionally, [API R](https://github.com/sbg/sevenbridges-r) and [API Java](https://github.com/sbg/sevenbridges-java) clients are available. To learn more about using these API clients please refer to the [API R client documentation](https://sbg.github.io/sevenbridges-r/), and [API Java client documentation](https://docs.sevenbridges.com/docs/java-library-quickstart).",
  "sbg:wrapperAuthor": "veliborka_josipovic, nemanja.vucic",
  "sbg:projectName": "BCO-CWL Examples",
  "sbg:license": "BSD 3-Clause License",
  "sbg:revisionsInfo": [
    {
      "sbg:revision": 0,
      "sbg:modifiedBy": "phil_webster",
      "sbg:modifiedOn": 1663787195,
      "sbg:revisionNotes": "Copy of admin/sbg-public-data/broad-best-practices-rna-seq-variant-calling-4-1-0-0/8"
    }
  ],
  "sbg:toolAuthor": "Broad Institute",
  "sbg:image_url": "https://cgc.sbgenomics.com/ns/brood/images/phil_webster/bco-cwl-examples/broad-best-practices-rna-seq-variant-calling-4-1-0-0/0.png",
  "sbg:expand_workflow": false,
  "outputs": [
    {
      "type": "File?",
      "outputSource": [
        "gatk_applybqsr_4_1_0_0/out_alignments"
      ],
      "label": "Output recalibrated BAM/SAM/CRAM",
      "sbg:fileTypes": "BAM, SAM, CRAM",
      "id": "out_alignments",
      "sbg:x": 2278.889892578125,
      "doc": "Output recalibrated BAM/SAM/CRAM file.",
      "sbg:y": -617.44921875
    },
    {
      "type": "File?",
      "outputSource": [
        "gatk_mergevcfs_4_1_0_0/out_variants"
      ],
      "label": "Output VCF",
      "sbg:fileTypes": "VCF, VCF.GZ, BCF",
      "id": "out_variants",
      "sbg:x": 2655.3984375,
      "doc": "Output VCF file.",
      "sbg:y": -385.8646240234375
    },
    {
      "type": "File?",
      "outputSource": [
        "gatk_variantfiltration_4_1_0_0/out_variants"
      ],
      "label": "Output filtered VCF",
      "sbg:fileTypes": "VCF.GZ",
      "id": "out_filtered_variants",
      "sbg:x": 2750.729248046875,
      "doc": "Output filtered VCF file.",
      "sbg:y": -106.19538879394531
    }
  ],
  "label": "BROAD Best Practices RNA-Seq Variant Calling 4.1.0.0",
  "class": "Workflow",
  "inputs": [
    {
      "type": "File",
      "label": "Unmapped BAM",
      "sbg:fileTypes": "SAM, BAM, CRAM",
      "id": "in_alignments",
      "sbg:x": -1237,
      "doc": "Unmapped BAM file.",
      "sbg:y": -463
    },
    {
      "type": "File",
      "secondaryFiles": [
        ".fai",
        "^.dict"
      ],
      "label": "Reference",
      "sbg:fileTypes": "FASTA, FA",
      "id": "in_reference",
      "sbg:x": -178.14291381835938,
      "doc": "Genome reference.",
      "sbg:y": 389.0186462402344
    },
    {
      "type": "File[]?",
      "secondaryFiles": [
        ".idx"
      ],
      "label": "Known INDELs",
      "sbg:fileTypes": "VCF",
      "id": "known_indels",
      "sbg:x": 729.8524169921875,
      "doc": "Known INDELs.",
      "sbg:y": -223.1912841796875
    },
    {
      "type": "File?",
      "secondaryFiles": [
        ".idx"
      ],
      "label": "Known SNPs",
      "sbg:fileTypes": "VCF",
      "id": "known_snps",
      "sbg:x": 912.197509765625,
      "doc": "Known SNPs.",
      "sbg:y": -490.7837829589844
    },
    {
      "type": "File[]",
      "label": "Interval list",
      "sbg:fileTypes": "VCF, INTERVAL_LIST",
      "id": "in_intervals",
      "sbg:x": 1423.5,
      "doc": "Interval list.",
      "sbg:y": -626.5
    },
    {
      "type": "int?",
      "doc": "Scatter count.",
      "id": "scatter_count",
      "sbg:exposed": true
    },
    {
      "type": "float?",
      "doc": "Standard minimum confidence threshold for calling.",
      "id": "standard_min_confidence_threshold_for_calling",
      "sbg:exposed": true
    },
    {
      "type": "File",
      "label": "Reference or STAR index",
      "sbg:fileTypes": "FASTA, FA, FNA, TAR",
      "id": "in_reference_or_index",
      "sbg:x": -1079.9658203125,
      "doc": "Genome reference or STAR index file.",
      "sbg:y": 13
    },
    {
      "type": "File?",
      "label": "Gene annotation",
      "sbg:fileTypes": "GTF, GFF, GFF2, GFF3",
      "id": "in_gene_annotation",
      "sbg:x": -1069.978271484375,
      "doc": "Gene annotation used by STAR.",
      "sbg:y": 136
    },
    {
      "type": "int?",
      "label": "Number of threads",
      "id": "cpu_per_job",
      "sbg:x": -1066.9813232421875,
      "doc": "Number of threads.",
      "sbg:y": 261.99688720703125
    },
    {
      "type": "int?",
      "label": "Memory per job",
      "id": "mem_per_job",
      "sbg:x": -1062.9844970703125,
      "doc": "Amount of RAM memory to be used per job.",
      "sbg:y": 386.9906921386719
    },
    {
      "type": "int?",
      "label": "Read length",
      "id": "read_length",
      "sbg:x": -1087.95654296875,
      "doc": "Read length used by STAR.",
      "sbg:y": -111.00310516357422
    },
    {
      "type": "int?",
      "label": "Number of threads",
      "id": "cpu_per_star_align",
      "sbg:x": -690,
      "doc": "Number of threads.",
      "sbg:y": 33.62785720825195
    },
    {
      "type": "int?",
      "label": "Max number of collapsed junctions",
      "id": "limitOutSJcollapsed",
      "sbg:x": -795.79296875,
      "doc": "Max number of collapsed junctions.",
      "sbg:y": -92.24427032470703
    },
    {
      "type": "int?",
      "label": "Memory per job",
      "id": "mem_per_star_align",
      "sbg:x": -918.782470703125,
      "doc": "Amount of RAM memory to be used per job.",
      "sbg:y": -189.21380615234375
    }
  ],
  "cwlVersion": "v1.0",
  "sbg:categories": [
    "Transcriptomics",
    "Variant Calling"
  ],
  "steps": [
    {
      "id": "gatk_revertsam_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 8,
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/28",
        "sbg:toolAuthor": "Broad Institute",
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 4096;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "The **GATK RevertSam** tool reverts SAM, BAM or CRAM files to the previous state. \n\nThis tool removes or restores certain properties of the SAM records, including alignment information, which can be used to produce an unmapped BAM (uBAM) from a previously aligned BAM. It is also capable of restoring the original quality scores of the BAM file that has already undergone base quality score recalibration (BQSR) if the original qualities were retained during the calibration (OQ tag) [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases\n\n* The **GATK RevertSam** tool requires a BAM/SAM/CRAM file on its **Input BAM/SAM/CRAM file** (`--INPUT`) input. The tool generates a single BAM file on its output by default, or SAM or CRAM if the input file is SAM or CRAM, respectively.\n\n* The **GATK RevertSam** tool supports an optional parameter  **Output by readgroup** (`--OUTPUT_BY_READGROUP`) which, when true, outputs each read group in a separate file. The output file format will be equal to the input file format. This behaviour can be overridden with the **Output by readgroup file format** (`--OUTPUT_BY_READGROUP_FILE_FORMAT`) argument. Outputting by read group can optionally be done by adding an output map on the **Output map** (`--OUTPUT_MAP`) input. The output map is a tab separated file which provides file mapping with two columns, READ_GROUP_ID and OUTPUT.\n\n* Usage Example - Output to a single file:\n```\n gatk RevertSam \\\\\n      --INPUT input.bam \\\\\n      --OUTPUT reverted.bam\n\n```\n\n* Usage Example - Output by read group into multiple files with sample map:\n\n```\n\n gatk RevertSam \\\\\n      --INPUT input.bam \\\\\n      --OUTPUT_BY_READGROUP true\\\\\n      --OUTPUT_MAP reverted_bam_paths.tsv\n\n```\n\n* Usage Example - Output by read group with no output map:\n\n```\n\ngatk RevertSam \\\\\n      --INPUT input.bam \\\\\n      --OUTPUT_BY_READGROUP true \\\\\n      --OUTPUT /write/reverted/read/group/bams/in/this/dir\n\n```\n\n###Changes Introduced by Seven Bridges\n\n* All output files will be prefixed using the **Output prefix** parameter. In case **Output prefix** is not provided, output prefix will be the same as the Sample ID metadata from the **Input SAM/BAM/CRAM file**, if the Sample ID metadata exists. Otherwise, output prefix will be inferred from the **Input SAM/BAM/CRAM file** filename. This way, having identical names of the output files between runs is avoided. Moreover,  **reverted** will be added before the extension of the output file name. \n\n* The user has a possibility to specify the output file format using the **Output file format** option. Otherwise, the output file format will be the same as the format of the input file.\n\n###Common Issues and Important Notes\n\n* Note: If the program fails due to a SAM validation error, consider setting the **Validation stringency** (`--VALIDATION_STRINGENCY`) option to LENIENT or SILENT if the failures are expected to be obviated by the reversion process (e.g. invalid alignment information will be obviated when the **Remove alignment information** (`--REMOVE_ALIGNMENT_INFORMATION`) option is used).\n\n###Performance Benchmarking\n\nBelow is a table describing runtimes and task costs of **GATK RevertSam** for a couple of different samples, executed on the AWS cloud instances:\n\n| Experiment type |  Input size | Paired-end | # of reads | Read length | Duration |  Cost | Instance (AWS) | \n|:--------------:|:------------:|:--------:|:-------:|:---------:|:----------:|:------:|:------:|\n|     RNA-Seq     |  1.3 GB |     Yes    |     16M     |     101     |   4min   | ~0.03$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     |  3.9 GB |     Yes    |     50M     |     101     |   6min   | ~0.04$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 6.5 GB |     Yes    |     82M    |     101     |  9min  | ~0.06$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 12.9 GB |     Yes    |     164M    |     101     |  16min  | ~0.11$ | c4.2xlarge (8 CPUs) |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n###References\n\n[1] [GATK RevertSam](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_SamToFastq.php)",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:createdOn": 1552659126,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-revertsam-4-1-0-0/8",
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:image_url": null,
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/28",
        "sbg:modifiedBy": "veliborka_josipovic",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1552659126,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/14",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1552659760,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/15",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554492426,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/18",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554492542,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/19",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554492643,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/20",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554493226,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/21",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554720836,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/23",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999285,
            "sbg:revision": 7,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/24",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559564779,
            "sbg:revision": 8,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-revertsam-4-1-0-0/28",
            "sbg:modifiedBy": "veliborka_josipovic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:toolkit": "GATK",
        "label": "GATK RevertSam",
        "sbg:content_hash": "a49c638f1ba71e9b2aba87e9cfce60275b41027bb463214a36fc53afbc98710f3",
        "outputs": [
          {
            "type": "File[]?",
            "label": "Output reverted SAM/BAM/CRAM file(s)",
            "sbg:fileTypes": "BAM, SAM",
            "id": "out_alignments",
            "outputBinding": {
              "glob": "${\n    if (inputs.output_by_readgroup)\n    {\n        var in_alignments = inputs.in_alignments;\n        var output_prefix = '';\n        if (inputs.output_prefix)\n        {\n            output_prefix = inputs.output_prefix;\n        }\n        else \n        {\n            if (in_alignments.metadata && in_alignments.metadata.sample_id)\n            {\n                output_prefix = in_alignments.metadata.sample_id;\n            }\n            else \n            {\n                output_prefix = in_alignments.path.split('/').pop().split('.')[0];\n            }\n        }\n        if (inputs.output_map)\n        {\n            return '*am';\n        }\n        else\n        {\n            return output_prefix + \"/*\";\n        }\n            \n    }\n    else\n    {\n        return \"*reverted*\";\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "Output reverted SAM/BAM/CRAM file(s)."
          }
        ],
        "sbg:id": "h-66f487bd/h-e1122972/h-0a3bf13f/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "[NM, UQ, PG, MD, MQ, SA, MC, AS]",
            "id": "attribute_to_clear",
            "doc": "When removing alignment information, the set of optional tags to remove. This argument may be specified 0 or more times.",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--ATTRIBUTE_TO_CLEAR', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    else\n    {\n        return '';\n    }\n    \n}",
              "shellQuote": false,
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Attribute to clear"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "compression_level",
            "doc": "Compression level for all compressed files created (e.g. BAM and VCF).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--COMPRESSION_LEVEL",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Compression level"
          },
          {
            "type": "File",
            "id": "in_alignments",
            "sbg:fileTypes": "SAM, BAM, CRAM",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--INPUT",
              "position": 5
            },
            "doc": "The input SAM/BAM/CRAM file to revert the state of.",
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "label": "Input SAM/BAM/CRAM file"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "keep_first_duplicate",
            "doc": "If SANITIZE=true keep the first record when we find more than one record with the same name for R1/R2/unpaired reads respectively. For paired end reads, keeps only the first R1 and R2 found respectively, and discards all unpaired reads. Duplicates do not refer to the duplicate flag in the FLAG field, but instead reads with the same name.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--KEEP_FIRST_DUPLICATE",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Keep first duplicate"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "library_name",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--LIBRARY_NAME",
              "position": 5
            },
            "doc": "The library name to use in the reverted output file. This will override the existing library name alias in the file and is used only if all the read groups in the input file have the same library name.",
            "sbg:altPrefix": "-LIB",
            "sbg:category": "Optional Arguments",
            "label": "Library name"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.01",
            "id": "max_discard_fraction",
            "doc": "If SANITIZE=true and higher than MAX_DISCARD_FRACTION, reads are discarded due to sanitization then the program will exit with an Exception instead of exiting cleanly. Output BAM will still be valid.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MAX_DISCARD_FRACTION",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Max discard fraction"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "500000",
            "id": "max_records_in_ram",
            "doc": "When writing files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort the file, and increases the amount of RAM needed.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MAX_RECORDS_IN_RAM",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Max records in RAM"
          },
          {
            "type": "int?",
            "id": "memory_overhead_per_job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2048 MB",
            "id": "memory_per_job",
            "label": "Memory per job",
            "sbg:category": "Platform Options",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped)."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "output_by_readgroup",
            "doc": "When true, outputs each read group in a separate file.",
            "sbg:altPrefix": "-OBR",
            "sbg:category": "Optional Arguments",
            "label": "Output by readgroup"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_by_readgroup_file_format",
                "symbols": [
                  "sam",
                  "bam",
                  "cram",
                  "dynamic"
                ]
              }
            ],
            "sbg:toolDefaultValue": "dynamic",
            "id": "output_by_readgroup_file_format",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--OUTPUT_BY_READGROUP_FILE_FORMAT",
              "position": 5
            },
            "doc": "When using OUTPUT_BY_READGROUP, the output file format can be set to a certain format. Possible values: { sam (generate SAM files.) bam (generate BAM files.) cram (generate CRAM files.) dynamic (generate files based on the extention of input.) }.",
            "sbg:altPrefix": "-OBRFF",
            "sbg:category": "Optional Arguments",
            "label": "Output by readgroup file format"
          },
          {
            "type": "File?",
            "id": "output_map",
            "sbg:fileTypes": "TSV",
            "doc": "Tab separated file with two columns, READ_GROUP_ID and OUTPUT, providing file mapping only used if OUTPUT_BY_READGROUP is true.",
            "sbg:altPrefix": "-OM",
            "sbg:category": "Optional Arguments",
            "label": "Output map"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "true",
            "id": "remove_alignment_information",
            "doc": "Remove all alignment information from the file.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--REMOVE_ALIGNMENT_INFORMATION",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Remove alignment information"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "true",
            "id": "remove_duplicate_information",
            "doc": "Remove duplicate read flags from all reads. Note that if this is false and REMOVE_ALIGNMENT_INFORMATION==true, the output may have the unusual but sometimes desirable trait of having unmapped reads that are marked as duplicates.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--REMOVE_DUPLICATE_INFORMATION",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Remove duplicate information"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "true",
            "id": "restore_original_qualities",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--RESTORE_ORIGINAL_QUALITIES",
              "position": 5
            },
            "doc": "True to restore original qualities from the OQ field to the QUAL field if available.",
            "sbg:altPrefix": "-OQ",
            "sbg:category": "Optional Arguments",
            "label": "Restore original qualities"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "sample_alias",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SAMPLE_ALIAS",
              "position": 5
            },
            "doc": "The sample alias to use in the reverted output file. This will override the existing sample alias in the file and is used only if all the read groups in the input file have the same sample alias.",
            "sbg:altPrefix": "-ALIAS",
            "sbg:category": "Optional Arguments",
            "label": "Sample alias"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "sanitize",
            "doc": "Warning: this option is potentially destructive. If enabled, will discard reads in order to produce a consistent output BAM. Reads discarded include (but are not limited to) paired reads with missing mates, duplicated records, records with mismatches in length of bases and qualities. This option can only be enabled if the output sort order is queryname and will always cause sorting to occur.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SANITIZE",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Sanitize"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "sort_order",
                "symbols": [
                  "unsorted",
                  "queryname",
                  "coordinate",
                  "duplicate",
                  "unknown"
                ]
              }
            ],
            "sbg:toolDefaultValue": "queryname",
            "id": "sort_order",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SORT_ORDER",
              "position": 5
            },
            "doc": "The sort order to create the reverted output file with.",
            "sbg:altPrefix": "-SO",
            "sbg:category": "Optional Arguments",
            "label": "Sort order"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "validation_stringency",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "STRICT",
            "id": "validation_stringency",
            "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--VALIDATION_STRINGENCY",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Validation stringency"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_file_format",
                "symbols": [
                  "sam",
                  "bam",
                  "cram"
                ]
              }
            ],
            "id": "output_file_format",
            "doc": "Output file format.",
            "label": "Output file format",
            "sbg:category": "Optional Arguments"
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output file name prefix.",
            "label": "Output prefix",
            "sbg:category": "Optional Arguments"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform Options",
            "doc": "This input allows a user to set the desired CPU requirement when running a tool or adding it to a workflow."
          }
        ],
        "sbg:contributors": [
          "uros_sipetic",
          "veliborka_josipovic"
        ],
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) \n    {\n        return \"--java-options\";\n    }\n    else\n    {\n        return '';\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    else\n    {\n        return '';\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 3
          },
          {
            "valueFrom": "RevertSam",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          },
          {
            "valueFrom": "${\n    if (!inputs.output_map)\n    {\n        var in_alignments = inputs.in_alignments;\n        var output_ext = inputs.output_file_format ? inputs.output_file_format : inputs.in_alignments.path.split('.').pop();\n        var output_prefix = '';\n        if (inputs.output_prefix)\n        {\n            output_prefix = inputs.output_prefix;\n        }\n        else \n        {\n            if (in_alignments.metadata && in_alignments.metadata.sample_id)\n            {\n                output_prefix = in_alignments.metadata.sample_id;\n            }\n            else \n            {\n                output_prefix = in_alignments.path.split('/').pop().split('.')[0];\n            }\n        }\n        \n        if (inputs.output_by_readgroup)\n            return \"--OUTPUT_BY_READGROUP --OUTPUT \" + output_prefix;\n        else\n            return \"--OUTPUT \" + output_prefix + \".reverted.\" + output_ext;\n    }\n    else\n    {\n        var output_map = inputs.output_map.path;\n        return \"--OUTPUT_BY_READGROUP --OUTPUT_MAP \" + output_map;\n    }\n        \n}",
            "shellQuote": false,
            "prefix": "",
            "position": 5
          },
          {
            "valueFrom": "${\n    if (inputs.output_by_readgroup)\n    {\n        var in_alignments = inputs.in_alignments;\n        var output_prefix = '';\n        if (inputs.output_prefix)\n        {\n            output_prefix = inputs.output_prefix;\n        }\n        else \n        {\n            if (in_alignments.metadata && in_alignments.metadata.sample_id)\n            {\n                output_prefix = in_alignments.metadata.sample_id;\n            }\n            else \n            {\n                output_prefix = in_alignments.path.split('/').pop().split('.')[0];\n            }\n        }\n        return \"mkdir \" + output_prefix + \" && \";\n    }\n    else\n    {\n        return '';\n    }\n        \n}",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          }
        ],
        "sbg:modifiedOn": 1559564779,
        "sbg:publisher": "sbg",
        "sbg:toolkitVersion": "4.1.0.0",
        "cwlVersion": "v1.0",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk/"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
          },
          {
            "label": "Publications",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_RevertSam"
          }
        ],
        "sbg:revision": 8,
        "sbg:categories": [
          "Utilities",
          "BAM Processing"
        ]
      },
      "in": [
        {
          "id": "attribute_to_clear",
          "default": [
            "FT",
            "CO"
          ]
        },
        {
          "source": "in_alignments",
          "id": "in_alignments"
        },
        {
          "id": "sort_order",
          "default": "queryname"
        },
        {
          "id": "validation_stringency",
          "default": "SILENT"
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        }
      ],
      "sbg:y": -330.21722412109375,
      "label": "GATK RevertSam",
      "sbg:x": -743.1947631835938,
      "out": [
        {
          "id": "out_alignments"
        }
      ]
    },
    {
      "id": "gatk_samtofastq_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 15,
        "sbg:modifiedBy": "veliborka_josipovic",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk/"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
          },
          {
            "label": "Publications",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_SamToFastq.php"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 4096;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1;\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "The **GATK SamToFastq** tool converts a SAM or BAM file to FASTQ.\n\nThis tool extracts read sequences and qualities from the input SAM/BAM file and writes them into the output file in Sanger FASTQ format.\n\nIn the RC mode (default is True), if the read is aligned and the alignment is to the reverse strand on the genome, the read sequence from input SAM file will be reverse-complemented prior to writing it to FASTQ in order to correctly restore the original read sequence as it was generated by the sequencer [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases\n\n* The **GATK SamToFastq** tool requires a BAM/SAM file on its **Input BAM/SAM file** (`--INPUT`) input. The tool generates a single-end FASTQ file on its **Output FASTQ file(s)** output if the input BAM/SAM file is single end. In case the input file is paired end, the tool outputs the first end of the pair FASTQ and the second end of the pair FASTQ on its **Output FASTQ file(s)** output, except when the **Interleave** (`--INTERLEAVE`) option is set to True. If the output is an interleaved FASTQ file, if paired, each line will have /1 or /2 to describe which end it came from.\n\n* The **GATK SamToFastq** tool supports an optional parameter  **Output by readgroup** (`--OUTPUT_BY_READGROUP`) which, when true, outputs a FASTQ file per read group (two FASTQ files per read group if the group is paired).\n\n* Usage example (input BAM file is single-end):\n\n```\ngatk SamToFastq \n     --INPUT input.bam\n     --FASTQ output.fastq\n```\n\n\n\n\n\n* Usage example (input BAM file is paired-end):\n\n```\ngatk SamToFastq \n     --INPUT input.bam\n     --FASTQ output.pe_1.fastq\n     --SECOND_END_FASTQ output.pe_2.fastq\n     --UNPAIRED_FASTQ unpaired.fastq\n\n```\n\n###Changes Introduced by Seven Bridges\n\n* The GATK SamToFastq tool is implemented to check if the input alignments file contains single-end or paired-end data and according to that generates different command lines for these two modes and thus produces appropriate output files on its **Output FASTQ file(s)** output (one FASTQ file in single-end mode and two FASTQ files if the input alignment file contains paired-end data). \n\n* All output files will be prefixed using the **Output prefix** parameter. In case the **Output prefix** is not provided, the output prefix will be the same as the Sample ID metadata from the **input SAM/BAM file**, if the Sample ID metadata exists. Otherwise, the output prefix will be inferred from the **Input SAM/BAM** filename. This way, having identical names of the output files between runs is avoided.\n\n* For paired-end read files, in order to successfully run alignment with STAR, this tool adds the appropriate **paired-end** metadata field in the output FASTQ files.\n\n###Common Issues and Important Notes\n\n* None\n\n###Performance Benchmarking\n\nBelow is a table describing runtimes and task costs of **GATK SamToFastq** for a couple of different samples, executed on the AWS cloud instances:\n\n| Experiment type |  Input size | Paired-end | # of reads | Read length | Duration |  Cost | Instance (AWS) | \n|:--------------:|:------------:|:--------:|:-------:|:---------:|:----------:|:------:|:------:|\n|     RNA-Seq     |  1.9 GB |     Yes    |     16M     |     101     |   4min   | ~0.03$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     |  5.7 GB |     Yes    |     50M     |     101     |   7min   | ~0.04$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 9.5 GB |     Yes    |     82M    |     101     |  10min  | ~0.07$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 19 GB |     Yes    |     164M    |     101     |  20min  | ~0.13$ | c4.2xlarge (8 CPUs) |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n\n###References\n\n[1] [GATK SamToFastq](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.0.12.0/picard_sam_SamToFastq)",
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:createdOn": 1552663400,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-samtofastq-4-1-0-0/15",
        "sbg:image_url": null,
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:toolkit": "GATK",
        "sbg:content_hash": "a21e1194e724a1f17bceabd4d2040324713c2a5c63896adcebbc777578b2bfef5",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1552663400,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-samtofastq-4-1-0-0/19",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1552663734,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-samtofastq-4-1-0-0/20",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554492676,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-samtofastq-4-1-0-0/27",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554493243,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-samtofastq-4-1-0-0/28",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554720826,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-samtofastq-4-1-0-0/29",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999298,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-samtofastq-4-1-0-0/30",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1557484228,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Updated Description",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1557745933,
            "sbg:revision": 7,
            "sbg:revisionNotes": "",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1557918579,
            "sbg:revision": 8,
            "sbg:revisionNotes": "v32: [input]",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1557919927,
            "sbg:revision": 9,
            "sbg:revisionNotes": "v5->update",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558002424,
            "sbg:revision": 10,
            "sbg:revisionNotes": "output required",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558015833,
            "sbg:revision": 11,
            "sbg:revisionNotes": "unmapped_reads required",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558022954,
            "sbg:revision": 12,
            "sbg:revisionNotes": "strict js for glob",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558023482,
            "sbg:revision": 13,
            "sbg:revisionNotes": "strict javascript for unmapped_reads",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558354170,
            "sbg:revision": 14,
            "sbg:revisionNotes": "return '';",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1561548030,
            "sbg:revision": 15,
            "sbg:revisionNotes": "Added glob for single end output fastq",
            "sbg:modifiedBy": "veliborka_josipovic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:revisionNotes": "Added glob for single end output fastq",
        "label": "GATK SamToFastq",
        "sbg:contributors": [
          "uros_sipetic",
          "nens",
          "veliborka_josipovic"
        ],
        "outputs": [
          {
            "type": "File[]?",
            "label": "Output FASTQ file(s)",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ",
            "id": "out_reads",
            "outputBinding": {
              "glob": "${\n    var output_ext = inputs.compress_outputs ? \".fastq.gz\" : \".fastq\";\n    var interleave = inputs.interleave;\n    if (!inputs.outputs_by_readgroup)\n    {\n        if (interleave)\n        {\n            return \"*interleaved\" + output_ext;\n        }\n        else\n        {\n            return [\"*pe_1\" + output_ext, \"*pe_2\" + output_ext, \"*se\" + output_ext];\n        }\n\n    }\n    else\n    {\n        return \"*\" + output_ext;\n    }\n}",
              "outputEval": "${ \n    self = [].concat(self)\n    \n    function getPairedEnd(filename)\n    {\n        if (filename.lastIndexOf(\".fastq\") !== 0 && filename[filename.lastIndexOf(\".fastq\") - 2 ]==\"_\") \n        {\n            return filename[filename.lastIndexOf(\".fastq\") - 1 ];\n        } \n        else \n        {\n            return \"\";\n        }\n    }\n    \n    var out = inheritMetadata(self,inputs.in_alignments);\n    for (var i=0; i < out.length; i++)\n    {\n        out[i].metadata['paired_end'] = getPairedEnd(out[i].path);\n    }\n    \n    return out;\n}"
            },
            "doc": "Output FASTQ file(s)."
          },
          {
            "type": "File?",
            "label": "Unpaired reads",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ",
            "id": "unmapped_reads",
            "outputBinding": {
              "glob": "${\n    var output_ext = inputs.compress_outputs ? \".fastq.gz\" : \".fastq\";\n    var interleave = inputs.interleave;\n    if (!inputs.outputs_by_readgroup)\n    {\n        if (!interleave)\n        {\n            return \"*unpaired\" + output_ext;\n        }\n        else \n        {\n             return \"\"; \n        }      \n    }\n  else {\n       return \"\";  \n  \n  }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "Unpaired reads."
          }
        ],
        "sbg:id": "h-8a457351/h-fe430875/h-1c7fa2c8/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "clipping_action",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--CLIPPING_ACTION",
              "position": 5
            },
            "doc": "The action that should be taken with clipped reads: 'X' means the reads and qualities should be trimmed at the clipped position; 'N' means the bases should be changed to Ns in the clipped region; and any integer means that the base qualities should be set to that value in the clipped region.",
            "sbg:altPrefix": "-CLIP_ACT",
            "sbg:category": "Optional Arguments",
            "label": "Clipping action"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "clipping_attribute",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--CLIPPING_ATTRIBUTE",
              "position": 5
            },
            "doc": "The attribute that stores the position at which the SAM record should be clipped.",
            "sbg:altPrefix": "-CLIP_ATTR",
            "sbg:category": "Optional Arguments",
            "label": "Clipping attribute"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "clipping_min_length",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--CLIPPING_MIN_LENGTH",
              "position": 5
            },
            "doc": "When performing clipping with the CLIPPING_ATTRIBUTE and CLIPPING_ACTION parameters, ensure that the resulting reads after clipping are at least CLIPPING_MIN_LENGTH bases long. If the original read is shorter than CLIPPING_MIN_LENGTH then the original read length will be maintained.",
            "sbg:altPrefix": "-CLIP_MIN",
            "sbg:category": "Optional Arguments",
            "label": "Clipping min length"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "compress_outputs_per_rg",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--COMPRESS_OUTPUTS_PER_RG",
              "position": 5
            },
            "doc": "Compress output FASTQ files per read group using gzip and append a .gz extension to the file names. Cannot be used in conjuction with argument(s) FASTQ (F) SECOND_END_FASTQ (F2) UNPAIRED_FASTQ (FU).",
            "sbg:altPrefix": "-GZOPRG",
            "sbg:category": "Optional Arguments",
            "label": "Compress outputs per RG"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "compression_level",
            "doc": "Compression level for all compressed files created (e.g. BAM and VCF).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--COMPRESSION_LEVEL",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Compression level"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "include_non_pf_reads",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--INCLUDE_NON_PF_READS",
              "position": 5
            },
            "doc": "Include non-PF reads from the SAM file into the output FASTQ files. PF means 'passes filtering'. Reads whose 'not passing quality controls' flag is set are non-PF reads. See GATK Dictionary for more info.",
            "sbg:altPrefix": "-NON_PF",
            "sbg:category": "Optional Arguments",
            "label": "Include non PF reads"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "include_non_primary_alignments",
            "doc": "If true, include non-primary alignments in the output. Support of non-primary alignments in SamToFastq is not comprehensive, so there may be exceptions if this is set to true and there are paired reads with non-primary alignments.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--INCLUDE_NON_PRIMARY_ALIGNMENTS",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Include non primary alignments"
          },
          {
            "type": "File",
            "id": "in_alignments",
            "sbg:fileTypes": "SAM, BAM",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--INPUT",
              "position": 5
            },
            "doc": "Input SAM/BAM file to extract reads from.",
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "label": "Input SAM/BAM file"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "interleave",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--INTERLEAVE",
              "position": 5
            },
            "doc": "Will generate an interleaved FASTQ if paired, each line will have /1 or /2 to describe which end it came from.",
            "sbg:altPrefix": "-INTER",
            "sbg:category": "Optional Arguments",
            "label": "Interleave"
          },
          {
            "type": "int?",
            "id": "memory_overhead_per_job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2048 MB",
            "id": "memory_per_job",
            "label": "Memory per job",
            "sbg:category": "Platform Options",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped)."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "output_per_rg",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--OUTPUT_PER_RG",
              "position": 5
            },
            "doc": "Output a FASTQ file per read group (two FASTQ files per read group if the group is paired). Cannot be used in conjuction with argument(s)FASTQ (F) SECOND_END_FASTQ (F2) UNPAIRED_FASTQ (FU).",
            "sbg:altPrefix": "-OPRG",
            "sbg:category": "Optional Arguments",
            "label": "Output per RG"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "quality",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--QUALITY",
              "position": 5
            },
            "doc": "End-trim reads using the phred/bwa quality trimming algorithm and this quality.",
            "sbg:altPrefix": "-Q",
            "sbg:category": "Optional Arguments",
            "label": "Quality"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "re_reverse",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "re_reverse",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--RE_REVERSE",
              "position": 5
            },
            "doc": "Re-reverse bases and qualities of reads with negative strand flag set before writing them to FASTQ.",
            "sbg:altPrefix": "-RC",
            "sbg:category": "Optional Arguments",
            "label": "Re reverse"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "read1_max_bases_to_write",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--READ1_MAX_BASES_TO_WRITE",
              "position": 5
            },
            "doc": "The maximum number of bases to write from read 1 after trimming. If there are fewer than this many bases left after trimming, all will be written. If this value is null then all bases left after trimming will be written.",
            "sbg:altPrefix": "-R1_MAX_BASES",
            "sbg:category": "Optional Arguments",
            "label": "Read1 max bases to write"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "read1_trim",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--READ1_TRIM",
              "position": 5
            },
            "doc": "The number of bases to trim from the beginning of read 1.",
            "sbg:altPrefix": "-R1_TRIM",
            "sbg:category": "Optional Arguments",
            "label": "Read1 trim"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "read2_max_bases_to_write",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--READ2_MAX_BASES_TO_WRITE",
              "position": 5
            },
            "doc": "The maximum number of bases to write from read 2 after trimming. If there are fewer than this many bases left after trimming, all will be written. If this value is null then all bases left after trimming will be written.",
            "sbg:altPrefix": "-R2_MAX_BASES",
            "sbg:category": "Optional Arguments",
            "label": "Read2 max bases to write"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "read2_trim",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--READ2_TRIM",
              "position": 5
            },
            "doc": "The number of bases to trim from the beginning of read 2.",
            "sbg:altPrefix": "-R2_TRIM",
            "sbg:category": "Optional Arguments",
            "label": "Read2 trim"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "PU",
            "id": "rg_tag",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--RG_TAG",
              "position": 5
            },
            "doc": "The read group tag (PU or ID) to be used to output a FASTQ file per read group.",
            "sbg:altPrefix": "-RGT",
            "sbg:category": "Optional Arguments",
            "label": "RG tag"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "validation_stringency",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "STRICT",
            "id": "validation_stringency",
            "doc": "Validation stringency for all SAM files read by this program. Setting stringency to silent can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--VALIDATION_STRINGENCY",
              "position": 5
            },
            "sbg:category": "Optional Arguments",
            "label": "Validation stringency"
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output file name prefix.",
            "label": "Output prefix",
            "sbg:category": "Optional Arguments"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "compress_outputs",
            "label": "Compress output file(s)",
            "sbg:category": "Optional parameters",
            "doc": "Compress output file(s)."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform Options",
            "doc": "CPU per job."
          }
        ],
        "cwlVersion": "v1.0",
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "${\n    var in_alignments = [].concat(inputs.in_alignments)[0];\n    var output_ext    = inputs.compress_outputs ? \".fastq.gz\" : \".fastq\";\n    var interleave    = inputs.interleave;\n    var output_prefix = ''; \n    var cmd_line      = '';\n    cmd_line          = \"cmd='' && paired_end=`samtools view -h \" + in_alignments.path + \" | head -n 500000 | samtools view -Sc -f 0x1 -`\";\n\n  if (!inputs.outputs_by_readgroup)\n    {\n        if (inputs.output_prefix)\n        {\n            output_prefix = inputs.output_prefix;\n        }\n        else\n        {\n            if (in_alignments.metadata && in_alignments.metadata.sample_id)\n            {\n                output_prefix = in_alignments.metadata.sample_id;\n            }\n            else\n            {\n                output_prefix = in_alignments.path.split('/').pop().split('.')[0];\n            }          \n        }           \n        \n        cmd_line = cmd_line + \" && if [ $paired_end != 0 ]; then cmd='--FASTQ \" + output_prefix; \n        \n        if (interleave)\n        {\n            cmd_line = cmd_line + \".interleaved\" + output_ext + \"';\";\n        }\n        else\n        {\n            cmd_line = cmd_line + \".pe_1\" + output_ext;\n            cmd_line = cmd_line + \" --SECOND_END_FASTQ \" + output_prefix + \".pe_2\" + output_ext;\n            cmd_line = cmd_line + \" --UNPAIRED_FASTQ \" + output_prefix + \".unpaired\" + output_ext + \"';\";\n        }        \n        cmd_line = cmd_line + \" else cmd='--FASTQ \" + output_prefix  + \".se\" + output_ext + \"'; fi;\";\n        return cmd_line;\n    }\n    else\n    {\n        return \"cmd='--OUTPUT_DIR .'\";\n    }\n}\n\n",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job)\n    {\n        return \"--java-options\";\n    }\n    else {\n        return '';\n    }\n    \n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    else {\n        return \"\";\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 3
          },
          {
            "valueFrom": "SamToFastq",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          },
          {
            "valueFrom": "${\n        return '$cmd';\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 6
          }
        ],
        "sbg:modifiedOn": 1561548030,
        "sbg:publisher": "sbg",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "4.1.0.0",
        "sbg:revision": 15,
        "sbg:categories": [
          "Utilities",
          "BAM Processing"
        ]
      },
      "in": [
        {
          "source": "gatk_revertsam_4_1_0_0/out_alignments",
          "id": "in_alignments",
          "valueFrom": "$(self[0])"
        },
        {
          "id": "validation_stringency",
          "default": "SILENT"
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        }
      ],
      "sbg:y": -179.5,
      "label": "GATK SamToFastq",
      "sbg:x": -537.5,
      "out": [
        {
          "id": "out_reads"
        },
        {
          "id": "unmapped_reads"
        }
      ]
    },
    {
      "id": "sbg_extract_basename",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "veliborka_josipovic",
        "sbg:latestRevision": 1,
        "sbg:modifiedBy": "veliborka_josipovic",
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/sbg-extract-basename/5",
        "sbg:toolAuthor": "nemanja.vucic",
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": 1000,
            "coresMin": 1,
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/nikola_jovanovic/alpine:1",
            "class": "DockerRequirement"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "doc": "This tool is extracting basename root from a single file provided to the **Input file** port. This is performed using nameroot File property built into Common Workflow Language.",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:createdOn": 1554494620,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/sbg-extract-basename/1",
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:image_url": null,
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/sbg-extract-basename/5",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1554494620,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/sbg-extract-basename/4",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559741931,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/sbg-extract-basename/5",
            "sbg:modifiedBy": "veliborka_josipovic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:toolkit": "SBGTools",
        "label": "SBG Extract Nameroot",
        "sbg:content_hash": "a8ef1bf3f7e18a01bf36acc0ffbdfc977e17d1c916c1fda26063ece28c74c08d0",
        "outputs": [
          {
            "type": "string?",
            "doc": "Name generated with this app.",
            "outputBinding": {
              "glob": "out_name.txt",
              "outputEval": "${\n\treturn self[0].contents.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n}",
              "loadContents": true
            },
            "label": "Output name",
            "id": "out_name"
          }
        ],
        "sbg:id": "h-95792107/h-be45d28e/h-aaac2ccb/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": "File?",
            "label": "Input file",
            "doc": "File of any type.",
            "id": "in_file"
          }
        ],
        "sbg:contributors": [
          "veliborka_josipovic"
        ],
        "baseCommand": [
          "echo"
        ],
        "arguments": [
          {
            "valueFrom": "${\n    return inputs.in_file.nameroot + \" > out_name.txt\";\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 1
          }
        ],
        "sbg:modifiedOn": 1559741931,
        "sbg:publisher": "sbg",
        "sbg:toolkitVersion": "v1.0",
        "cwlVersion": "v1.0",
        "sbg:revision": 1
      },
      "in": [
        {
          "source": "in_alignments",
          "id": "in_file"
        }
      ],
      "sbg:y": -555.7025146484375,
      "label": "SBG Extract Nameroot",
      "sbg:x": -948.4229125976562,
      "out": [
        {
          "id": "out_name"
        }
      ]
    },
    {
      "id": "gatk_mergebamalignment_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 14,
        "sbg:modifiedBy": "nens",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk/"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
          },
          {
            "label": "Publications",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_MergeSamFiles.php"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 4096;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1;\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "The **GATK MergeBamAlignment** tool is used for merging BAM/SAM alignment info from a third-party aligner with the data in an unmapped BAM file, producing a third BAM file that has alignment data (from the aligner) and all the remaining data from the unmapped BAM.\n\nMany alignment tools still require FASTQ format input. The unmapped BAM may contain useful information that will be lost in the conversion to FASTQ (meta-data like sample alias, library, barcodes, etc... as well as read-level tags.) This tool takes an unaligned BAM with meta-data, and the aligned BAM produced by calling [SamToFastq](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_SamToFastq.php) and then passing the result to an aligner. It produces a new SAM file that includes all aligned and unaligned reads and also carries forward additional read attributes from the unmapped BAM (attributes that are otherwise lost in the process of converting to FASTQ). The resulting file will be valid for use by Picard and GATK tools. The output may be coordinate-sorted, in which case the tags, NM, MD, and UQ will be calculated and populated, or query-name sorted, in which case the tags will not be calculated or populated [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases\n\n* The **GATK MergeBamAlignment** tool requires a SAM or BAM file on its **Aligned BAM/SAM file** (`--ALIGNED_BAM`) input, original SAM or BAM file of unmapped reads, which must be in queryname order on its **Unmapped BAM/SAM file** (`--UNMAPPED_BAM`) input and a reference sequence on its **Reference** (`--REFERENCE_SEQUENCE`) input. The tool generates a single BAM/SAM file on its **Output merged BAM/SAM file** output.\n\n* Usage example:\n\n```\ngatk MergeBamAlignment \\\\\n      --ALIGNED_BAM aligned.bam \\\\\n      --UNMAPPED_BAM unmapped.bam \\\\\n      --OUTPUT merged.bam \\\\\n      --REFERENCE_SEQUENCE reference_sequence.fasta\n```\n\n###Changes Introduced by Seven Bridges\n\n* The output file name will be prefixed using the **Output prefix** parameter. In case **Output prefix** is not provided, output prefix will be the same as the Sample ID metadata from **Input SAM/BAM file**, if the Sample ID metadata exists. Otherwise, output prefix will be inferred from the **Input SAM/BAM file** filename. This way, having identical names of the output files between runs is avoided. Moreover,  **merged** will be added before the extension of the output file name. \n\n* The user has a possibility to specify the output file format using the **Output file format** argument. Otherwise, the output file format will be the same as the format of the input aligned file.\n\n###Common Issues and Important Notes\n\n* Note:  This is not a tool for taking multiple BAM/SAM files and creating a bigger file by merging them. For that use-case, see [MergeSamFiles](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_MergeSamFiles.php).\n\n###Performance Benchmarking\n\nBelow is a table describing runtimes and task costs of **GATK MergeBamAlignment** for a couple of different samples, executed on the AWS cloud instances:\n\n| Experiment type |  Aligned BAM/SAM size |  Unmapped BAM/SAM size | Duration |  Cost | Instance (AWS) | \n|:--------------:|:------------:|:--------:|:-------:|:---------:|:----------:|:------:|:------:|------:|\n|     RNA-Seq     |  1.4 GB |  1.9 GB |   9min   | ~0.06$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     |  4.0 GB |  5.7 GB |   20min   | ~0.13$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 6.6 GB | 9.5 GB |  32min  | ~0.21$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 13 GB | 19 GB |  1h 4min  | ~0.42$ | c4.2xlarge (8 CPUs) |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n###References\n\n[1] [GATK MergeBamAlignment](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_MergeBamAlignment.php)",
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/37",
        "sbg:createdOn": 1552666475,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-mergebamalignment-4-1-0-0/14",
        "sbg:image_url": null,
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:toolkit": "GATK",
        "sbg:content_hash": "a758b43167e957642f45a0aad07716ff3b8c8c6a379cf76b35f10b0a3f5a121b8",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1552666475,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/12",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554492767,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/23",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554720890,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/24",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999266,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/25",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1557734540,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/26",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558000585,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/27",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558017849,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/28",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558351570,
            "sbg:revision": 7,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/29",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558370509,
            "sbg:revision": 8,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/30",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558427482,
            "sbg:revision": 9,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/31",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558448356,
            "sbg:revision": 10,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/32",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558453788,
            "sbg:revision": 11,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/33",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1559750464,
            "sbg:revision": 12,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/34",
            "sbg:modifiedBy": "nemanja.vucic"
          },
          {
            "sbg:modifiedOn": 1560335266,
            "sbg:revision": 13,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/36",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1560336165,
            "sbg:revision": 14,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/37",
            "sbg:modifiedBy": "nens"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergebamalignment-4-1-0-0/37",
        "label": "GATK MergeBamAlignment",
        "sbg:contributors": [
          "uros_sipetic",
          "nens",
          "nemanja.vucic",
          "veliborka_josipovic"
        ],
        "outputs": [
          {
            "type": "File",
            "secondaryFiles": [
              "${\n    if (self.nameext == \".bam\" && inputs.create_index)\n    {\n        return [self.basename + \".bai\", self.nameroot + \".bai\"];\n    }\n    else {\n        return []; \n    }\n}"
            ],
            "label": "Output merged SAM or BAM file",
            "sbg:fileTypes": "SAM, BAM",
            "id": "out_alignments",
            "outputBinding": {
              "glob": "*am",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "Output merged SAM or BAM file."
          }
        ],
        "sbg:id": "h-72d132f4/h-8fee70f1/h-f578e9f3/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "add_mate_cigar",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "add_mate_cigar",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ADD_MATE_CIGAR",
              "position": 4
            },
            "doc": "Adds the mate CIGAR tag (MC) if true, does not if false.",
            "sbg:altPrefix": "-MC",
            "sbg:category": "Optional Arguments",
            "label": "Add mate CIGAR"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "add_pg_tag_to_reads",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "add_pg_tag_to_reads",
            "doc": "Add PG tag to each read in a SAM or BAM.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ADD_PG_TAG_TO_READS",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Add PG tag to reads"
          },
          {
            "type": "File[]",
            "sbg:toolDefaultValue": "null",
            "id": "in_alignments",
            "sbg:fileTypes": "BAM, SAM",
            "doc": "SAM or BAM file(s) with alignment data. Cannot be used in conjuction with argument(s) READ1_ALIGNED_BAM (R1_ALIGNED) READ2_ALIGNED_BAM (R2_ALIGNED).",
            "inputBinding": {
              "valueFrom": "${\n    var arr = [].concat(inputs.in_alignments);\n    if (arr.length == 1) \n    {\n        return \"--ALIGNED_BAM \" + arr[0].path;\n    }\n    else\n    {\n        var pe_1 = [];\n        var pe_2 = [];\n        var se = [];\n        for (var i in arr)\n        {\n            if (arr[i].metadata && arr[i].metadata.paired_end && arr[i].metadata.paired_end == 1)\n            {\n                pe_1.push(arr[i].path);\n            }\n            else if (arr[i].metadata && arr[i].metadata.paired_end && arr[i].metadata.paired_end == 2)\n            {\n                pe_2.push(arr[i].path);\n            }\n            else\n            {\n                se.push(arr[i].path);\n            }\n        }\n        \n        if (se.length > 0) \n        {\n            return \"--ALIGNED_BAM \" + se.join(\" --ALIGNED_BAM \");\n        } \n        else if (pe_1.length > 0 && pe_2.length > 0 && pe_1.length == pe_2.length) \n        {\n            return \"--READ1_ALIGNED_BAM \" + pe_1.join(' --READ1_ALIGNED_BAM ') + \" --READ2_ALIGNED_BAM \" + pe_2.join(' --READ2_ALIGNED_BAM ');\n        } \n        else \n        {\n            return \"\";\n        }\n            \n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Aligned BAM/SAM file"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "aligned_reads_only",
            "doc": "Whether to output only aligned reads.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ALIGNED_READS_ONLY",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Aligned reads only"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "aligner_proper_pair_flags",
            "doc": "Use the aligner's idea of what a proper pair is rather than computing in this program.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ALIGNER_PROPER_PAIR_FLAGS",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Aligner proper pair flags"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "attributes_to_remove",
            "doc": "Attributes from the alignment record that should be removed when merging. This overrides ATTRIBUTES_TO_RETAIN if they share common tags.",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--ATTRIBUTES_TO_REMOVE', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Attributes to remove"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "attributes_to_retain",
            "doc": "Reserved alignment attributes (tags starting with X, Y, or Z) that should be brought over from the alignment data when merging.",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--ATTRIBUTES_TO_RETAIN', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Attributes to retain"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "[OQ,U2]",
            "id": "attributes_to_reverse",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--ATTRIBUTES_TO_REVERSE', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Attributes on negative strand reads that need to be reversed.",
            "sbg:altPrefix": "-RV",
            "sbg:category": "Optional Arguments",
            "label": "Attributes to reverse"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "[E2,SQ]",
            "id": "attributes_to_reverse_complement",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--ATTRIBUTES_TO_REVERSE_COMPLEMENT', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Attributes on negative strand reads that need to be reverse complemented.",
            "sbg:altPrefix": "-RC",
            "sbg:category": "Optional Arguments",
            "label": "Attributes to reverse complement"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "clip_adapters",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "clip_adapters",
            "doc": "Whether to clip adapters where identified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--CLIP_ADAPTERS",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Clip adapters"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "clip_overlapping_reads",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "clip_overlapping_reads",
            "doc": "For paired reads, soft clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--CLIP_OVERLAPPING_READS",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Clip overlapping reads"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "compression_level",
            "doc": "Compression level for all compressed files created (e.g. BAM and VCF).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--COMPRESSION_LEVEL",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Compression level"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "create_index",
            "doc": "Whether to create a BAM index when writing a coordinate-sorted BAM file.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--CREATE_INDEX",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Create index"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "expected_orientations",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--EXPECTED_ORIENTATIONS', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "The expected orientation of proper read pairs. Replaces JUMP_SIZE. Cannot be used in conjuction with argument(s) JUMP_SIZE (JUMP).",
            "sbg:altPrefix": "-ORIENTATIONS",
            "sbg:category": "Optional Arguments",
            "label": "Expected orientations"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "include_secondary_alignments",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "include_secondary_alignments",
            "doc": "If false, do not write secondary alignments to output.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--INCLUDE_SECONDARY_ALIGNMENTS",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Include secondary alignments"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "is_bisulfite_sequence",
            "doc": "Whether the lane is bisulfite sequence (used when calculating the NM tag).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--IS_BISULFITE_SEQUENCE",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Is bisulfite sequence"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "jump_size",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--JUMP_SIZE",
              "position": 4
            },
            "doc": "The expected jump size (required if this is a jumping library). Deprecated. Use EXPECTED_ORIENTATIONS instead. Cannot be used in conjuction with argument(s) EXPECTED_ORIENTATIONS (ORIENTATIONS).",
            "sbg:altPrefix": "-JUMP",
            "sbg:category": "Optional Arguments",
            "label": "Jump size"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "[M5,LN]",
            "id": "matching_dictionary_tags",
            "doc": "List of Sequence Records tags that must be equal (if present) in the reference dictionary and in the aligned file. Mismatching tags will cause an error if in this list, and a warning otherwise.",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--MATCHING_DICTIONARY_TAGS', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Matching dictionary tags"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "max_insertions_or_deletions",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MAX_INSERTIONS_OR_DELETIONS",
              "position": 4
            },
            "doc": "The maximum number of insertions or deletions permitted for an alignment to be included. Alignments with more than this many insertions or deletions will be ignored. Set to -1 to allow any number of insertions or deletions.",
            "sbg:altPrefix": "-MAX_GAPS",
            "sbg:category": "Optional Arguments",
            "label": "Max insertions or deletions"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "500000",
            "id": "max_records_in_ram",
            "doc": "When writing files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort the file, and increases the amount of RAM needed.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MAX_RECORDS_IN_RAM",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Max records in RAM"
          },
          {
            "type": "int?",
            "id": "memory_overhead_per_job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "id": "memory_per_job",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "32",
            "id": "min_unclipped_bases",
            "doc": "If UNMAP_CONTAMINANT_READS is set, require this many unclipped bases or else the read will be marked as contaminant.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MIN_UNCLIPPED_BASES",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Min unclipped bases"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_run",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "paired_run",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PAIRED_RUN",
              "position": 4
            },
            "doc": "DEPRECATED. This argument is ignored and will be removed.",
            "sbg:altPrefix": "-PE",
            "sbg:category": "Optional Arguments",
            "label": "Paired run"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "primary_alignment_strategy",
                "symbols": [
                  "BestMapq",
                  "EarliestFragment",
                  "BestEndMapq",
                  "MostDistant"
                ]
              }
            ],
            "sbg:toolDefaultValue": "BestMapq",
            "id": "primary_alignment_strategy",
            "doc": "Strategy for selecting primary alignment when the aligner has provided more than one alignment for a pair or fragment, and none are marked as primary, more than one is marked as primary, or the primary alignment is filtered out for some reason. For all strategies, ties are resolved arbitrarily. Possible values: { BestMapq (expects that multiple alignments will be correlated with HI tag, and prefers the pair of alignments with the largest MAPQ, in the absence of a primary selected by the aligner.) EarliestFragment (prefers the alignment which maps the earliest base in the read. Note that EarliestFragment may not be used for paired reads.) BestEndMapq (appropriate for cases in which the aligner is not pair-aware, and does not output the HI tag. It simply picks the alignment for each end with the highest MAPQ, and makes those alignments primary, regardless of whether the two alignments make sense together.) MostDistant (appropriate for a non-pair-aware aligner. Picks the alignment pair with the largest insert size. If all alignments would be chimeric, it picks the alignments for each end with the best MAPQ. ) }.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PRIMARY_ALIGNMENT_STRATEGY",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Primary alignment strategy"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "program_group_command_line",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PROGRAM_GROUP_COMMAND_LINE",
              "position": 4
            },
            "doc": "The command line of the program group (if not supplied by the aligned file).",
            "sbg:altPrefix": "-PG_COMMAND",
            "sbg:category": "Optional Arguments",
            "label": "Program group command line"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "program_group_name",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PROGRAM_GROUP_NAME",
              "position": 4
            },
            "doc": "The name of the program group (if not supplied by the aligned file).",
            "sbg:altPrefix": "-PG_NAME",
            "sbg:category": "Optional Arguments",
            "label": "Program group name"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "program_group_version",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PROGRAM_GROUP_VERSION",
              "position": 4
            },
            "doc": "The version of the program group (if not supplied by the aligned file).",
            "sbg:altPrefix": "-PG_VERSION",
            "sbg:category": "Optional Arguments",
            "label": "Program group version"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "program_record_id",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PROGRAM_RECORD_ID",
              "position": 4
            },
            "doc": "The program group ID of the aligner (if not supplied by the aligned file).",
            "sbg:altPrefix": "-PG",
            "sbg:category": "Optional Arguments",
            "label": "Program record id"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "read1_trim",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--READ1_TRIM",
              "position": 4
            },
            "doc": "The number of bases trimmed from the beginning of read 1 prior to alignment.",
            "sbg:altPrefix": "-R1_TRIM",
            "sbg:category": "Optional Arguments",
            "label": "Read1 trim"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "read2_trim",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--READ2_TRIM",
              "position": 4
            },
            "doc": "The number of bases trimmed from the beginning of read 2 prior to alignment.",
            "sbg:altPrefix": "-R2_TRIM",
            "sbg:category": "Optional Arguments",
            "label": "Read2 trim"
          },
          {
            "type": "File",
            "secondaryFiles": [
              ".fai",
              "^.dict"
            ],
            "id": "in_reference",
            "sbg:fileTypes": "FASTA, FA",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--REFERENCE_SEQUENCE",
              "position": 4
            },
            "doc": "Reference sequence file.",
            "sbg:altPrefix": "-R",
            "sbg:category": "Required Arguments",
            "label": "Reference"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "sort_order",
                "symbols": [
                  "unsorted",
                  "queryname",
                  "coordinate",
                  "duplicate",
                  "unknown"
                ]
              }
            ],
            "sbg:toolDefaultValue": "coordinate",
            "id": "sort_order",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SORT_ORDER",
              "position": 4
            },
            "doc": "The order in which the merged reads should be output.",
            "sbg:altPrefix": "-SO",
            "sbg:category": "Optional Arguments",
            "label": "Sort order"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "unmap_contaminant_reads",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--UNMAP_CONTAMINANT_READS",
              "position": 4
            },
            "doc": "Detect reads originating from foreign organisms (e.g. bacterial DNA in a non-bacterial sample), and unmap + label those reads accordingly.",
            "sbg:altPrefix": "-UNMAP_CONTAM",
            "sbg:category": "Optional Arguments",
            "label": "Unmap contaminant reads"
          },
          {
            "type": "File",
            "id": "unmapped_bam",
            "sbg:fileTypes": "BAM, SAM",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--UNMAPPED_BAM",
              "position": 4
            },
            "doc": "Original SAM or BAM file of unmapped reads, which must be in queryname order.",
            "sbg:altPrefix": "-UNMAPPED",
            "sbg:category": "Required Arguments",
            "label": "Unmapped BAM/SAM file"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unmapped_read_strategy",
                "symbols": [
                  "COPY_TO_TAG",
                  "DO_NOT_CHANGE",
                  "MOVE_TO_TAG"
                ]
              }
            ],
            "sbg:toolDefaultValue": "DO_NOT_CHANGE",
            "id": "unmapped_read_strategy",
            "doc": "How to deal with alignment information in reads that are being unmapped (e.g. due to cross-species contamination.) Currently ignored unless UNMAP_CONTAMINANT_READS = true",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--UNMAPPED_READ_STRATEGY",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Unmapped read strategy"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "validation_stringency",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "STRICT",
            "id": "validation_stringency",
            "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--VALIDATION_STRINGENCY",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Validation stringency"
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output file name prefix.",
            "label": "Output prefix",
            "sbg:category": "Optional Parameters"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_file_format",
                "symbols": [
                  "bam",
                  "sam"
                ]
              }
            ],
            "id": "output_file_format",
            "doc": "Output file format",
            "label": "Output file format",
            "sbg:category": "Optional parameters"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform Options",
            "doc": "CPU per job."
          }
        ],
        "cwlVersion": "v1.0",
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job)\n    {\n        return \"--java-options\";\n    }\n    else {\n        return '';\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    else {\n        return ''; \n        \n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "MergeBamAlignment",
            "shellQuote": false,
            "position": 3
          },
          {
            "valueFrom": "${\n    var in_alignments = [].concat(inputs.in_alignments);\n    var output_ext = inputs.output_file_format ? inputs.output_file_format : in_alignments[0].path.split('.').pop();\n    var output_prefix = '';\n    var file1_name = ''; \n    var file2_name = ''; \n    if (inputs.output_prefix)\n    {\n        output_prefix = inputs.output_prefix;\n    }\n    else \n    {\n        if (in_alignments.length > 1)\n        {\n            in_alignments.sort(function(file1, file2) {\n                file1_name = file1.path.split('/').pop().toUpperCase();\n                file2_name = file2.path.split('/').pop().toUpperCase();\n                if (file1_name < file2_name) {\n                    return -1;\n                }\n                if (file1_name > file2_name) {\n                    return 1;\n                }\n                // names must be equal\n                return 0;\n            });\n        }\n        \n        var in_alignments_first =  in_alignments[0];\n        if (in_alignments_first.metadata && in_alignments_first.metadata.sample_id)\n        {\n            output_prefix = in_alignments_first.metadata.sample_id;\n        }\n        else \n        {\n            output_prefix = in_alignments_first.path.split('/').pop().split('.')[0];\n        }\n        \n        if (in_alignments.length > 1)\n        {\n            output_prefix = output_prefix + \".\" + in_alignments.length;\n        }\n    }\n    \n    return \"--OUTPUT \" + output_prefix + \".merged.\" + output_ext;\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          }
        ],
        "sbg:modifiedOn": 1560336165,
        "sbg:publisher": "sbg",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "4.1.0.0",
        "sbg:revision": 14,
        "sbg:categories": [
          "Utilities",
          "BAM Processing"
        ]
      },
      "in": [
        {
          "source": [
            "star_align_2_5_3a_modified/out_aligned_reads"
          ],
          "id": "in_alignments",
          "valueFrom": "$([self])"
        },
        {
          "id": "include_secondary_alignments",
          "default": "false"
        },
        {
          "id": "paired_run",
          "default": "false"
        },
        {
          "source": "in_reference",
          "id": "in_reference"
        },
        {
          "source": "gatk_revertsam_4_1_0_0/out_alignments",
          "id": "unmapped_bam",
          "valueFrom": "$(self[0])"
        },
        {
          "id": "validation_stringency",
          "default": "SILENT"
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        }
      ],
      "sbg:y": -137.82554626464844,
      "label": "GATK MergeBamAlignment",
      "sbg:x": 164.83518981933594,
      "out": [
        {
          "id": "out_alignments"
        }
      ]
    },
    {
      "id": "gatk_markduplicates_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 10,
        "sbg:modifiedBy": "nemanja.vucic",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk/"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
          },
          {
            "label": "Publications",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_markduplicates_MarkDuplicates.php"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 4096;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1;\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "The **GATK  MarkDuplicates** tool identifies duplicate reads in a BAM or SAM file.\n\nThis tool locates and tags duplicate reads in a BAM or SAM file, where duplicate reads are defined as originating from a single fragment of DNA. Duplicates can arise during sample preparation e.g. library construction using PCR. Duplicate reads can also result from a single amplification cluster, incorrectly detected as multiple clusters by the optical sensor of the sequencing instrument. These duplication artifacts are referred to as optical duplicates [1].\n\nThe MarkDuplicates tool works by comparing sequences in the 5 prime positions of both reads and read-pairs in the SAM/BAM file. The **Barcode tag** (`--BARCODE_TAG`) option is available to facilitate duplicate marking using molecular barcodes. After duplicate reads are collected, the tool differentiates the primary and duplicate reads using an algorithm that ranks reads by the sums of their base-quality scores (default method).\n\n\n###Common Use Cases\n\n* The **GATK MarkDuplicates** tool requires the BAM or SAM file on its **Input BAM/SAM file** (`--INPUT`) input. The tool generates a new SAM or BAM file on its **Output BAM/SAM** output, in which duplicates have been identified in the SAM flags field for each read. Duplicates are marked with the hexadecimal value of 0x0400, which corresponds to a decimal value of 1024. If you are not familiar with this type of annotation, please see the following [blog post](https://software.broadinstitute.org/gatk/blog?id=7019) for additional information. **MarkDuplicates** also produces a metrics file on its **Output metrics file** output, indicating the numbers of duplicates for both single and paired end reads.\n\n* The program can take either coordinate-sorted or query-sorted inputs, however the behavior is slightly different. When the input is coordinate-sorted, unmapped mates of mapped records and supplementary/secondary alignments are not marked as duplicates. However, when the input is query-sorted (actually query-grouped), then unmapped mates and secondary/supplementary reads are not excluded from the duplication test and can be marked as duplicate reads.\n\n* If desired, duplicates can be removed using the **Remove duplicates** (`--REMOVE_DUPLICATES`) and **Remove sequencing duplicates** ( `--REMOVE_SEQUENCING_DUPLICATES`) options.\n\n* Although the bitwise flag annotation indicates whether a read was marked as a duplicate, it does not identify the type of duplicate. To do this, a new tag called the duplicate type (DT) tag was recently added as an optional output of a SAM/BAM file. Invoking the **Tagging policy** ( `--TAGGING_POLICY`) option, you can instruct the program to mark all the duplicates (All), only the optical duplicates (OpticalOnly), or no duplicates (DontTag). The records within the output SAM/BAM file will have values for the 'DT' tag (depending on the invoked **TAGGING_POLICY** option), as either library/PCR-generated duplicates (LB), or sequencing-platform artifact duplicates (SQ). \n\n* This tool uses the **Read name regex** (`--READ_NAME_REGEX`) and the **Optical duplicate pixel distance** (`--OPTICAL_DUPLICATE_PIXEL_DISTANCE`) options as the primary methods to identify and differentiate duplicate types. Set **READ_NAME_REGEX** to null to skip optical duplicate detection, e.g. for RNA-seq or other data where duplicate sets are extremely large and estimating library complexity is not an aim. Note that without optical duplicate counts, library size estimation will be inaccurate.\n\n* Usage example:\n\n```\ngatk MarkDuplicates \\\n      --INPUT input.bam \\\n      --OUTPUT marked_duplicates.bam \\\n      --METRICS_FILE marked_dup_metrics.txt\n```\n\n###Changes Introduced by Seven Bridges\n\n* All output files will be prefixed using the **Output prefix** parameter. In case **Output prefix** is not provided, output prefix will be the same as the Sample ID metadata from the **Input SAM/BAM file**, if the Sample ID metadata exists. Otherwise, output prefix will be inferred from the **Input SAM/BAM** filename. This way, having identical names of the output files between runs is avoided. Moreover,  **dedupped** will be added before the extension of the output file name. \n\n* The user has a possibility to specify the output file format using the **Output file format** option. Otherwise, the output file format will be the same as the format of the input file.\n\n###Common Issues and Important Notes\n\n* None\n\n###Performance Benchmarking\n\nBelow is a table describing runtimes and task costs of **GATK MarkDuplicates** for a couple of different samples, executed on the AWS cloud instances:\n\n| Experiment type |  Input size | Duration |  Cost | Instance (AWS) | \n|:--------------:|:------------:|:--------:|:-------:|:---------:|\n|     RNA-Seq     |  1.8 GB |   3min   | ~0.02$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     |  5.3 GB |   9min   | ~0.06$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 8.8 GB |  16min  | ~0.11$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 17 GB |  30min  | ~0.20$ | c4.2xlarge (8 CPUs) |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n###References\n\n[1] [GATK MarkDuplicates](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_sam_markduplicates_MarkDuplicates.php)",
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/24",
        "sbg:createdOn": 1552668097,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-markduplicates-4-1-0-0/10",
        "sbg:image_url": null,
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:toolkit": "GATK",
        "sbg:content_hash": "a2917fa62da73641aaeec51d2063d913022de4659f044ad25153832f2508dd5b7",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1552668097,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/9",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554492835,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/13",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554720881,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/14",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999255,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/15",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1555945044,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/17",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1557734534,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/18",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558000580,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/19",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558351536,
            "sbg:revision": 7,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/21",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558447931,
            "sbg:revision": 8,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/22",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1559750423,
            "sbg:revision": 9,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/23",
            "sbg:modifiedBy": "nemanja.vucic"
          },
          {
            "sbg:modifiedOn": 1559751034,
            "sbg:revision": 10,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/24",
            "sbg:modifiedBy": "nemanja.vucic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-markduplicates-4-1-0-0/24",
        "label": "GATK MarkDuplicates",
        "sbg:contributors": [
          "uros_sipetic",
          "nens",
          "nemanja.vucic",
          "veliborka_josipovic"
        ],
        "outputs": [
          {
            "type": "File?",
            "secondaryFiles": [
              "${\n    if (inputs.create_index)\n    {\n        return self.nameroot + \".bai\";\n    }\n    else {\n    \n    return '';     \n    }\n    \n}"
            ],
            "label": "Output BAM/SAM file",
            "sbg:fileTypes": "BAM, SAM",
            "id": "out_alignments",
            "outputBinding": {
              "glob": "*am",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "Output BAM/SAM file which contains marked records."
          },
          {
            "type": "File",
            "label": "Output metrics file",
            "sbg:fileTypes": "METRICS",
            "id": "output_metrics",
            "outputBinding": {
              "glob": "*metrics",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "Output duplication metrics file."
          }
        ],
        "sbg:id": "h-c824d200/h-1346fab9/h-f22aeccc/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "add_pg_tag_to_reads",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "add_pg_tag_to_reads",
            "doc": "Add PG tag to each read in a SAM or BAM file.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ADD_PG_TAG_TO_READS",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Add PG tag to reads"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "assume_sort_order",
                "symbols": [
                  "unsorted",
                  "queryname",
                  "coordinate",
                  "duplicate",
                  "unknown"
                ]
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "assume_sort_order",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ASSUME_SORT_ORDER",
              "position": 4
            },
            "doc": "If not null, assume that the input file has this order even if the header says otherwise. Cannot be used in conjuction with argument(s) ASSUME_SORTED (AS).",
            "sbg:altPrefix": "-ASO",
            "sbg:category": "Optional Arguments",
            "label": "Assume sort order"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "assume_sorted",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ASSUME_SORTED",
              "position": 4
            },
            "doc": "If true, assume that the input file is coordinate sorted even if the header says otherwise. Deprecated, used ASSUME_SORT_ORDER=coordinate instead. Exclusion: This argument cannot be used at the same time as ASSUME_SORT_ORDER (ASO).",
            "sbg:altPrefix": "-AS",
            "sbg:category": "Optional arguments",
            "label": "Assume sorted"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "barcode_tag",
            "doc": "Barcode SAM tag (ex. BC for 10x genomics).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--BARCODE_TAG",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Barcode tag"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "clear_dt",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "clear_dt",
            "doc": "Clear DT tag from input SAM records. Should be set to false if input SAM doesn't have this tag.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--CLEAR_DT",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Clear DT"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "comment",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--COMMENT', self[i]);\n            \n        }\n        return cmd.join(' ');\n    }\n}",
              "shellQuote": false,
              "position": 4
            },
            "doc": "Comment(s) to include in the output file's header.",
            "sbg:altPrefix": "-CO",
            "sbg:category": "Optional Arguments",
            "label": "Comment"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "compression_level",
            "doc": "Compression level for all compressed files created (e.g. BAM and VCF).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--COMPRESSION_LEVEL",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Compression level"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "create_index",
            "doc": "Whether to create a BAM index when writing a coordinate-sorted BAM file.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--CREATE_INDEX",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Create index"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "duplex_umi",
            "doc": "Treat UMIs as being duplex stranded. This option requires that the UMI consist of two equal length strings that are separated by a hyphen (e.g. 'ATC-GTC'). Reads are considered duplicates if, in addition to standard definition, have identical normalized UMIs. A UMI from the 'bottom' strand is normalized by swapping its content around the hyphen (eg. ATC-GTC becomes GTC-ATC). A UMI from the 'top' strand is already normalized as it is. Both reads from a read pair considered top strand if the read 1 unclipped 5' coordinate is less than the read 2 unclipped 5' coordinate. All chimeric reads and read fragments are treated as having come from the top strand. With this option it is required that the BARCODE_TAG hold non-normalized UMIs.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--DUPLEX_UMI",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Duplex UMI"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "duplicate_scoring_strategy",
                "symbols": [
                  "SUM_OF_BASE_QUALITIES",
                  "TOTAL_MAPPED_REFERENCE_LENGTH",
                  "RANDOM"
                ]
              }
            ],
            "sbg:toolDefaultValue": "SUM_OF_BASE_QUALITIES",
            "id": "duplicate_scoring_strategy",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--DUPLICATE_SCORING_STRATEGY",
              "position": 4
            },
            "doc": "The scoring strategy for choosing the non-duplicate among candidates.",
            "sbg:altPrefix": "-DS",
            "sbg:category": "Optional Arguments",
            "label": "Duplicate scoring strategy"
          },
          {
            "type": "File[]",
            "id": "in_alignments",
            "sbg:fileTypes": "BAM, SAM",
            "inputBinding": {
              "valueFrom": "${\n    var in_files = [].concat(inputs.in_alignments);\n    if (in_files)\n    {\n        var cmd = [];\n        for (var i = 0; i < in_files.length; i++) \n        {\n            cmd.push('--INPUT', in_files[i].path);\n        }\n        return cmd.join(' ');\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Input SAM or BAM files to analyze. Must be coordinate sorted.",
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "label": "Input BAM/SAM file"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "8000",
            "id": "max_file_handles_for_read_ends_map",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MAX_FILE_HANDLES_FOR_READ_ENDS_MAP",
              "position": 4
            },
            "doc": "Maximum number of file handles to keep open when spilling read ends to disk. Set this number a little lower than the per-process maximum number of file that may be open. This number can be found by executing the 'ulimit -n' command on a unix system.",
            "sbg:altPrefix": "-MAX_FILE_HANDLES",
            "sbg:category": "Optional Arguments",
            "label": "Max file handles for read ends map"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "300000",
            "id": "max_optical_duplicate_set_size",
            "doc": "This number is the maximum size of a set of duplicate reads for which we will attempt to determine which are optical duplicates. Please be aware that if you raise this value too high and do encounter a very large set of duplicate reads, it will severely affect the runtime of this tool. To completely disable this check, set the value to -1.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MAX_OPTICAL_DUPLICATE_SET_SIZE",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Max optical duplicate set size"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "500000",
            "id": "max_records_in_ram",
            "doc": "When writing files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort the file, and increases the amount of RAM needed.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MAX_RECORDS_IN_RAM",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Max records in RAM"
          },
          {
            "type": "int?",
            "id": "memory_overhead_per_job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "id": "memory_per_job",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "molecular_identifier_tag",
            "doc": "SAM tag to uniquely identify the molecule from which a read was derived. Use of this option requires that the BARCODE_TAG option be set to a non null value.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MOLECULAR_IDENTIFIER_TAG",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Molecular identifier tag"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "100",
            "id": "optical_duplicate_pixel_distance",
            "doc": "The maximum offset between two duplicate clusters in order to consider them optical duplicates. The default is appropriate for unpatterned versions of the illumina platform. For the patterned flowcell models, 2500 is moreappropriate. For other platforms and models, users should experiment to find what works best.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--OPTICAL_DUPLICATE_PIXEL_DISTANCE",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Optical duplicate pixel distance"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "program_group_command_line",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PROGRAM_GROUP_COMMAND_LINE",
              "position": 4
            },
            "doc": "Value of CL tag of PG record to be created. If not supplied the command line will be detected automatically.",
            "sbg:altPrefix": "-PG_COMMAND",
            "sbg:category": "Optional Arguments",
            "label": "Program group command line"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "MarkDuplicates",
            "id": "program_group_name",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PROGRAM_GROUP_NAME",
              "position": 4
            },
            "doc": "Value of PN tag of PG record to be created.",
            "sbg:altPrefix": "-PG_NAME",
            "sbg:category": "Optional Arguments",
            "label": "Program group name"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "program_group_version",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PROGRAM_GROUP_VERSION",
              "position": 4
            },
            "doc": "Value of VN tag of PG record to be created. If not specified, the version will be detected automatically.",
            "sbg:altPrefix": "-PG_VERSION",
            "sbg:category": "Optional Arguments",
            "label": "Program group version"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "MarkDuplicates",
            "id": "program_record_id",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PROGRAM_RECORD_ID",
              "position": 4
            },
            "doc": "The program record ID for the @PG record(s) created by this program. Set to null to disable PG record creation.  This string may have a suffix appended to avoid collision with other program record IDs.",
            "sbg:altPrefix": "-PG",
            "sbg:category": "Optional Arguments",
            "label": "Program record id"
          },
          {
            "type": "string?",
            "id": "read_name_regex",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--READ_NAME_REGEX",
              "position": 4
            },
            "label": "Read name regex",
            "sbg:category": "Optional Arguments",
            "doc": "MarkDuplicates can use the tile and cluster positions to estimate the rate of optical duplication in addition to the dominant source of duplication, PCR, to provide a more accurate estimation of library size. By default (with no READ_NAME_REGEX specified), MarkDuplicates will attempt to extract coordinates using a split on ':' (see note below). Set READ_NAME_REGEX to 'null' to disable optical duplicate detection. Note that without optical duplicate counts, library size estimation will be less accurate. If the read name does not follow a standard illumina colon-separation convention, but does contain tile and x,y coordinates, a regular expression can be specified to extract three variables: tile/region, x coordinate and y coordinate from a read name. The regular expression must contain three capture groups for the three variables, in order. It must match the entire read name. e.g. if field names were separated by semi-colon (';') this example regex could be specified (?:.*;)?([0-9]+)[^;]*;([0-9]+)[^;]*;([0-9]+)[^;]*$ Note that if no READ_NAME_REGEX is specified, the read name is split on ':'. For 5 element names, the 3rd, 4th and 5th elements are assumed to be tile, x and y values. For 7 element names (CASAVA 1.8), the 5th, 6th, and 7th elements are assumed to be tile, x and y values."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "read_one_barcode_tag",
            "doc": "Read one barcode SAM tag (ex. BX for 10x Genomics).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--READ_ONE_BARCODE_TAG",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Read one barcode tag"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "read_two_barcode_tag",
            "doc": "Read two barcode SAM tag (ex. BX for 10x Genomics).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--READ_TWO_BARCODE_TAG",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Read two barcode tag"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "remove_duplicates",
            "doc": "If true do not write duplicates to the output file instead of writing them with appropriate flags set.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--REMOVE_DUPLICATES",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Remove duplicates"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "remove_sequencing_duplicates",
            "doc": "If true remove 'optical' duplicates and other duplicates that appear to have arisen from the sequencing process instead of the library preparation process, even if REMOVE_DUPLICATES is false. If REMOVE_DUPLICATES is true, all duplicates are removed and this option is ignored.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--REMOVE_SEQUENCING_DUPLICATES",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Remove sequencing duplicates"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.25",
            "id": "sorting_collection_size_ratio",
            "doc": "This number, plus the maximum RAM available to the JVM, determine the memory footprint used by some of the sorting collections. If you are running out of memory, try reducing this number.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SORTING_COLLECTION_SIZE_RATIO",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Sorting collection size ratio"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "tag_duplicate_set_members",
            "doc": "If a read appears in a duplicate set, add two tags. The first tag, DUPLICATE_SET_SIZE_TAG (DS), indicates the size of the duplicate set. The smallest possible DS value is 2 which occurs when two reads map to the same portion of the reference only one of which is marked as duplicate. The second tag, DUPLICATE_SET_INDEX_TAG (DI), represents a unique identifier for the duplicate set to which the record belongs. This identifier is the index-in-file of the representative read that was selected out of the duplicate set.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--TAG_DUPLICATE_SET_MEMBERS",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Tag duplicate set members"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "tagging_policy",
                "symbols": [
                  "DontTag",
                  "OpticalOnly",
                  "All"
                ]
              }
            ],
            "sbg:toolDefaultValue": "DontTag",
            "id": "tagging_policy",
            "doc": "Determines how duplicate types are recorded in the DT optional attribute.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--TAGGING_POLICY",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Tagging policy"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "validation_stringency",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "STRICT",
            "id": "validation_stringency",
            "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--VALIDATION_STRINGENCY",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Validation stringency"
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output file name prefix.",
            "label": "Output prefix",
            "sbg:category": "Optional Arguments"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_file_format",
                "symbols": [
                  "bam",
                  "sam"
                ]
              }
            ],
            "sbg:toolDefaultValue": "BAM",
            "id": "output_file_format",
            "label": "Output file format",
            "sbg:category": "Optional Arguments",
            "doc": "Output file format"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform Options",
            "doc": "This input allows a user to set the desired CPU requirement when running a tool or adding it to a workflow."
          }
        ],
        "cwlVersion": "v1.0",
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job)\n    {\n        return \"--java-options\";\n    }\n    else {\n        return ''; \n    }\n}\n    ",
            "shellQuote": false,
            "prefix": "",
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    else {\n        return ''; \n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "MarkDuplicates",
            "shellQuote": false,
            "position": 3
          },
          {
            "valueFrom": "${\n    var in_alignments = inputs.in_alignments;\n    var output_ext = inputs.output_file_format ? \".\" + inputs.output_file_format : in_alignments[0].nameext;\n    var output_prefix = '';\n    if (inputs.output_prefix)\n    {\n        output_prefix = inputs.output_prefix;\n    }\n    else\n    {\n        if (in_alignments[0].metadata && in_alignments[0].metadata.sample_id)\n        {\n            output_prefix = in_alignments[0].metadata.sample_id;\n        }\n        else\n        {\n            output_prefix = in_alignments[0].nameroot.split('.')[0];\n        }\n    }\n    return \"--OUTPUT \" + output_prefix + \".dedupped\" + output_ext;\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          },
          {
            "valueFrom": "${\n    var in_alignments = inputs.in_alignments;\n    var output_prefix = '';  \n\n    if (inputs.output_prefix)\n    {\n        output_prefix = inputs.output_prefix;\n    }\n    else\n    {\n        if (in_alignments[0].metadata && in_alignments[0].metadata.sample_id)\n        {\n            output_prefix = in_alignments[0].metadata.sample_id;\n        }\n        else\n        {\n            output_prefix = in_alignments[0].nameroot.split('.')[0];\n        }\n    }\n    return \"--METRICS_FILE \" + output_prefix + \".dedupped.metrics\";\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          }
        ],
        "sbg:modifiedOn": 1559751034,
        "sbg:publisher": "sbg",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "4.1.0.0",
        "sbg:revision": 10,
        "sbg:categories": [
          "Utilities",
          "BAM Processing"
        ]
      },
      "in": [
        {
          "id": "create_index",
          "default": true
        },
        {
          "source": [
            "gatk_mergebamalignment_4_1_0_0/out_alignments"
          ],
          "id": "in_alignments",
          "valueFrom": "$([self])"
        },
        {
          "id": "validation_stringency",
          "default": "SILENT"
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        }
      ],
      "sbg:y": -23.46544647216797,
      "label": "GATK MarkDuplicates",
      "sbg:x": 429.13018798828125,
      "out": [
        {
          "id": "out_alignments"
        },
        {
          "id": "output_metrics"
        }
      ]
    },
    {
      "id": "gatk_splitncigarreads_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 4,
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-splitncigarreads-4-1-0-0/23",
        "sbg:toolAuthor": "Broad Institute",
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 4096;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "The **GATK SplitNCigarReads** tool splits reads that contain Ns in their CIGAR string (e.g. spanning splicing events in RNAseq data) from the input alignment file and outputs an alignment file with reads split at N CIGAR elements and CIGAR strings updated. \n\nThis tool identifies all N cigar elements in sequence reads, and creates k+1 new reads (where k is the number of N cigar elements) that correspond to the segments of the original read beside/between the splicing events represented by the Ns in the original CIGAR. The first read includes the bases that are to the left of the first N element, while the part of the read that is to the right of the N (including the Ns) is hard clipped, and so on for the rest of the new reads [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases\n\n* The **GATK SplitNCigarReads** tool requires a BAM/SAM/CRAM file on its **Input BAM/SAM/CRAM file** (`--input`) input and a reference file on its **Reference** (`--reference`) input. The tool generates a single BAM file on its **Output split BAM/SAM/CRAM file** output by default, or SAM or CRAM if the input file is SAM or CRAM, respectively.\n\n* Usage example:\n\n```\n    gatk SplitNCigarReads \\\n      --reference Homo_sapiens_assembly38.fasta \\\n      --input input.bam \\\n      --output output.bam\n```\n\n###Changes Introduced by Seven Bridges\n\n* The output file name will be prefixed using the **Output prefix** parameter. In case **Output prefix** is not provided, output prefix will be the same as the Sample ID metadata from **Input SAM/BAM/CRAM file**, if the Sample ID metadata exists. Otherwise, output prefix will be inferred from the **Input SAM/BAM/CRAM file** filename. This way, having identical names of the output files between runs is avoided. Moreover,  **split** will be added right before the extension of the output file name. \n\n* The user has a possibility to specify the output file format using the **Output file format** argument. Otherwise, the output file format will be the same as the format of the input file.\n\n* **Include intervals** (`--intervals`) option is divided into **Include intervals string** and **Include intervals file** options.\n\n* **Exclude intervals** (`--exclude-intervals`) option is divided into **Exclude intervals string** and **Exclude intervals file** options.\n\n###Common Issues and Important Notes\n\n* Note: The **AllowAllReadsReadFilter** read filter (do not filter out any read) is automatically applied to the data by the Engine before processing by SplitNCigarReads.\n* Note: If **Read filter** (`--read-filter`) option is set to \"LibraryReadFilter\", **Library** (`--library`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"PlatformReadFilter\", **Platform filter name** (`--platform-filter-name`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to\"PlatformUnitReadFilter\", **Black listed lanes** (`--black-listed-lanes`) option must be set to some value. \n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadGroupBlackListReadFilter\", **Read group black list** (`--read-group-black-list`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadGroupReadFilter\", **Keep read group** (`--keep-read-group`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadLengthReadFilter\", **Max read length** (`--max-read-length`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadNameReadFilter\", **Read name** (`--read-name`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadStrandFilter\", **Keep reverse strand only** (`--keep-reverse-strand-only`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"SampleReadFilter\", **Sample** (`--sample`) option must be set to some value.\n\n###Performance Benchmarking\n\nBelow is a table describing runtimes and task costs of **GATK SplitNCigarReads** for a couple of different samples, executed on the AWS cloud instances:\n\n| Experiment type |  Input size | Duration |  Cost | Instance (AWS) | \n|:--------------:|:------------:|:--------:|:-------:|:---------:|\n|     RNA-Seq     |  1.9 GB |   29min   | ~0.19$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     |  5.4 GB |   1h 10min   | ~0.46$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 8.8 GB |  2h 2min  | ~0.80$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 17 GB |  4h 15min  | ~1.69$ | c4.2xlarge (8 CPUs) |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n###References\n\n[1] [GATK SplitNCigarReads](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/org_broadinstitute_hellbender_tools_walkers_rnaseq_SplitNCigarReads.php)",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:createdOn": 1552920664,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-splitncigarreads-4-1-0-0/4",
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:image_url": null,
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-splitncigarreads-4-1-0-0/23",
        "sbg:modifiedBy": "veliborka_josipovic",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1552920664,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-splitncigarreads-4-1-0-0/9",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554492879,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-splitncigarreads-4-1-0-0/14",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554720873,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-splitncigarreads-4-1-0-0/15",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999310,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-splitncigarreads-4-1-0-0/16",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559734483,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-splitncigarreads-4-1-0-0/23",
            "sbg:modifiedBy": "veliborka_josipovic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:toolkit": "GATK",
        "label": "GATK SplitNCigarReads",
        "sbg:content_hash": "a4e717ec3b368b23d87ae86adfbfa07ac7dea02ebd2082ed86f9874d2a8fe4073",
        "outputs": [
          {
            "type": "File?",
            "secondaryFiles": [
              "${\n    var output_ext = self.nameext;\n    if (output_ext == \".bam\")\n    {\n        return self.nameroot + \".bai\";\n    }\n    else if (output_ext == \".cram\")\n    {\n        return self.nameroot + \".crai\";\n    }\n}"
            ],
            "label": "Output split BAM/SAM/CRAM file",
            "sbg:fileTypes": "BAM, SAM, CRAM",
            "id": "out_alignments",
            "outputBinding": {
              "glob": "*am",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "Output BAM/SAM/CRAM file with reads split at N CIGAR elements and CIGAR strings updated."
          }
        ],
        "sbg:id": "h-e8e19a9b/h-11fe3172/h-e0dc209d/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "add_output_sam_program_record",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "add_output_sam_program_record",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--add-output-sam-program-record",
              "position": 4
            },
            "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files.",
            "sbg:altPrefix": "-add-output-sam-program-record",
            "sbg:category": "Optional Arguments",
            "label": "Add output SAM program record"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "ambig_filter_bases",
            "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjuction with argument(s) maxAmbiguousBaseFraction. Valid only if \"AmbiguousBaseReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ambig-filter-bases",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Ambig filter bases"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.05",
            "id": "ambig_filter_frac",
            "doc": "Threshold fraction of ambiguous bases. Cannot be used in conjuction with argument(s) maxAmbiguousBases. Valid only if \"AmbiguousBaseReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ambig-filter-frac",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Ambig filter frac"
          },
          {
            "type": "string[]?",
            "id": "black_listed_lanes",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--black-listed-lanes', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "label": "Black listed lanes",
            "sbg:category": "Conditional Arguments",
            "doc": "Platform unit (PU) to filter out. This argument must be specified at least once. Valid only if \"PlatformUnitReadFilter\" is specified."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "create_output_bam_index",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "create_output_bam_index",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--create-output-bam-index",
              "position": 4
            },
            "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file.",
            "sbg:altPrefix": "-OBI",
            "sbg:category": "Optional Arguments",
            "label": "Create output BAM/CRAM index"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "disable_read_filter",
                  "symbols": [
                    "AlignmentAgreesWithHeaderReadFilter",
                    "AllowAllReadsReadFilter",
                    "AmbiguousBaseReadFilter",
                    "CigarContainsNoNOperator",
                    "FirstOfPairReadFilter",
                    "FragmentLengthReadFilter",
                    "GoodCigarReadFilter",
                    "HasReadGroupReadFilter",
                    "LibraryReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "MatchingBasesAndQualsReadFilter",
                    "MateDifferentStrandReadFilter",
                    "MateOnSameContigOrNoMappedMateReadFilter",
                    "MetricsReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroFragmentLengthReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotOpticalDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "NotSupplementaryAlignmentReadFilter",
                    "OverclippedReadFilter",
                    "PairedReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "PlatformReadFilter",
                    "PlatformUnitReadFilter",
                    "PrimaryLineReadFilter",
                    "ProperlyPairedReadFilter",
                    "ReadGroupBlackListReadFilter",
                    "ReadGroupReadFilter",
                    "ReadLengthEqualsCigarLengthReadFilter",
                    "ReadLengthReadFilter",
                    "ReadNameReadFilter",
                    "ReadStrandFilter",
                    "SampleReadFilter",
                    "SecondOfPairReadFilter",
                    "SeqIsStoredReadFilter",
                    "ValidAlignmentEndReadFilter",
                    "ValidAlignmentStartReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "disable_read_filter",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--disable-read-filter', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Read filters to be disabled before analysis.",
            "sbg:altPrefix": "-DF",
            "sbg:category": "Optional Arguments",
            "label": "Disable read filter"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_sequence_dictionary_validation",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-sequence-dictionary-validation",
              "position": 4
            },
            "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk!",
            "sbg:altPrefix": "-disable-sequence-dictionary-validation",
            "sbg:category": "Optional Arguments",
            "label": "Disable sequence dictionary validation"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_read_filters",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-tool-default-read-filters",
              "position": 4
            },
            "doc": "Disable all tool default read filters (WARNING: many tools will not function correctly without their default read filters on).",
            "sbg:altPrefix": "-disable-tool-default-read-filters",
            "sbg:category": "Advanced Arguments",
            "label": "Disable tool default read filters"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "do_not_fix_overhangs",
            "doc": "Do not have the walker soft-clip overhanging sections of the reads.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--do-not-fix-overhangs",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Do not fix overhangs"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "dont_require_soft_clips_both_ends",
            "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Valid only if \"OverclippedReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--dont-require-soft-clips-both-ends",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Dont require soft clips both ends"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals_file",
            "sbg:fileTypes": "BED",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--exclude-intervals",
              "position": 4
            },
            "doc": "File which contains one or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude intervals file"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--exclude-intervals', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude intervals string"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "30",
            "id": "filter_too_short",
            "doc": "Minimum number of aligned bases. Valid only if \"OverclippedReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--filter-too-short",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Filter too short"
          },
          {
            "type": "File",
            "secondaryFiles": [
              "${\n    \n    if (self.nameext == \".bam\")\n    {\n        return self.nameroot + \".bai\";\n    }\n    else if (self.nameext == \".cram\")\n    {\n        return self.nameroot + \".crai\";\n    }\n    return '';\n    \n}"
            ],
            "id": "in_alignments",
            "sbg:fileTypes": "BAM, SAM, CRAM",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--input",
              "position": 4
            },
            "doc": "BAM/SAM/CRAM file containing reads.",
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "label": "Input BAM/SAM/CRAM file"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_exclusion_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-exclusion-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are excluding.",
            "sbg:altPrefix": "-ixp",
            "sbg:category": "Optional Arguments",
            "label": "Interval exclusion padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_merging_rule",
                "symbols": [
                  "ALL",
                  "OVERLAPPING_ONLY"
                ]
              }
            ],
            "sbg:toolDefaultValue": "ALL",
            "id": "interval_merging_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-merging-rule",
              "position": 4
            },
            "doc": "Interval merging rule for abutting intervals.",
            "sbg:altPrefix": "-imr",
            "sbg:category": "Optional Arguments",
            "label": "Interval merging rule"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are including.",
            "sbg:altPrefix": "-ip",
            "sbg:category": "Optional Arguments",
            "label": "Interval padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_set_rule",
                "symbols": [
                  "UNION",
                  "INTERSECTION"
                ]
              }
            ],
            "sbg:toolDefaultValue": "UNION",
            "id": "interval_set_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-set-rule",
              "position": 4
            },
            "doc": "Set merging approach to use for combining interval inputs.",
            "sbg:altPrefix": "-isr",
            "sbg:category": "Optional Arguments",
            "label": "Interval set rule"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals_file",
            "sbg:fileTypes": "BED",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--intervals",
              "position": 4
            },
            "doc": "File which contains one or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Include intervals file"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--intervals', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Include intervals string"
          },
          {
            "type": "string?",
            "id": "keep_read_group",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--keep-read-group",
              "position": 4
            },
            "label": "Keep read group",
            "sbg:category": "Conditional Arguments",
            "doc": "The name of the read group to keep. Valid only if \"ReadGroupReadFilter\" is specified."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "keep_reverse_strand_only",
            "doc": "Keep only reads on the reverse strand. Valid only if \"ReadStrandFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--keep-reverse-strand-only",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Keep reverse strand only"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "lenient",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--lenient",
              "position": 4
            },
            "doc": "Lenient processing of VCF files.",
            "sbg:altPrefix": "-LE",
            "sbg:category": "Optional Arguments",
            "label": "Lenient"
          },
          {
            "type": "string[]?",
            "id": "library",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--library', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Name of the library to keep. This argument must be specified at least once. Valid only if \"LibraryReadFilter\" is specified.",
            "sbg:altPrefix": "-library",
            "sbg:category": "Conditional Arguments",
            "label": "Library"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "40",
            "id": "max_bases_in_overhang",
            "doc": "Max number of bases allowed in the overhang.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-bases-in-overhang",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Max bases in overhang"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1000000",
            "id": "max_fragment_length",
            "doc": "Maximum length of fragment (insert size). Valid only if \"FragmentLengthReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-fragment-length",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Max fragment length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "max_mismatches_in_overhang",
            "doc": "Max number of mismatches allowed in the overhang.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-mismatches-in-overhang",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Max mismatches in overhang"
          },
          {
            "type": "int?",
            "id": "max_read_length",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-read-length",
              "position": 4
            },
            "label": "Max read length",
            "sbg:category": "Conditional Arguments",
            "doc": "Keep only reads with length at most equal to the specified value. Valid only if \"ReadLengthReadFilter\" is specified."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "150000",
            "id": "max_reads_in_memory",
            "doc": "Max reads allowed to be kept in memory at a time by the BAM writer.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-reads-in-memory",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Max reads in memory"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "maximum_mapping_quality",
            "doc": "Maximum mapping quality to keep (inclusive). Valid only if \"MappingQualityReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--maximum-mapping-quality",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Maximum mapping quality"
          },
          {
            "type": "int?",
            "id": "memory_overhead_per_job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "id": "memory_per_job",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "min_read_length",
            "doc": "Keep only reads with length at least equal to the specified value. Valid only if \"ReadLengthReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--min-read-length",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Min read length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "minimum_mapping_quality",
            "doc": "Minimum mapping quality to keep (inclusive). Valid only if \"MappingQualityReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--minimum-mapping-quality",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Minimum mapping quality"
          },
          {
            "type": "string[]?",
            "id": "platform_filter_name",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--platform-filter-name', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "label": "Platform filter name",
            "sbg:category": "Conditional Arguments",
            "doc": "Platform attribute (PL) to match. This argument must be specified at least once. Valid only if \"PlatformReadFilter\" is specified."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "process_secondary_alignments",
            "doc": "Have the walker split secondary alignments (will still repair MC tag without it).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--process-secondary-alignments",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Process secondary alignments"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "read_filter",
                  "symbols": [
                    "AlignmentAgreesWithHeaderReadFilter",
                    "AllowAllReadsReadFilter",
                    "AmbiguousBaseReadFilter",
                    "CigarContainsNoNOperator",
                    "FirstOfPairReadFilter",
                    "FragmentLengthReadFilter",
                    "GoodCigarReadFilter",
                    "HasReadGroupReadFilter",
                    "LibraryReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "MatchingBasesAndQualsReadFilter",
                    "MateDifferentStrandReadFilter",
                    "MateOnSameContigOrNoMappedMateReadFilter",
                    "MetricsReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroFragmentLengthReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotOpticalDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "NotSupplementaryAlignmentReadFilter",
                    "OverclippedReadFilter",
                    "PairedReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "PlatformReadFilter",
                    "PlatformUnitReadFilter",
                    "PrimaryLineReadFilter",
                    "ProperlyPairedReadFilter",
                    "ReadGroupBlackListReadFilter",
                    "ReadGroupReadFilter",
                    "ReadLengthEqualsCigarLengthReadFilter",
                    "ReadLengthReadFilter",
                    "ReadNameReadFilter",
                    "ReadStrandFilter",
                    "SampleReadFilter",
                    "SecondOfPairReadFilter",
                    "SeqIsStoredReadFilter",
                    "ValidAlignmentEndReadFilter",
                    "ValidAlignmentStartReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "read_filter",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--read-filter', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Read filters to be applied before analysis.",
            "sbg:altPrefix": "-RF",
            "sbg:category": "Optional Arguments",
            "label": "Read filter"
          },
          {
            "type": "string[]?",
            "id": "read_group_black_list",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--read-group-black-list', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "label": "Read group black list",
            "sbg:category": "Conditional Arguments",
            "doc": "The name of the read group to filter out. This argument must be specified at least once. Valid only if \"ReadGroupBlackListReadFilter\" is specified."
          },
          {
            "type": "string?",
            "id": "read_name",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--read-name",
              "position": 4
            },
            "label": "Read name",
            "sbg:category": "Conditional Arguments",
            "doc": "Keep only reads with this read name. Valid only if \"ReadNameReadFilter\" is specified."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "read_validation_stringency",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "SILENT",
            "id": "read_validation_stringency",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--read-validation-stringency",
              "position": 4
            },
            "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded.",
            "sbg:altPrefix": "-VS",
            "sbg:category": "Optional Arguments",
            "label": "Read validation stringency"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "refactor_cigar_string",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--refactor-cigar-string",
              "position": 4
            },
            "doc": "Refactor cigar string with NDN elements to one element.",
            "sbg:altPrefix": "-fixNDN",
            "sbg:category": "Optional Arguments",
            "label": "Refactor cigar string"
          },
          {
            "type": "File",
            "secondaryFiles": [
              ".fai",
              "^.dict"
            ],
            "id": "in_reference",
            "sbg:fileTypes": "FASTA, FA",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--reference",
              "position": 4
            },
            "doc": "Reference sequence file.",
            "sbg:altPrefix": "-R",
            "sbg:category": "Required Arguments",
            "label": "Reference"
          },
          {
            "type": "string[]?",
            "id": "sample",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--sample', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "The name of the sample(s) to keep, filtering out all others. This argument must be specified at least once. Valid only if \"SampleReadFilter\" is specified.",
            "sbg:altPrefix": "-sample",
            "sbg:category": "Conditional Arguments",
            "label": "Sample"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "sequence_dictionary",
            "sbg:fileTypes": "DICT",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sequence-dictionary",
              "position": 4
            },
            "doc": "Use the given sequence dictionary as the master/canonical sequence dictionary. Must be a .dict file.",
            "sbg:altPrefix": "-sequence-dictionary",
            "sbg:category": "Optional Arguments",
            "label": "Sequence dictionary"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "skip_mapping_quality_transform",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--skip-mapping-quality-transform",
              "position": 4
            },
            "doc": "Skip the 255 -> 60 MQ read transform.",
            "sbg:altPrefix": "-skip-mq-transform",
            "sbg:category": "Optional Arguments",
            "label": "Skip mapping quality transform"
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output file name prefix.",
            "label": "Output prefix",
            "sbg:category": "Optional Arguments"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_file_format",
                "symbols": [
                  "sam",
                  "bam",
                  "cram"
                ]
              }
            ],
            "id": "output_file_format",
            "doc": "Output file format.",
            "label": "Output file format",
            "sbg:category": "Optional Arguments"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform Options",
            "doc": "This input allows a user to set the desired CPU requirement when running a tool or adding it to a workflow."
          }
        ],
        "sbg:contributors": [
          "uros_sipetic",
          "veliborka_josipovic"
        ],
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job)\n    {\n        return \"--java-options\";\n    }\n    else \n    {\n        return '';\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) \n    {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    else\n    {\n        return '';\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "SplitNCigarReads",
            "shellQuote": false,
            "position": 3
          },
          {
            "valueFrom": "${\n    var in_alignments = inputs.in_alignments;\n    var output_ext = inputs.output_file_format ? inputs.output_file_format : in_alignments.path.split('.').pop();\n    var output_prefix = '';\n    if (inputs.output_prefix)\n    {\n        output_prefix = inputs.output_prefix;\n    }\n    else \n    {\n        if (in_alignments.metadata && in_alignments.metadata.sample_id)\n        {\n            output_prefix = in_alignments.metadata.sample_id;\n        }\n        else \n        {\n            output_prefix = in_alignments.path.split('/').pop().split('.')[0];\n        }\n    }\n    \n    return \"--output \" + output_prefix + \".split.\" + output_ext;\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          },
          {
            "valueFrom": "${\n    var output_ext = inputs.output_file_format ? inputs.output_file_format :\n    inputs.in_alignments.path.split('.').pop();\n    if (output_ext == \"cram\")\n    {\n        return '&& for i in *cram.bai; do mv \"$i\" \"${i%.cram.bai}.cram.crai\";  done';\n    }\n    else \n    {\n        return '';\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 5
          }
        ],
        "sbg:modifiedOn": 1559734483,
        "sbg:publisher": "sbg",
        "sbg:toolkitVersion": "4.1.0.0",
        "cwlVersion": "v1.0",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk/"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
          },
          {
            "label": "Publications",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/org_broadinstitute_hellbender_tools_walkers_rnaseq_SplitNCigarReads.php"
          }
        ],
        "sbg:revision": 4,
        "sbg:categories": [
          "Utilities",
          "BAM Processing"
        ]
      },
      "in": [
        {
          "source": "gatk_markduplicates_4_1_0_0/out_alignments",
          "id": "in_alignments"
        },
        {
          "source": "in_reference",
          "id": "in_reference"
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        }
      ],
      "sbg:y": 1.102539300918579,
      "label": "GATK SplitNCigarReads",
      "sbg:x": 860.520751953125,
      "out": [
        {
          "id": "out_alignments"
        }
      ]
    },
    {
      "id": "gatk_baserecalibrator_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 12,
        "sbg:modifiedBy": "veliborka_josipovic",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk/"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
          },
          {
            "label": "Publications",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/org_broadinstitute_hellbender_tools_walkers_bqsr_BaseRecalibrator.php"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 6500;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1;\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "The **GATK BaseRecalibrator** tool performs first pass of Base Quality Score Recalibration (BQSR) based on various covariates. The default covariates are read group, reported quality score, machine cycle, and nucleotide context. The tool generates on a recalibration table on its output.\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases\n\n* The **GATK BaseRecalibrator** tool requires the input read data whose quality scores need to be assessed on its **Input BAM/SAM/CRAM file** (`--input`) input and the database of known polymorphic sites to skip over on its **Known SNPs** and **Known INDELs** (`--known-sites`) inputs. The tool generates on its **Output recalibration report** output a GATK report file with many tables: the list of arguments, the quantized qualities table, the recalibration table by read group, the recalibration table by quality score,\nthe recalibration table for all the optional covariates.\n\n* Usage example:\n\n```\ngatk BaseRecalibrator \\\n   --input my_reads.bam \\\n   --reference reference.fasta \\\n   --known-sites sites_of_variation.vcf \\\n   --known-sites another/optional/setOfSitesToMask.vcf \\\n   --output recal_data.table\n\n```\n\n###Changes Introduced by Seven Bridges\n\n* All output files will be prefixed using the **Output prefix** parameter. In case **Output prefix** is not provided, output prefix will be the same as the Sample ID metadata from **Input SAM/BAM/CRAM file**, if the Sample ID metadata exists. Otherwise, output prefix will be inferred from the **Input SAM/BAM/CRAM** filename. This way, having identical names of the output files between runs is avoided. Moreover,  **recal_data** will be added before the extension of the output file name which is CSV by default. \n\n* **Include intervals** (`--intervals`) option is divided into **Include intervals string** and **Include intervals file** options.\n\n* **Exclude intervals** (`--exclude-intervals`) option is divided into **Exclude intervals string** and **Exclude intervals file** options.\n\n###Common Issues and Important Notes\n\n* Note: If **Read filter** (`--read-filter`) option is set to \"LibraryReadFilter\", **Library** (`--library`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"PlatformReadFilter\", **Platform filter name** (`--platform-filter-name`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to\"PlatformUnitReadFilter\", **Black listed lanes** (`--black-listed-lanes`) option must be set to some value. \n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadGroupBlackListReadFilter\", **Read group black list** (`--read-group-black-list`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadGroupReadFilter\", **Keep read group** (`--keep-read-group`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadLengthReadFilter\", **Max read length** (`--max-read-length`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadNameReadFilter\", **Read name** (`--read-name`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadStrandFilter\", **Keep reverse strand only** (`--keep-reverse-strand-only`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"SampleReadFilter\", **Sample** (`--sample`) option must be set to some value.\n\n###Performance Benchmarking\n\nBelow is a table describing runtimes and task costs of **GATK BaseRecalibrator** for a couple of different samples, executed on the AWS cloud instances:\n\n| Experiment type |  Input size | Duration |  Cost | Instance (AWS) | \n|:--------------:|:------------:|:--------:|:-------:|:---------:|\n|     RNA-Seq     |  2.2 GB |   8min   | ~0.05$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     |  6.6 GB |   18min   | ~0.12$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 11 GB |  26min  | ~0.17$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 22 GB |  45min  | ~0.29$ | c4.2xlarge (8 CPUs) |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n###References\n\n[1] [GATK BaseRecalibrator](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/org_broadinstitute_hellbender_tools_walkers_bqsr_BaseRecalibrator.php)",
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:createdOn": 1552922094,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-baserecalibrator-4-1-0-0/12",
        "sbg:image_url": null,
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:toolkit": "GATK",
        "sbg:content_hash": "aa3b8b1c9bf0bd33d0aa683181678534233162749f580e7013cc7938184880f0b",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1552922094,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/11",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554492924,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/14",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554492998,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/15",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554720866,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/17",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999207,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/18",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1556030757,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/19",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1557735256,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/20",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558000594,
            "sbg:revision": 7,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/21",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558351546,
            "sbg:revision": 8,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/23",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558450805,
            "sbg:revision": 9,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/24",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558517350,
            "sbg:revision": 10,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/25",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558518057,
            "sbg:revision": 11,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-baserecalibrator-4-1-0-0/26",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1571321280,
            "sbg:revision": 12,
            "sbg:revisionNotes": "known_snps null handled",
            "sbg:modifiedBy": "veliborka_josipovic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:revisionNotes": "known_snps null handled",
        "label": "GATK BaseRecalibrator",
        "sbg:contributors": [
          "uros_sipetic",
          "veliborka_josipovic",
          "nens"
        ],
        "outputs": [
          {
            "type": "File?",
            "label": "Output recalibration report",
            "sbg:fileTypes": "CSV",
            "id": "output",
            "outputBinding": {
              "glob": "*csv",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "The output recalibration table file."
          }
        ],
        "sbg:id": "h-483b80a3/h-f742706b/h-875b1dc3/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "ambig_filter_bases",
            "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjuction with argument(s) maxAmbiguousBaseFraction. Valid only if \"AmbiguousBaseReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ambig-filter-bases",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Ambig filter bases"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0",
            "id": "ambig_filter_frac",
            "doc": "Threshold fraction of ambiguous bases. Cannot be used in conjuction with argument(s) maxAmbiguousBases. Valid only if \"AmbiguousBaseReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ambig-filter-frac",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Ambig filter frac"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "binary_tag_name",
            "doc": "The binary tag covariate name if using it.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--binary-tag-name",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Binary tag name"
          },
          {
            "type": "string[]?",
            "id": "black_listed_lanes",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--black-listed-lanes', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "label": "Black listed lanes",
            "sbg:category": "Conditional Arguments",
            "doc": "Platform unit (PU) to filter out. This argument must be specified at least once. Valid only if \"PlatformUnitReadFilter\" is specified."
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "40",
            "id": "bqsr_baq_gap_open_penalty",
            "doc": "BQSR BAQ gap open penalty (Phred Scaled). Default value is 40. 30 is perhaps better for whole genome call sets.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--bqsr-baq-gap-open-penalty",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "BQSR BAQ gap open penalty"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-1",
            "id": "default_base_qualities",
            "doc": "Assign a default base quality.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--default-base-qualities",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Default base qualities"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "45",
            "id": "deletions_default_quality",
            "doc": "Default quality for the base deletions covariate.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--deletions-default-quality",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Deletions default quality"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "disable_read_filter",
                  "symbols": [
                    "AlignmentAgreesWithHeaderReadFilter",
                    "AllowAllReadsReadFilter",
                    "AmbiguousBaseReadFilter",
                    "CigarContainsNoNOperator",
                    "FirstOfPairReadFilter",
                    "FragmentLengthReadFilter",
                    "GoodCigarReadFilter",
                    "HasReadGroupReadFilter",
                    "LibraryReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "MatchingBasesAndQualsReadFilter",
                    "MateDifferentStrandReadFilter",
                    "MateOnSameContigOrNoMappedMateReadFilter",
                    "MetricsReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroFragmentLengthReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotOpticalDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "NotSupplementaryAlignmentReadFilter",
                    "OverclippedReadFilter",
                    "PairedReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "PlatformReadFilter",
                    "PlatformUnitReadFilter",
                    "PrimaryLineReadFilter",
                    "ProperlyPairedReadFilter",
                    "ReadGroupBlackListReadFilter",
                    "ReadGroupReadFilter",
                    "ReadLengthEqualsCigarLengthReadFilter",
                    "ReadLengthReadFilter",
                    "ReadNameReadFilter",
                    "ReadStrandFilter",
                    "SampleReadFilter",
                    "SecondOfPairReadFilter",
                    "SeqIsStoredReadFilter",
                    "ValidAlignmentEndReadFilter",
                    "ValidAlignmentStartReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "disable_read_filter",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--disable-read-filter', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Read filters to be disabled before analysis.",
            "sbg:altPrefix": "-DF",
            "sbg:category": "Optional Arguments",
            "label": "Disable read filter"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_sequence_dictionary_validation",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-sequence-dictionary-validation",
              "position": 4
            },
            "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk!",
            "sbg:altPrefix": "-disable-sequence-dictionary-validation",
            "sbg:category": "Optional Arguments",
            "label": "Disable sequence dictionary validation"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_read_filters",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-tool-default-read-filters",
              "position": 4
            },
            "doc": "Disable all tool default read filters (WARNING: many tools will not function correctly without their default read filters on).",
            "sbg:altPrefix": "-disable-tool-default-read-filters",
            "sbg:category": "Advanced Arguments",
            "label": "Disable tool default read filters"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "dont_require_soft_clips_both_ends",
            "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Valid only if \"OverclippedReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--dont-require-soft-clips-both-ends",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Dont require soft clips both ends"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals_file",
            "sbg:fileTypes": "BED",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--exclude-intervals",
              "position": 4
            },
            "doc": "File which contains one or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude intervals file"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--exclude-intervals', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude intervals string"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "30",
            "id": "filter_too_short",
            "doc": "Minimum number of aligned bases. Valid only if \"OverclippedReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--filter-too-short",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Filter too short"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "3",
            "id": "indels_context_size",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--indels-context-size",
              "position": 4
            },
            "doc": "Size of the k-mer context to be used for base insertions and deletions.",
            "sbg:altPrefix": "-ics",
            "sbg:category": "Optional Arguments",
            "label": "Indels context size"
          },
          {
            "type": "File",
            "secondaryFiles": [
              "${\n    if (self.nameext == \".bam\")\n    {\n        return  self.nameroot + \".bai\";\n    }\n    else if (self.nameext == \".cram\")\n    {\n        return  self.nameroot + \".crai\";\n    }\n    return ''; \n    \n}"
            ],
            "id": "in_alignments",
            "sbg:fileTypes": "BAM, SAM, CRAM",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--input",
              "position": 4
            },
            "doc": "BAM/SAM/CRAM file containing reads.",
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "label": "Input BAM/SAM/CRAM file"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "45",
            "id": "insertions_default_quality",
            "doc": "Default quality for the base insertions covariate.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--insertions-default-quality",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Insertions default quality"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_exclusion_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-exclusion-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are excluding.",
            "sbg:altPrefix": "-ixp",
            "sbg:category": "Optional Arguments",
            "label": "Interval exclusion padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_merging_rule",
                "symbols": [
                  "ALL",
                  "OVERLAPPING_ONLY"
                ]
              }
            ],
            "sbg:toolDefaultValue": "ALL",
            "id": "interval_merging_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-merging-rule",
              "position": 4
            },
            "doc": "Interval merging rule for abutting intervals.",
            "sbg:altPrefix": "-imr",
            "sbg:category": "Optional Arguments",
            "label": "Interval merging rule"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are including.",
            "sbg:altPrefix": "-ip",
            "sbg:category": "Optional Arguments",
            "label": "Interval padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_set_rule",
                "symbols": [
                  "UNION",
                  "INTERSECTION"
                ]
              }
            ],
            "sbg:toolDefaultValue": "UNION",
            "id": "interval_set_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-set-rule",
              "position": 4
            },
            "doc": "Set merging approach to use for combining interval inputs.",
            "sbg:altPrefix": "-isr",
            "sbg:category": "Optional Arguments",
            "label": "Interval set rule"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals_file",
            "sbg:fileTypes": "BED, INTERVALS",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--intervals",
              "position": 4
            },
            "doc": "File which contains one or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Include intervals file"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--intervals', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Include intervals string"
          },
          {
            "type": "string?",
            "id": "keep_read_group",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--keep-read-group",
              "position": 4
            },
            "label": "Keep read group",
            "sbg:category": "Conditional Arguments",
            "doc": "The name of the read group to keep. Valid only if \"ReadGroupReadFilter\" is specified."
          },
          {
            "type": "boolean?",
            "id": "keep_reverse_strand_only",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--keep-reverse-strand-only",
              "position": 4
            },
            "label": "Keep reverse strand only",
            "sbg:category": "Conditional Arguments",
            "doc": "Keep only reads on the reverse strand. Valid only if \"ReadStrandFilter\" is specified."
          },
          {
            "type": "File[]?",
            "secondaryFiles": [
              "${\n    return self.basename + \".idx\"\n}"
            ],
            "id": "known_indels",
            "sbg:fileTypes": "VCF",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--known-sites', self[i].path);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 5
            },
            "label": "Known indels",
            "sbg:category": "Required Arguments",
            "doc": "One or more databases of known polymorphic sites used to exclude regions around known polymorphisms from analysis. This argument must be specified at least once."
          },
          {
            "type": "File[]?",
            "secondaryFiles": [
              "${\n    return self.basename + \".idx\"\n}"
            ],
            "id": "known_snps",
            "sbg:fileTypes": "VCF",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            if (self[i] != null)\n            {\n                cmd.push('--known-sites', self[i].path);\n            }\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 5
            },
            "label": "Known SNPs",
            "sbg:category": "Required Arguments",
            "doc": "One or more databases of known polymorphic sites used to exclude regions around known polymorphisms from analysis. This argument must be specified at least once."
          },
          {
            "type": "string[]?",
            "id": "library",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--library', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Name of the library to keep. This argument must be specified at least once. Valid only if \"LibraryReadFilter\" is specified.",
            "sbg:altPrefix": "-library",
            "sbg:category": "Conditional Arguments",
            "label": "Library"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "low_quality_tail",
            "doc": "Minimum quality for the bases in the tail of the reads to be considered.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--low-quality-tail",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Low quality tail"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1000000",
            "id": "max_fragment_length",
            "doc": "Maximum length of fragment (insert size). Valid only if \"FragmentLengthReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-fragment-length",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Max fragment length"
          },
          {
            "type": "int?",
            "id": "max_read_length",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-read-length",
              "position": 4
            },
            "label": "Max read length",
            "sbg:category": "Conditional Arguments",
            "doc": "Keep only reads with length at most equal to the specified value. Valid only if \"ReadLengthReadFilter\" is specified."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "500",
            "id": "maximum_cycle_value",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--maximum-cycle-value",
              "position": 4
            },
            "doc": "The maximum cycle value permitted for the Cycle covariate.",
            "sbg:altPrefix": "-max-cycle",
            "sbg:category": "Optional Arguments",
            "label": "Maximum cycle value"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "maximum_mapping_quality",
            "doc": "Maximum mapping quality to keep (inclusive). Valid only if \"MappingQualityReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--maximum-mapping-quality",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Maximum mapping quality"
          },
          {
            "type": "int?",
            "id": "memory_overhead_per_job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "id": "memory_per_job",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "min_read_length",
            "doc": "Keep only reads with length at least equal to the specified value. Valid only if \"ReadLengthReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--min-read-length",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Min read length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "minimum_mapping_quality",
            "doc": "Minimum mapping quality to keep (inclusive). Valid only if \"MappingQualityReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--minimum-mapping-quality",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Minimum mapping quality"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "mismatches_context_size",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--mismatches-context-size",
              "position": 4
            },
            "doc": "Size of the k-mer context to be used for base mismatches.",
            "sbg:altPrefix": "-mcs",
            "sbg:category": "Optional Arguments",
            "label": "Mismatches context size"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-1",
            "id": "mismatches_default_quality",
            "doc": "Default quality for the base mismatches covariate.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--mismatches-default-quality",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Mismatches default quality"
          },
          {
            "type": "string[]?",
            "id": "platform_filter_name",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--platform-filter-name', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "label": "Platform filter name",
            "sbg:category": "Conditional Arguments",
            "doc": "Platform attribute (PL) to match. This argument must be specified at least once. Valid only if \"PlatformReadFilter\" is specified."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "6",
            "id": "preserve_qscores_less_than",
            "doc": "Don't recalibrate bases with quality scores less than this threshold (with -bqsr).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--preserve-qscores-less-than",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Preserve qscores less than"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "16",
            "id": "quantizing_levels",
            "doc": "Number of distinct quality scores in the quantized output.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--quantizing-levels",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Quantizing levels"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "read_filter",
                  "symbols": [
                    "AlignmentAgreesWithHeaderReadFilter",
                    "AllowAllReadsReadFilter",
                    "AmbiguousBaseReadFilter",
                    "CigarContainsNoNOperator",
                    "FirstOfPairReadFilter",
                    "FragmentLengthReadFilter",
                    "GoodCigarReadFilter",
                    "HasReadGroupReadFilter",
                    "LibraryReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "MatchingBasesAndQualsReadFilter",
                    "MateDifferentStrandReadFilter",
                    "MateOnSameContigOrNoMappedMateReadFilter",
                    "MetricsReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroFragmentLengthReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotOpticalDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "NotSupplementaryAlignmentReadFilter",
                    "OverclippedReadFilter",
                    "PairedReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "PlatformReadFilter",
                    "PlatformUnitReadFilter",
                    "PrimaryLineReadFilter",
                    "ProperlyPairedReadFilter",
                    "ReadGroupBlackListReadFilter",
                    "ReadGroupReadFilter",
                    "ReadLengthEqualsCigarLengthReadFilter",
                    "ReadLengthReadFilter",
                    "ReadNameReadFilter",
                    "ReadStrandFilter",
                    "SampleReadFilter",
                    "SecondOfPairReadFilter",
                    "SeqIsStoredReadFilter",
                    "ValidAlignmentEndReadFilter",
                    "ValidAlignmentStartReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "read_filter",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--read-filter', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Read filters to be applied before analysis.",
            "sbg:altPrefix": "-RF",
            "sbg:category": "Optional Arguments",
            "label": "Read filter"
          },
          {
            "type": "string[]?",
            "id": "read_group_black_list",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--read-group-black-list', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "label": "Read group black list",
            "sbg:category": "Conditional Arguments",
            "doc": "The name of the read group to filter out. This argument must be specified at least once. Valid only if \"ReadGroupBlackListReadFilter\" is specified."
          },
          {
            "type": "string?",
            "id": "read_name",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--read-name",
              "position": 4
            },
            "label": "Read name",
            "sbg:category": "Conditional Arguments",
            "doc": "Keep only reads with this read name. Valid only if \"ReadNameReadFilter\" is specified."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "read_validation_stringency",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "SILENT",
            "id": "read_validation_stringency",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--read-validation-stringency",
              "position": 4
            },
            "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded.",
            "sbg:altPrefix": "-VS",
            "sbg:category": "Optional Arguments",
            "label": "Read validation stringency"
          },
          {
            "type": "File",
            "secondaryFiles": [
              ".fai",
              "^.dict"
            ],
            "id": "in_reference",
            "sbg:fileTypes": "FASTA, FA",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--reference",
              "position": 4
            },
            "doc": "Reference sequence file.",
            "sbg:altPrefix": "-R",
            "sbg:category": "Required Arguments",
            "label": "Reference"
          },
          {
            "type": "string[]?",
            "id": "sample",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--sample', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "The name of the sample(s) to keep, filtering out all others. This argument must be specified at least once. Valid only if \"SampleReadFilter\" is specified.",
            "sbg:altPrefix": "-sample",
            "sbg:category": "Conditional Arguments",
            "label": "Sample"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "10.0",
            "id": "sequence_dictionary",
            "sbg:fileTypes": "DICT",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sequence-dictionary",
              "position": 4
            },
            "doc": "Use the given sequence dictionary as the master/canonical sequence dictionary. Must be a .dict file.",
            "sbg:altPrefix": "-sequence-dictionary",
            "sbg:category": "Optional Arguments",
            "label": "Sequence dictionary"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "use_original_qualities",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--use-original-qualities",
              "position": 4
            },
            "doc": "Use the base quality scores from the OQ tag.",
            "sbg:altPrefix": "-OQ",
            "sbg:category": "Optional Arguments",
            "label": "Use original qualities"
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output file name prefix.",
            "label": "Output prefix",
            "sbg:category": "Optional arguments"
          },
          {
            "type": "int?",
            "id": "cpu_per_job",
            "doc": "This input allows a user to set the desired CPU requirement when running a tool or adding it to a workflow.",
            "label": "CPU per job",
            "sbg:category": "Platform Options"
          }
        ],
        "cwlVersion": "v1.0",
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "--java-options",
            "shellQuote": false,
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    return '\\\"-XX:GCTimeLimit=50 -XX:GCHeapFreeLimit=10 -XX:+PrintFlagsFinal -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:gc_log.log -Xms4000m\\\"';\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "BaseRecalibrator",
            "shellQuote": false,
            "position": 3
          },
          {
            "valueFrom": "${\n    var in_alignments = inputs.in_alignments;\n    var output_prefix = '';\n    if (inputs.output_prefix)\n    {\n        output_prefix = inputs.output_prefix;\n    }\n    else \n    {\n        if (in_alignments.metadata && in_alignments.metadata.sample_id)\n        {\n             output_prefix = in_alignments.metadata.sample_id;\n        }\n        else \n        {\n            output_prefix = in_alignments.path.split('/').pop().split('.')[0];\n        }\n    }\n    \n    return \"--output \" + output_prefix + \".recal_data.csv\";\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          }
        ],
        "sbg:modifiedOn": 1571321280,
        "sbg:publisher": "sbg",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "4.1.0.0",
        "sbg:revision": 12,
        "sbg:categories": [
          "Utilities",
          "BAM Processing"
        ]
      },
      "in": [
        {
          "source": "gatk_splitncigarreads_4_1_0_0/out_alignments",
          "id": "in_alignments"
        },
        {
          "source": [
            "known_indels"
          ],
          "id": "known_indels"
        },
        {
          "source": [
            "known_snps"
          ],
          "id": "known_snps",
          "valueFrom": "$([self])"
        },
        {
          "source": "in_reference",
          "id": "in_reference"
        },
        {
          "id": "use_original_qualities",
          "default": true
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        }
      ],
      "sbg:y": 18.842971801757812,
      "label": "GATK BaseRecalibrator",
      "sbg:x": 1278.3719482421875,
      "out": [
        {
          "id": "output"
        }
      ]
    },
    {
      "id": "gatk_applybqsr_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 10,
        "sbg:modifiedBy": "nemanja.vucic",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk/"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
          },
          {
            "label": "Publications",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/org_broadinstitute_hellbender_tools_walkers_bqsr_ApplyBQSR.php"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 3500;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1;\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "The **GATK ApplyBQSR** tool recalibrates the base qualities score of the input reads and outputs a recalibrated BAM, SAM or CRAM file. \n\nThis tool performs the second pass in a two-stage process called Base Quality Score Recalibration (BQSR). Specifically, it recalibrates the base qualities of the input reads based on the recalibration table produced by the **BaseRecalibrator** tool. The goal of this procedure is to correct systematic biasses that affect the assignment of base quality scores by the sequencer. The first pass consists of calculating error empirically and finding patterns in how error varies with basecall features over all bases. The relevant observations are written to the recalibration table. The second pass consists of applying numerical corrections to each individual basecall based on the patterns identified in the first step (recorded in the recalibration table) and write out the recalibrated data to a new BAM, SAM or CRAM file [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases\n\n* The **GATK ApplyBQSR** tool requires the BAM, SAM or CRAM file on its **Input BAM/SAM/CRAM file** (`--input`) input and the covariates table (= recalibration file) generated by the **BaseRecalibrator** tool on its **BQSR recal file** input (`--bqsr-recal-file`). The tool generates on its **Output BAM/SAM/CRAM** output a new alignments file which contains recalibrated read data.\n\n* Usage example\n\n```\n gatk ApplyBQSR \\\n   --reference reference.fasta \\\n   --input input.bam \\\n   --bqsr-recal-file recalibration.table \\\n   --output output.bam\n\n```\n\n* If the input alignments file is in CRAM format, the reference sequence is required on the **Reference sequence** (`--reference`) input of the tool.\n\n* Original qualities can be retained in the output file under the \"OQ\" tag if desired. See the **Emit original quals** (`--emit-original-quals`) argument for details.\n\n###Changes Introduced by Seven Bridges\n\n* All output files will be prefixed using the **Output prefix** parameter. In case **Output prefix** is not provided, output prefix will be the same as the Sample ID metadata from **Input SAM/BAM/CRAM file**, if the Sample ID metadata exists. Otherwise, output prefix will be inferred from the **Input SAM/BAM/CRAM** filename. This way, having identical names of the output files between runs is avoided. Moreover,  **recalibrated** will be added before the extension of the output file name. \n\n* The user has a possibility to specify the output file format using the **Output file format** argument. Otherwise, the output file format will be the same as the format of the input file.\n\n* **Include intervals** (`--intervals`) option is divided into **Include intervals string** and **Include intervals file** options.\n\n* **Exclude intervals** (`--exclude-intervals`) option is divided into **Exclude intervals string** and **Exclude intervals file** options.\n\n###Common Issues and Important Notes\n\n* Note: This tool replaces the use of PrintReads for the application of base quality score recalibration as practiced in earlier versions of GATK (2.x and 3.x) [1].\n* Note: You should only run **ApplyBQSR** with the covariates table created from the input BAM, SAM or CRAM file [1].\nInput BAM/SAM/CRAM file\n* Note: If **Read filter** (`--read-filter`) option is set to \"LibraryReadFilter\", **Library** (`--library`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"PlatformReadFilter\", **Platform filter name** (`--platform-filter-name`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to\"PlatformUnitReadFilter\", **Black listed lanes** (`--black-listed-lanes`) option must be set to some value. \n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadGroupBlackListReadFilter\", **Read group black list** (`--read-group-black-list`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadGroupReadFilter\", **Keep read group** (`--keep-read-group`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadLengthReadFilter\", **Max read length** (`--max-read-length`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadNameReadFilter\", **Read name** (`--read-name`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"ReadStrandFilter\", **Keep reverse strand only** (`--keep-reverse-strand-only`) option must be set to some value.\n* Note: If **Read filter** (`--read-filter`) option is set to \"SampleReadFilter\", **Sample** (`--sample`) option must be set to some value.\n\n###Performance Benchmarking\n\nBelow is a table describing runtimes and task costs of **GATK ApplyBQSR** for a couple of different samples, executed on the AWS cloud instances:\n\n| Experiment type |  Input size | Duration |  Cost | Instance (AWS) | \n|:--------------:|:------------:|:--------:|:-------:|:---------:|\n|     RNA-Seq     |  2.2 GB |   7min   | ~0.05$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     |  6.6 GB |   22min   | ~0.12$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 11 GB |  36min  | ~0.17$ | c4.2xlarge (8 CPUs) | \n|     RNA-Seq     | 22 GB |  1h 15min  | ~0.29$ | c4.2xlarge (8 CPUs) |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n###References\n\n[1] [GATK ApplyBQSR](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/org_broadinstitute_hellbender_tools_walkers_bqsr_ApplyBQSR.php)",
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/24",
        "sbg:createdOn": 1552923344,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-applybqsr-4-1-0-0/10",
        "sbg:image_url": null,
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:toolkit": "GATK",
        "sbg:content_hash": "a0fe80d5ce988982acb05bdf82d9c9874f2ec68e4160fc40b157059decbfb5810",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1552923344,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/8",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554493022,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/14",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554493059,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/15",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554720859,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/16",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999197,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/17",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1557734544,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/18",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558000590,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/19",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558351541,
            "sbg:revision": 7,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/21",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558451164,
            "sbg:revision": 8,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/22",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1558524331,
            "sbg:revision": 9,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/23",
            "sbg:modifiedBy": "nens"
          },
          {
            "sbg:modifiedOn": 1559744828,
            "sbg:revision": 10,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/24",
            "sbg:modifiedBy": "nemanja.vucic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-applybqsr-4-1-0-0/24",
        "label": "GATK ApplyBQSR",
        "sbg:contributors": [
          "uros_sipetic",
          "nens",
          "nemanja.vucic",
          "veliborka_josipovic"
        ],
        "outputs": [
          {
            "type": "File?",
            "secondaryFiles": [
              "${\n    var output_ext = self.nameext;\n    \n    if (output_ext == \".bam\")\n    {\n        return self.nameroot + \".bai\";\n    }\n    else if (output_ext == \".cram\")\n    {\n        return self.nameroot + \".crai\";\n    }\n    else \n        return ''; \n  \n}"
            ],
            "label": "Output recalibrated BAM/SAM/CRAM file",
            "sbg:fileTypes": "BAM, SAM, CRAM",
            "id": "out_alignments",
            "outputBinding": {
              "glob": "*am",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "Output base quality recalibrated BAM/SAM/CRAM file."
          }
        ],
        "sbg:id": "h-764888e1/h-4f9e8f84/h-5db15e7e/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "add_output_sam_program_record",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "add_output_sam_program_record",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--add-output-sam-program-record",
              "position": 4
            },
            "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files.",
            "sbg:altPrefix": "-add-output-sam-program-record",
            "sbg:category": "Optional Arguments",
            "label": "Add output SAM program record"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "ambig_filter_bases",
            "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjuction with argument maxAmbiguousBaseFraction. Valid only if \"AmbiguousBaseReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ambig-filter-bases",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Ambig filter bases"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0",
            "id": "ambig_filter_frac",
            "doc": "Threshold fraction of ambiguous bases. Cannot be used in conjuction with argument maxAmbiguousBases. Valid only if \"AmbiguousBaseReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ambig-filter-frac",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Ambig filter frac"
          },
          {
            "type": "string[]?",
            "id": "black_listed_lanes",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--black-listed-lanes', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "label": "Black listed lanes",
            "sbg:category": "Conditional Arguments",
            "doc": "Platform unit (PU) to filter out. Valid only if \"PlatformUnitReadFilter\" is specified."
          },
          {
            "type": "File",
            "id": "bqsr_recal_file",
            "sbg:fileTypes": "CSV",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--bqsr-recal-file",
              "position": 4
            },
            "doc": "Input recalibration table for BQSR.",
            "sbg:altPrefix": "-bqsr",
            "sbg:category": "Required Arguments",
            "label": "BQSR recal file"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "create_output_bam_index",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "create_output_bam_index",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--create-output-bam-index",
              "position": 4
            },
            "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file.",
            "sbg:altPrefix": "-OBI",
            "sbg:category": "Optional Arguments",
            "label": "Create output BAM/CRAM index"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "disable_read_filter",
                  "symbols": [
                    "AlignmentAgreesWithHeaderReadFilter",
                    "AllowAllReadsReadFilter",
                    "AmbiguousBaseReadFilter",
                    "CigarContainsNoNOperator",
                    "FirstOfPairReadFilter",
                    "FragmentLengthReadFilter",
                    "GoodCigarReadFilter",
                    "HasReadGroupReadFilter",
                    "LibraryReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "MatchingBasesAndQualsReadFilter",
                    "MateDifferentStrandReadFilter",
                    "MateOnSameContigOrNoMappedMateReadFilter",
                    "MetricsReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroFragmentLengthReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotOpticalDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "NotSupplementaryAlignmentReadFilter",
                    "OverclippedReadFilter",
                    "PairedReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "PlatformReadFilter",
                    "PlatformUnitReadFilter",
                    "PrimaryLineReadFilter",
                    "ProperlyPairedReadFilter",
                    "ReadGroupBlackListReadFilter",
                    "ReadGroupReadFilter",
                    "ReadLengthEqualsCigarLengthReadFilter",
                    "ReadLengthReadFilter",
                    "ReadNameReadFilter",
                    "ReadStrandFilter",
                    "SampleReadFilter",
                    "SecondOfPairReadFilter",
                    "SeqIsStoredReadFilter",
                    "ValidAlignmentEndReadFilter",
                    "ValidAlignmentStartReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "disable_read_filter",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--disable-read-filter', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "separate": false,
              "position": 4
            },
            "doc": "Read filters to be disabled before analysis.",
            "sbg:altPrefix": "-DF",
            "sbg:category": "Optional Arguments",
            "label": "Disable read filter"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_sequence_dictionary_validation",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-sequence-dictionary-validation",
              "position": 4
            },
            "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk!",
            "sbg:altPrefix": "-disable-sequence-dictionary-validation",
            "sbg:category": "Optional Arguments",
            "label": "Disable sequence dictionary validation"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_read_filters",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-tool-default-read-filters",
              "position": 4
            },
            "doc": "Disable all tool default read filters (warning: many tools will not function correctly without their default read filters on).",
            "sbg:altPrefix": "-disable-tool-default-read-filters",
            "sbg:category": "Advanced Arguments",
            "label": "Disable tool default read filters"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "dont_require_soft_clips_both_ends",
            "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Valid only if \"OverclippedReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--dont-require-soft-clips-both-ends",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Dont require soft clips both ends"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "emit_original_quals",
            "doc": "Emit original base qualities under the OQ tag.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--emit-original-quals",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Emit original quals"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals_file",
            "sbg:fileTypes": "BED",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--exclude-intervals",
              "position": 4
            },
            "doc": "File which contains one or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude intervals file"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--exclude-intervals', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude intervals string"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "30",
            "id": "filter_too_short",
            "doc": "Minimum number of aligned bases. Valid only if \"OverclippedReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--filter-too-short",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Filter too short"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "-1.0",
            "id": "global_qscore_prior",
            "doc": "Global Qscore Bayesian prior to use for BQSR.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--global-qscore-prior",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Global Qscore prior"
          },
          {
            "type": "File",
            "secondaryFiles": [
              "${\n    \n    if (self.nameext == \".bam\")\n    {\n        return  self.nameroot + \".bai\";\n    }\n    else if (self.nameext == \".cram\")\n    {\n        return self.nameroot + \".crai\";\n    }\n    \n    return ''; \n    \n}"
            ],
            "id": "in_alignments",
            "sbg:fileTypes": "BAM, SAM, CRAM",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--input",
              "position": 4
            },
            "doc": "BAM/SAM/CRAM file(s) containing reads.",
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "label": "Input BAM/SAM/CRAM file"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_exclusion_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-exclusion-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are excluding.",
            "sbg:altPrefix": "-ixp",
            "sbg:category": "Optional Arguments",
            "label": "Interval exclusion padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_merging_rule",
                "symbols": [
                  "ALL",
                  "OVERLAPPING_ONLY"
                ]
              }
            ],
            "sbg:toolDefaultValue": "ALL",
            "id": "interval_merging_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-merging-rule",
              "position": 4
            },
            "doc": "Interval merging rule for abutting intervals.",
            "sbg:altPrefix": "-imr",
            "sbg:category": "Optional Arguments",
            "label": "Interval merging rule"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are including.",
            "sbg:altPrefix": "-ip",
            "sbg:category": "Optional Arguments",
            "label": "Interval padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_set_rule",
                "symbols": [
                  "UNION",
                  "INTERSECTION"
                ]
              }
            ],
            "sbg:toolDefaultValue": "UNION",
            "id": "interval_set_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-set-rule",
              "position": 4
            },
            "doc": "Set merging approach to use for combining interval inputs.",
            "sbg:altPrefix": "-isr",
            "sbg:category": "Optional Arguments",
            "label": "Interval set rule"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals_file",
            "sbg:fileTypes": "BED",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--intervals",
              "position": 4
            },
            "doc": "File which contains one or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Include intervals file"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--intervals', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Include intervals string"
          },
          {
            "type": "string?",
            "id": "keep_read_group",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--keep-read-group",
              "position": 4
            },
            "label": "Keep read group",
            "sbg:category": "Conditional Arguments",
            "doc": "The name of the read group to keep. Valid only if \"ReadGroupReadFilter\" is specified."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "keep_reverse_strand_only",
            "doc": "Keep only reads on the reverse strand. Valid only if \"ReadStrandFilter\" is specified",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--keep-reverse-strand-only",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Keep reverse strand only"
          },
          {
            "type": "string[]?",
            "id": "library",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--library', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "position": 4
            },
            "doc": "Name of the library to keep. Valid only if \"LibraryReadFilter\" is specified",
            "sbg:altPrefix": "-library",
            "sbg:category": "Conditional Arguments",
            "label": "Library"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1000000",
            "id": "max_fragment_length",
            "doc": "Maximum length of fragment (insert size). Valid only if \"FragmentLengthReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-fragment-length",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Max fragment length"
          },
          {
            "type": "int?",
            "id": "max_read_length",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-read-length",
              "position": 4
            },
            "label": "Max read length",
            "sbg:category": "Conditional Arguments",
            "doc": "Keep only reads with length at most equal to the specified value. Valid only if \"ReadLengthReadFilter\" is specified."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "maximum_mapping_quality",
            "doc": "Maximum mapping quality to keep (inclusive). Valid only if \"MappingQualityReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--maximum-mapping-quality",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Maximum mapping quality"
          },
          {
            "type": "int?",
            "id": "memory_overhead_per_job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "id": "memory_per_job",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "min_read_length",
            "doc": "Keep only reads with length at least equal to the specified value. Valid only if \"ReadLengthReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--min-read-length",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Min read length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "minimum_mapping_quality",
            "doc": "Minimum mapping quality to keep (inclusive). Valid only if \"MappingQualityReadFilter\" is specified.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--minimum-mapping-quality",
              "position": 4
            },
            "sbg:category": "Conditional Arguments",
            "label": "Minimum mapping quality"
          },
          {
            "type": "string[]?",
            "id": "platform_filter_name",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--platform-filter-name', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "label": "Platform filter name",
            "sbg:category": "Conditional Arguments",
            "doc": "Platform attribute (PL) to match. Valid only if \"PlatformReadFilter\" is specified."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "6",
            "id": "preserve_qscores_less_than",
            "doc": "Don't recalibrate bases with quality scores less than this threshold.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--preserve-qscores-less-than",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Preserve qscores less than"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "quantize_quals",
            "doc": "Quantize quality scores to a given number of levels. Cannot be used in conjuction with argument(s) staticQuantizationQuals, roundDown.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--quantize-quals",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Quantize quals"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "read_filter",
                  "symbols": [
                    "AlignmentAgreesWithHeaderReadFilter",
                    "AllowAllReadsReadFilter",
                    "AmbiguousBaseReadFilter",
                    "CigarContainsNoNOperator",
                    "FirstOfPairReadFilter",
                    "FragmentLengthReadFilter",
                    "GoodCigarReadFilter",
                    "HasReadGroupReadFilter",
                    "LibraryReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "MatchingBasesAndQualsReadFilter",
                    "MateDifferentStrandReadFilter",
                    "MateOnSameContigOrNoMappedMateReadFilter",
                    "MetricsReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroFragmentLengthReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotOpticalDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "NotSupplementaryAlignmentReadFilter",
                    "OverclippedReadFilter",
                    "PairedReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "PlatformReadFilter",
                    "PlatformUnitReadFilter",
                    "PrimaryLineReadFilter",
                    "ProperlyPairedReadFilter",
                    "ReadGroupBlackListReadFilter",
                    "ReadGroupReadFilter",
                    "ReadLengthEqualsCigarLengthReadFilter",
                    "ReadLengthReadFilter",
                    "ReadNameReadFilter",
                    "ReadStrandFilter",
                    "SampleReadFilter",
                    "SecondOfPairReadFilter",
                    "SeqIsStoredReadFilter",
                    "ValidAlignmentEndReadFilter",
                    "ValidAlignmentStartReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "read_filter",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--read-filter', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "position": 4
            },
            "doc": "Read filters to be applied before analysis.",
            "sbg:altPrefix": "-RF",
            "sbg:category": "Optional Arguments",
            "label": "Read filter"
          },
          {
            "type": "string[]?",
            "id": "read_group_black_list",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--read-group-black-list', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "position": 4
            },
            "label": "Read group black list",
            "sbg:category": "Conditional Arguments",
            "doc": "The name of the read group to filter out. Valid only if \"ReadGroupBlackListReadFilter\" is specified."
          },
          {
            "type": "string?",
            "id": "read_name",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--read-name",
              "position": 4
            },
            "label": "Read name",
            "sbg:category": "Conditional Arguments",
            "doc": "Keep only reads with this read name. Valid only if \"ReadNameReadFilter\" is specified."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "read_validation_stringency",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "SILENT",
            "id": "read_validation_stringency",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--read-validation-stringency",
              "position": 4
            },
            "doc": "Validation stringency for all SAM/BAM/CRAM files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded.",
            "sbg:altPrefix": "-VS",
            "sbg:category": "Optional Arguments",
            "label": "Read validation stringency"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "secondaryFiles": [
              ".fai",
              "^.dict"
            ],
            "id": "in_reference",
            "sbg:fileTypes": "FASTA, FA",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--reference",
              "position": 4
            },
            "doc": "Reference sequence.",
            "sbg:altPrefix": "-R",
            "sbg:category": "Optional Arguments",
            "label": "Reference"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "round_down_quantized",
            "doc": "Round quals down to nearest quantized qual. Cannot be used in conjuction with argument quantizationLevels.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--round-down-quantized",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Round down quantized"
          },
          {
            "type": "string[]?",
            "id": "sample",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--sample', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "position": 4
            },
            "doc": "The name of the sample(s) to keep, filtering out all others. Valid only if \"SampleReadFilter\" is specified.",
            "sbg:altPrefix": "-sample",
            "sbg:category": "Conditional Arguments",
            "label": "Sample"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "10.0",
            "id": "seconds_between_progress_updates",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--seconds-between-progress-updates",
              "position": 4
            },
            "doc": "Output traversal statistics every time this many seconds elapse.",
            "sbg:altPrefix": "-seconds-between-progress-updates",
            "sbg:category": "Optional Arguments",
            "label": "Seconds between progress updates"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "10.0",
            "id": "sequence_dictionary",
            "sbg:fileTypes": "DICT",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sequence-dictionary",
              "position": 4
            },
            "doc": "Use the given sequence dictionary as the master/canonical sequence dictionary. Must be a .dict file.",
            "sbg:altPrefix": "-sequence-dictionary",
            "sbg:category": "Optional Arguments",
            "label": "Sequence dictionary"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "null",
            "id": "static_quantized_quals",
            "doc": "Use static quantized quality scores to a given number of levels (with -bqsr). Cannot be used in conjuction with argument(s) quantizationLevels.",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--static-quantized-quals', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Static quantized quals"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "use_original_qualities",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--use-original-qualities",
              "position": 4
            },
            "doc": "Use the base quality scores from the OQ tag.",
            "sbg:altPrefix": "-OQ",
            "sbg:category": "Optional Arguments",
            "label": "Use original qualities"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform Options",
            "doc": "This input allows a user to set the desired CPU requirement when running a tool or adding it to a workflow."
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output file name prefix.",
            "label": "Output prefix",
            "sbg:category": "Optional Arguments"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_file_format",
                "symbols": [
                  "sam",
                  "bam",
                  "cram"
                ]
              }
            ],
            "id": "output_file_format",
            "doc": "Output file format",
            "label": "Output file format",
            "sbg:category": "Optional Arguments"
          }
        ],
        "cwlVersion": "v1.0",
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "--java-options",
            "shellQuote": false,
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    return '\\\"-XX:+PrintFlagsFinal -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:gc_log.log -XX:GCTimeLimit=50 -XX:GCHeapFreeLimit=10 -Xms3000m\\\"';\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "ApplyBQSR",
            "shellQuote": false,
            "position": 3
          },
          {
            "valueFrom": "${\n    var in_alignments = inputs.in_alignments;\n    var output_ext = inputs.output_file_format ? inputs.output_file_format : in_alignments.path.split('.').pop();\n    var output_prefix = '';\n    if (inputs.output_prefix)\n    {\n        output_prefix = inputs.output_prefix;\n    }\n    else \n    {\n        if (in_alignments.metadata && in_alignments.metadata.sample_id)\n        {\n            output_prefix = in_alignments.metadata.sample_id;\n        }\n        else \n        {\n            output_prefix = in_alignments.path.split('/').pop().split('.')[0];\n        }\n    }\n    \n    return \"--output \" + output_prefix + \".recalibrated.\" + output_ext;\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          },
          {
            "valueFrom": "${\n    var output_ext = inputs.output_file_format ? inputs.output_file_format :\n    inputs.in_alignments.path.split('.').pop();\n    if (output_ext == \"cram\")\n    {\n        return '&& for i in *cram.bai; do mv \"$i\" \"${i%.cram.bai}.cram.crai\";  done';\n    }\n    else {\n        return ''; \n    } \n}",
            "shellQuote": false,
            "prefix": "",
            "position": 5
          }
        ],
        "sbg:modifiedOn": 1559744828,
        "sbg:publisher": "sbg",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "4.1.0.0",
        "sbg:revision": 10,
        "sbg:categories": [
          "Utilities",
          "BAM Processing"
        ]
      },
      "in": [
        {
          "id": "add_output_sam_program_record",
          "default": "true"
        },
        {
          "source": "gatk_baserecalibrator_4_1_0_0/output",
          "id": "bqsr_recal_file"
        },
        {
          "source": "gatk_splitncigarreads_4_1_0_0/out_alignments",
          "id": "in_alignments"
        },
        {
          "source": "in_reference",
          "id": "in_reference"
        },
        {
          "id": "use_original_qualities",
          "default": true
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        }
      ],
      "sbg:y": -247.38088989257812,
      "label": "GATK ApplyBQSR",
      "sbg:x": 1567.825439453125,
      "out": [
        {
          "id": "out_alignments"
        }
      ]
    },
    {
      "id": "gatk_haplotypecaller_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 7,
        "sbg:modifiedBy": "nemanja.vucic",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://www.broadinstitute.org/gatk/index.php"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.0.12.0/gatk-4.0.12.0.zip"
          },
          {
            "label": "Publication",
            "id": "https://www.biorxiv.org/content/10.1101/201178v3"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/org_broadinstitute_hellbender_tools_walkers_haplotypecaller_HaplotypeCaller.php"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n  var memory = 6500;\n  \n  if(inputs.mem_per_job){\n  \t memory = inputs.mem_per_job\n  }\n  if(inputs.mem_overhead_per_job){\n\treturn memory + inputs.mem_overhead_per_job; \n  }\n  else{\n  \treturn memory;\n  }\n}",
            "coresMin": "${\n    if(inputs.cpu_per_job){\n        return inputs.cpu_per_job;\n    } else {\n        return 1;\n    }\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "Call germline single nucleotide polymorphisms (SNPs) and indels via local re-assembly of haplotypes. To call SNPs and indels, **HaplotypeCaller** requires BAM file(s) containing reads aligned to the reference genome.\n\n**HaplotypeCaller** is capable of calling SNPs and indels simultaneously via local de-novo assembly of haplotypes in an active region. In other words, whenever the program encounters a region showing signs of variation, it discards the existing mapping information and completely reassembles the reads in that region. Reassembled reads are realigned to the reference. This allows **HaplotypeCaller** to be more accurate when calling regions that are traditionally difficult to call, for example when they contain different types of variants close to each other. It also makes **HaplotypeCaller** much better at calling indels than position-based callers like UnifiedGenotyper.\n\nIn the GVCF workflow used for scalable variant calling in DNA sequence data, **HaplotypeCaller** runs per-sample to generate an intermediate GVCF (not to be used in final analysis), which can then be used in GenotypeGVCFs for joint genotyping of multiple samples in a very efficient way. The GVCF workflow enables rapid incremental processing of samples as they roll off the sequencer, as well as scaling to very large cohort sizes. \n\nIn addition, **HaplotypeCaller** is able to handle non-diploid organisms as well as pooled experiment data. Note however that the algorithms used to calculate variant likelihoods are not well suited to extreme allele frequencies (relative to ploidy) so its use is not recommended for somatic (cancer) variant discovery. For that purpose, use **Mutect2** instead.\n\nFinally, **HaplotypeCaller** is also able to correctly handle splice junctions that make RNAseq a challenge for most variant callers.\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of this page.*\n\n### Common Use Cases\n\n- Call variants individually on each sample in GVCF mode\n\n```\n gatk --java-options \"-Xmx4g\" HaplotypeCaller  \\\n   -R Homo_sapiens_assembly38.fasta \\\n   -I input.bam \\\n   -O output.g.vcf.gz \\\n   -ERC GVCF\n```\n\n\n- Call variants individually on each sample in GVCF mode with allele-specific annotations. [Here](https://software.broadinstitute.org/gatk/documentation/article?id=9622) you can read more details about allele-specific annotation and filtering.\n\n```\ngatk --java-options \"-Xmx4g\" HaplotypeCaller  \\\n   -R Homo_sapiens_assembly38.fasta \\\n   -I input.bam \\\n   -O output.g.vcf.gz \\\n   -ERC GVCF \\\n   -G Standard \\\n   -G AS_Standard\n```\n\n\n- Call variants with [bamout](https://software.broadinstitute.org/gatk/documentation/article?id=5484) to show realigned reads. After performing a local reassembly and realignment the reads get moved to different mapping positions than what you can observe in the original BAM file. This option could be used to visualize what rearrangements **HaplotypeCaller** has made.\n\n```\n gatk --java-options \"-Xmx4g\" HaplotypeCaller  \\\n   -R Homo_sapiens_assembly38.fasta \\\n   -I input.bam \\\n   -O output.vcf.gz \\\n   -bamout bamout.bam\n```\n\n\n### Common issues and important notes\n\n- If **Read filter** (`--read-filter`) option is set to \"LibraryReadFilter\", **Library** (`--library`) option must be set to some value.\n- If **Read filter** (`--read-filter`) option is set to \"PlatformReadFilter\", **Platform filter name** (`--platform-filter-name`) option must be set to some value.\n- If **Read filter** (`--read-filter`) option is set to\"PlatformUnitReadFilter\", **Black listed lanes** (`--black-listed-lanes`) option must be set to some value. \n- If **Read filter** (`--read-filter`) option is set to \"ReadGroupBlackListReadFilter\", **Read group black list** (`--read-group-black-list`) option must be set to some value.\n- If **Read filter** (`--read-filter`) option is set to \"ReadGroupReadFilter\", **Keep read group** (`--keep-read-group`) option must be set to some value.\n- If **Read filter** (`--read-filter`) option is set to \"ReadLengthReadFilter\", **Max read length** (`--max-read-length`) option must be set to some value.\n- If **Read filter** (`--read-filter`) option is set to \"ReadNameReadFilter\", **Read name** (`--read-name`) option must be set to some value.\n- If **Read filter** (`--read-filter`) option is set to \"ReadStrandFilter\", **Keep reverse strand only** (`--keep-reverse-strand-only`) option must be set to some value.\n- If **Read filter** (`--read-filter`) option is set to \"SampleReadFilter\", **Sample** (`--sample`) option must be set to some value.\n- When working with PCR-free data, be sure to set **PCR indel model** (`--pcr_indel_model`) to NONE.\n- When running **Emit ref confidence** ( `--emit-ref-confidence`) in GVCF or in BP_RESOLUTION mode, the confidence threshold is automatically set to 0. This cannot be overridden by the command line. The threshold can be set manually to the desired level when using **GenotypeGVCFs**.\n- It is recommended to use a list of intervals to speed up the analysis. See [this document](https://software.broadinstitute.org/gatk/documentation/article?id=4133) for details.\n\n### Changes Introduced by Seven Bridges\n\n- **Include intervals** (`--intervals`) option is divided into **Include genomic intervals** and **Intervals string values** options.\n- **Exclude intervals** (`--exclude-intervals`) option is divided into **Exclude genomic intervals** and **Exclude intervals string values** options.\n- Using the **Output prefix** parameter you can set the name of the VCF output. If this value is not set the output name will be generated based on **Sample ID** metadata value from one of the input BAM files. If **Sample ID** value is not set the name will be inherited from one of the input BAM file names.\n\n### Performance Benchmarking\n\nBelow is a table describing the runtimes and task costs for a couple of samples with different file sizes.\n\n| Experiment type |  Input size | Paired-end | # of reads | Read length | Duration |  Cost (spot) | Cost (on-demand) | AWS instance type |\n|:--------------:|:------------:|:--------:|:-------:|:---------:|:----------:|:------:|:------:|:------:|\n|     RNA-Seq     | 2.6 GB |     Yes    |     16M     |     101     |   50min   | 0.22$ | 0.44$ | c4.2xlarge |\n|     RNA-Seq     | 7.7 GB |     Yes    |     50M     |     101     |   1h31min   | 0.40$ | 0.87$ | c4.2xlarge |\n|     RNA-Seq     | 12.7 GB |     Yes    |     82M    |     101     |  2h19min  | 0.61$ | 1.22$ | c4.2xlarge |\n|     RNA-Seq     | 25 GB |     Yes    |     164M    |     101     |  4h5min  | 1.07$ | 2.43 | c4.2xlarge |",
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/19",
        "sbg:createdOn": 1553086627,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-haplotypecaller-4-1-0-0/7",
        "sbg:image_url": null,
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:toolkit": "GATK",
        "sbg:content_hash": "aad5a3e87aca93b604708277a3ea29a56b099eb4bb91277df56f7585612fb1a54",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1553086627,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/4",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1553105347,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/8",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554720901,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/13",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554730721,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/14",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999234,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/15",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559736399,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/17",
            "sbg:modifiedBy": "nemanja.vucic"
          },
          {
            "sbg:modifiedOn": 1559746054,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/18",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559750439,
            "sbg:revision": 7,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/19",
            "sbg:modifiedBy": "nemanja.vucic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-haplotypecaller-4-1-0-0/19",
        "label": "GATK HaplotypeCaller",
        "sbg:contributors": [
          "uros_sipetic",
          "nemanja.vucic",
          "veliborka_josipovic"
        ],
        "outputs": [
          {
            "type": "File?",
            "secondaryFiles": [
              "${ \n    if(inputs.output_extension == 'vcf'){\n        return self.basename + \".idx\";\n    } \n    else if (inputs.output_extension == 'vcf.gz'){\n        return self.basename + \".tbi\";\n    } else {\n        return null;\n    }\n}"
            ],
            "label": "VCF output",
            "sbg:fileTypes": "VCF",
            "id": "out_variants",
            "outputBinding": {
              "glob": "${ \n    if (inputs.output_extension == \"vcf\")\n    {\n        return \"*.vcf\";\n    }\n    else if (inputs.output_extension == \"vcf.gz\")\n    {\n        return \"*.vcf.gz\";\n    }\n    else\n    {\n        return ''\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "A raw, unfiltered, highly specific callset in VCF format."
          },
          {
            "type": "File?",
            "secondaryFiles": [
              "${ \n    return self.nameroot + \".bai\";\n}"
            ],
            "label": "BAM output",
            "sbg:fileTypes": "BAM",
            "id": "out_alignments",
            "outputBinding": {
              "glob": "${\n    if(inputs.bam_output){\n        return inputs.bam_output\n    } else {\n        return null\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "doc": "Assembled haplotypes."
          },
          {
            "type": "File?",
            "doc": "Assembly graph information.",
            "outputBinding": {
              "glob": "${\n    if(inputs.graph_output){\n        return inputs.graph_output\n    } else {\n        return null\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_alignments))"
            },
            "label": "Graph output",
            "id": "out_graph"
          }
        ],
        "sbg:id": "h-decac271/h-ebb5bb74/h-e575ade4/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.002",
            "id": "active_probability_threshold",
            "doc": "Minimum probability for a locus to be considered active.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--active-probability-threshold",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Active probability threshold"
          },
          {
            "type": "string?",
            "id": "activity_profile_out",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--activity-profile-out",
              "position": 4
            },
            "label": "Activity profile output",
            "sbg:category": "Optional Arguments",
            "doc": "Output the raw activity profile results in IGV format."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "adaptive_pruning",
            "doc": "Use Mutect2's adaptive graph pruning algorithm.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--adaptive-pruning",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Adaptive pruning"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.001",
            "id": "adaptive_pruning_initial_error_rate",
            "doc": "Initial base error rate estimate for adaptive pruning.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--adaptive-pruning-initial-error-rate",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Adaptive pruning initial error rate"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "add_output_sam_program_record",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "add_output_sam_program_record",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--add-output-sam-program-record",
              "position": 4
            },
            "doc": "If true, adds a pg tag to created SAM/BAM/CRAM files.",
            "sbg:altPrefix": "-add-output-sam-program-record",
            "sbg:category": "Optional Arguments",
            "label": "Add output SAM program record"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "add_output_vcf_command_line",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "add_output_vcf_command_line",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--add-output-vcf-command-line",
              "position": 4
            },
            "doc": "If true, adds a command line header line to created VCF files.",
            "sbg:altPrefix": "-add-output-vcf-command-line",
            "sbg:category": "Optional Arguments",
            "label": "Add output VCF command line"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "all_site_pls",
            "doc": "Annotate all sites with PLs.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--all-site-pls",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Annotate all sites with PLs"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "alleles",
            "sbg:fileTypes": "BCF2, VCF, VCF3",
            "secondaryFiles": [
              ".idx"
            ],
            "doc": "The set of alleles at which to genotype when --genotyping_mode is genotype_given_alleles.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alleles",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Alleles"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "allow_non_unique_kmers_in_ref",
            "doc": "Allow graphs that have non-unique kmers in the reference.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--allow-non-unique-kmers-in-ref",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Allow non unique kmers in ref"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "annotate_with_num_discovered_alleles",
            "doc": "If provided, we will annotate records with the number of alternate alleles that were discovered (but not necessarily genotyped) at a given site.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--annotate-with-num-discovered-alleles",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Annotate with num discovered alleles"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "annotation",
                  "symbols": [
                    "AlleleFraction",
                    "AS_BaseQualityRankSumTest",
                    "AS_FisherStrand",
                    "AS_InbreedingCoeff",
                    "AS_MappingQualityRankSumTest",
                    "AS_QualByDepth",
                    "AS_ReadPosRankSumTest",
                    "AS_RMSMappingQuality",
                    "AS_StrandOddsRatio",
                    "BaseQuality",
                    "BaseQualityRankSumTest",
                    "ChromosomeCounts",
                    "ClippingRankSumTest",
                    "CountNs",
                    "Coverage",
                    "DepthPerAlleleBySample",
                    "DepthPerSampleHC",
                    "ExcessHet",
                    "FisherStrand",
                    "FragmentLength",
                    "GenotypeSummaries",
                    "InbreedingCoeff",
                    "LikelihoodRankSumTest",
                    "MappingQuality",
                    "MappingQualityRankSumTest",
                    "MappingQualityZero",
                    "OriginalAlignment",
                    "OxoGReadCounts",
                    "PolymorphicNuMT",
                    "PossibleDeNovo",
                    "QualByDepth",
                    "ReadOrientationArtifact",
                    "ReadPosition",
                    "ReadPosRankSumTest",
                    "ReferenceBases",
                    "RMSMappingQuality",
                    "SampleList",
                    "StrandArtifact",
                    "StrandBiasBySample",
                    "StrandOddsRatio",
                    "TandemRepeat",
                    "UniqueAltReadCount"
                  ]
                }
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "annotation",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--annotation ' + self.join(' --annotation ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "itemSeparator": "null",
              "prefix": "",
              "position": 4
            },
            "doc": "One or more specific annotations to add to variant calls.",
            "sbg:altPrefix": "-A",
            "sbg:category": "Optional Arguments",
            "label": "Annotation"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "annotation_group",
                  "symbols": [
                    "AS_StandardAnnotation",
                    "OrientationBiasMixtureModelAnnotation",
                    "ReducibleAnnotation",
                    "StandardAnnotation",
                    "StandardHCAnnotation",
                    "StandardMutectAnnotation"
                  ]
                }
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "annotation_group",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--annotation-group ' + self.join(' --annotation-group ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more groups of annotations to apply to variant calls.",
            "sbg:altPrefix": "-G",
            "sbg:category": "Optional Arguments",
            "label": "Annotation group"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "annotations_to_exclude",
                  "symbols": [
                    "BaseQualityRankSumTest",
                    "ChromosomeCounts",
                    "Coverage",
                    "DepthPerAlleleBySample",
                    "DepthPerSampleHC",
                    "ExcessHet",
                    "FisherStrand",
                    "InbreedingCoeff",
                    "MappingQualityRankSumTest",
                    "QualByDepth",
                    "ReadPosRankSumTest",
                    "RMSMappingQuality",
                    "StrandOddsRatio"
                  ]
                }
              }
            ],
            "sbg:toolDefaultValue": "null",
            "id": "annotations_to_exclude",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--annotations-to-exclude ' + self.join(' --annotations-to-exclude ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more specific annotations to exclude from variant calls.",
            "sbg:altPrefix": "-AX",
            "sbg:category": "Optional Arguments",
            "label": "Annotations to exclude"
          },
          {
            "type": "File[]?",
            "sbg:toolDefaultValue": "null",
            "id": "arguments_file",
            "sbg:fileTypes": "TXT",
            "doc": "Read one or more arguments files and add them to the command line.",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        var cmd = '';\n        for (var i=0; i<self.length; i++) {\n            cmd += ' --arguments_file ' + self[i].path\n        }\n        return cmd\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Arguments"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "assembly_region_out",
            "doc": "Output the assembly region to this IGV formatted file.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--assembly-region-out",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Assembly region output"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "100",
            "id": "assembly_region_padding",
            "doc": "Number of additional bases of context to include around each assembly region.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--assembly-region-padding",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Assembly region padding"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "bam_output",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--bam-output",
              "position": 4
            },
            "doc": "File to which assembled haplotypes should be written.",
            "sbg:altPrefix": "-bamout",
            "sbg:category": "Advanced Arguments",
            "label": "BAM output"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "bam_writer_type",
                "symbols": [
                  "ALL_POSSIBLE_HAPLOTYPES",
                  "CALLED_HAPLOTYPES"
                ]
              }
            ],
            "sbg:toolDefaultValue": "CALLED_HAPLOTYPES",
            "id": "bam_writer_type",
            "doc": "Which haplotypes should be written to the BAM.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--bam-writer-type",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "BAM writer type"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "18",
            "id": "base_quality_score_threshold",
            "doc": "Base qualities below this threshold will be reduced to the minimum (6).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--base-quality-score-threshold",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Base quality score threshold"
          },
          {
            "type": "File[]?",
            "sbg:toolDefaultValue": "null",
            "id": "comp",
            "sbg:fileTypes": "VCF",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        var cmd = '';\n        for (var i=0; i<self.length; i++) {\n            cmd += ' --comp ' + self[i].path\n        }\n        return cmd\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Comparison vcf file(s).",
            "sbg:altPrefix": "-comp",
            "sbg:category": "Advanced Arguments",
            "label": "Comparison VCF"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "consensus",
            "doc": "1000g consensus mode.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--consensus",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Consensus"
          },
          {
            "type": "File?",
            "id": "contamination_fraction_per_sample_file",
            "sbg:fileTypes": "TSV",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--contamination-fraction-per-sample-file",
              "position": 4
            },
            "doc": "Tab-separated file containing fraction of contamination in sequencing data (per sample) to aggressively remove. Format should be \".",
            "sbg:altPrefix": "-contamination-file",
            "sbg:category": "Advanced Arguments",
            "label": "Contamination fraction per sample"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0",
            "id": "contamination_fraction_to_filter",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--contamination-fraction-to-filter",
              "position": 4
            },
            "doc": "Fraction of contamination in sequencing data (for all samples) to aggressively remove 0.",
            "sbg:altPrefix": "-contamination",
            "sbg:category": "Optional Arguments",
            "label": "Contamination fraction to filter"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "correct_overlapping_quality",
            "doc": "Undocumented option.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--correct-overlapping-quality",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Correct overlapping quality"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "create_output_bam_index",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "create_output_bam_index",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--create-output-bam-index",
              "position": 4
            },
            "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file.",
            "sbg:altPrefix": "-OBI",
            "sbg:category": "Optional Arguments",
            "label": "Create output BAM index"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "create_output_bam_md5",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--create-output-bam-md5",
              "position": 4
            },
            "doc": "If true, create a md5 digest for any BAM/SAM/CRAM file created.",
            "sbg:altPrefix": "-OBM",
            "sbg:category": "Optional Arguments",
            "label": "Create output BAM md5"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "create_output_variant_index",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "create_output_variant_index",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--create-output-variant-index",
              "position": 4
            },
            "doc": "If true, create a vcf index when writing a coordinate-sorted VCF file.",
            "sbg:altPrefix": "-OVI",
            "sbg:category": "Optional Arguments",
            "label": "Create output variant index"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "create_output_variant_md5",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--create-output-variant-md5",
              "position": 4
            },
            "doc": "If true, create a a md5 digest any VCF file created.",
            "sbg:altPrefix": "-OVM",
            "sbg:category": "Optional Arguments",
            "label": "Create output variant md5"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "secondaryFiles": [
              ".idx"
            ],
            "id": "dbsnp",
            "sbg:fileTypes": "VCF",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--dbsnp",
              "position": 4
            },
            "doc": "dbSNP file.",
            "sbg:altPrefix": "-D",
            "sbg:category": "Optional Arguments",
            "label": "dbSNP"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "debug",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--debug",
              "position": 4
            },
            "doc": "Print out very verbose debug information about each triggering active region.",
            "sbg:altPrefix": "-debug",
            "sbg:category": "Advanced Arguments",
            "label": "Debug"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_bam_index_caching",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-bam-index-caching",
              "position": 4
            },
            "doc": "If true, don't cache BAM indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified.",
            "sbg:altPrefix": "-DBIC",
            "sbg:category": "Optional Arguments",
            "label": "Disable BAM index caching"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_optimizations",
            "doc": "Don't skip calculations in activeregions with no variants.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-optimizations",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Disable optimizations"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "disable_read_filter",
                  "symbols": [
                    "GoodCigarReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "id": "disable_read_filter",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--disable-read-filter ' + self.join(' --disable-read-filter ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Read filters to be disabled before analysis.",
            "sbg:altPrefix": "-DF",
            "sbg:category": "Optional Arguments",
            "label": "Disable read filter"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_sequence_dictionary_validation",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-sequence-dictionary-validation",
              "position": 4
            },
            "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk!",
            "sbg:altPrefix": "-disable-sequence-dictionary-validation",
            "sbg:category": "Optional Arguments",
            "label": "Disable sequence dictionary validation"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_annotations",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-tool-default-annotations",
              "position": 4
            },
            "doc": "Disable all tool default annotations.",
            "sbg:altPrefix": "-disable-tool-default-annotations",
            "sbg:category": "Advanced Arguments",
            "label": "Disable tool default annotations"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_read_filters",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-tool-default-read-filters",
              "position": 4
            },
            "doc": "Disable all tool default read filters (warning: many tools will not function correctly without their default read filters on).",
            "sbg:altPrefix": "-disable-tool-default-read-filters",
            "sbg:category": "Advanced Arguments",
            "label": "Disable tool default read filters"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "do_not_run_physical_phasing",
            "doc": "Disable physical phasing.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--do-not-run-physical-phasing",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Do not run physical phasing"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "dont_increase_kmer_sizes_for_cycles",
            "doc": "Disable iterating over kmer sizes when graph cycles are detected.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--dont-increase-kmer-sizes-for-cycles",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Dont increase kmer sizes for cycles"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "dont_trim_active_regions",
            "doc": "If specified, we will not trim down the active region from the full region (active + extension) to just the active interval for genotyping.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--dont-trim-active-regions",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Dont trim active regions"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "dont_use_soft_clipped_bases",
            "doc": "Do not analyze soft clipped bases in the reads.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--dont-use-soft-clipped-bases",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Do not use soft clipped bases"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "emit_ref_confidence",
                "symbols": [
                  "NONE",
                  "BP_RESOLUTION",
                  "GVCF"
                ]
              }
            ],
            "sbg:toolDefaultValue": "NONE",
            "id": "emit_ref_confidence",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--emit-ref-confidence",
              "position": 4
            },
            "doc": "Mode for emitting reference confidence scores.",
            "sbg:altPrefix": "-ERC",
            "sbg:category": "Advanced Arguments",
            "label": "Emit ref confidence"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "enable_all_annotations",
            "doc": "Use all possible annotations (not for the faint of heart).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--enable-all-annotations",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Enable all annotations"
          },
          {
            "type": "string[]?",
            "id": "exclude_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--exclude-intervals ' + self.join(' --exclude-intervals ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude intervals string values"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "founder_id",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--founder-id ' + self.join(' --founder-id ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Samples representing the population \"founders\".",
            "sbg:altPrefix": "-founder-id",
            "sbg:category": "Optional Arguments",
            "label": "Founder id"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "gatk_config_file",
            "sbg:fileTypes": "TXT",
            "doc": "A configuration file to use with the GATK.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--gatk-config-file",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "GATK config"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "20",
            "id": "gcs_max_retries",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--gcs-max-retries",
              "position": 4
            },
            "doc": "If the GCS bucket channel errors out, how many times it will attempt to re-initiate the connection.",
            "sbg:altPrefix": "-gcs-retries",
            "sbg:category": "Optional Arguments",
            "label": "GCS max retries"
          },
          {
            "type": "string?",
            "id": "gcs_project_for_requester_pays",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--gcs-project-for-requester-pays",
              "position": 4
            },
            "label": "GCS project for requester pays",
            "sbg:category": "Optional Arguments",
            "doc": "Project to bill when accessing \"requester pays\" buckets. If unset, these buckets cannot be accessed. Default value: ."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "genotype_filtered_alleles",
            "doc": "Whether to genotype all given alleles, even filtered ones, --genotyping_mode is genotype_given_alleles.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--genotype-filtered-alleles",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Genotype filtered alleles"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "genotyping_mode",
                "symbols": [
                  "DISCOVERY",
                  "GENOTYPE_GIVEN_ALLELES"
                ]
              }
            ],
            "sbg:toolDefaultValue": "DISCOVERY",
            "id": "genotyping_mode",
            "doc": "Specifies how to determine the alternate alleles to use for genotyping.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--genotyping-mode",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Genotyping mode"
          },
          {
            "type": "string?",
            "id": "graph_output",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--graph-output",
              "position": 4
            },
            "doc": "Write debug assembly graph information to this file.",
            "sbg:altPrefix": "-graph",
            "sbg:category": "Optional Arguments",
            "label": "Graph output"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 70, 80, 90, 99",
            "id": "gvcf_gq_bands",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--gvcf-gq-bands ' + self.join(' --gvcf-gq-bands ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Exclusive upper bounds for reference confidence GQ bands (must be value from 1 to 100 and specified in increasing order).",
            "sbg:altPrefix": "-GQB",
            "sbg:category": "Advanced Arguments",
            "label": "GVCF GQ bands"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.001",
            "id": "heterozygosity",
            "doc": "Heterozygosity value used to compute prior likelihoods for any locus. See the gatkdocs for full details on the meaning of this population genetics concept.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--heterozygosity",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Heterozygosity"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.01",
            "id": "heterozygosity_stdev",
            "doc": "Standard deviation of heterozygosity for SNP and indel calling.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--heterozygosity-stdev",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Heterozygosity stdev"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "1.25E-4",
            "id": "indel_heterozygosity",
            "doc": "Heterozygosity for indel calling. See the gatkdocs for heterozygosity for full details on the meaning of this population genetics concept.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--indel-heterozygosity",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Indel heterozygosity"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "indel_size_to_eliminate_in_ref_model",
            "doc": "The size of an indel to check for in the reference model.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--indel-size-to-eliminate-in-ref-model",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Indel size to eliminate in ref model"
          },
          {
            "type": "File[]",
            "secondaryFiles": [
              "${ \n    if(self.nameext == '.bam'){\n    return self.nameroot + \".bai\";\n    }\n    else if(self.nameext == '.cram'){\n    return self.nameroot + \".crai\";\n    } else {\n    return null;\n    }\n}"
            ],
            "id": "in_alignments",
            "sbg:fileTypes": "BAM, SAM, CRAM",
            "inputBinding": {
              "valueFrom": "${\n    var in_files = [].concat(inputs.in_alignments);\n    if (in_files) {\n        var cmd = '';\n        for (var i=0; i<in_files.length; i++) {\n            cmd += ' --input ' + in_files[i].path\n        }\n        return cmd\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "BAM/SAM/CRAM file containing reads this argument must be specified at least once.",
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "label": "Input alignments"
          },
          {
            "type": "float[]?",
            "id": "input_prior",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--input-prior ' + self.join(' --input-prior ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "label": "Input prior",
            "sbg:category": "Advanced Arguments",
            "doc": "Input prior for calls."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_exclusion_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-exclusion-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are excluding.",
            "sbg:altPrefix": "-ixp",
            "sbg:category": "Optional Arguments",
            "label": "Interval exclusion padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_merging_rule",
                "symbols": [
                  "ALL",
                  "OVERLAPPING_ONLY"
                ]
              }
            ],
            "sbg:toolDefaultValue": "ALL",
            "id": "interval_merging_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-merging-rule",
              "position": 4
            },
            "doc": "Interval merging rule for abutting intervals.",
            "sbg:altPrefix": "-imr",
            "sbg:category": "Optional Arguments",
            "label": "Interval merging rule"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are including.",
            "sbg:altPrefix": "-ip",
            "sbg:category": "Optional Arguments",
            "label": "Interval padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_set_rule",
                "symbols": [
                  "UNION",
                  "INTERSECTION"
                ]
              }
            ],
            "sbg:toolDefaultValue": "UNION",
            "id": "interval_set_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-set-rule",
              "position": 4
            },
            "doc": "Set merging approach to use for combining interval inputs.",
            "sbg:altPrefix": "-isr",
            "sbg:category": "Optional Arguments",
            "label": "Interval set rule"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals",
            "sbg:fileTypes": "INTERVAL_LIST",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--intervals",
              "position": 4
            },
            "doc": "One or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Include genomic intervals"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--intervals ' + self.join(' --intervals ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Intervals string values"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "10, 25",
            "id": "kmer_size",
            "doc": "Kmer size to use in the read threading assembler.",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--kmer-size ' + self.join(' --kmer-size ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Kmer size"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "lenient",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--lenient",
              "position": 4
            },
            "doc": "Lenient processing of VCF files.",
            "sbg:altPrefix": "-LE",
            "sbg:category": "Optional Arguments",
            "label": "Lenient"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "6",
            "id": "max_alternate_alleles",
            "doc": "Maximum number of alternate alleles to genotype.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-alternate-alleles",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Max alternate alleles"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "300",
            "id": "max_assembly_region_size",
            "doc": "Maximum size of an assembly region.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-assembly-region-size",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Max assembly region size"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1024",
            "id": "max_genotype_count",
            "doc": "Maximum number of genotypes to consider at any site.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-genotype-count",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Max genotype count"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "max_mnp_distance",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-mnp-distance",
              "position": 4
            },
            "doc": "Two or more phased substitutions separated by this distance or less are merged into MNPs. Warning: when used in GVCF mode, resulting GVCFs cannot be joint-genotyped.",
            "sbg:altPrefix": "-mnp-dist",
            "sbg:category": "Advanced Arguments",
            "label": "Max MNP distance"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "128",
            "id": "max_num_haplotypes_in_population",
            "doc": "Maximum number of haplotypes to consider for your population.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-num-haplotypes-in-population",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Max num haplotypes in population"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "50",
            "id": "max_prob_propagation_distance",
            "doc": "Upper limit on how many bases away probability mass can be moved around when calculating the boundaries between active and inactive assembly regions.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-prob-propagation-distance",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Max prob propagation distance"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "50",
            "id": "max_reads_per_alignment_start",
            "doc": "Maximum number of reads to retain per alignment start position. Reads above this threshold will be downsampled. Set to 0 to disable.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-reads-per-alignment-start",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Max reads per alignment start"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "100",
            "id": "max_unpruned_variants",
            "doc": "Maximum number of variants in graph the adaptive pruner will allow.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--max-unpruned-variants",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Max unpruned variants"
          },
          {
            "type": "int?",
            "id": "maximum_mapping_quality",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"MappingQualityReadFilter\") != -1){\n            return self\n        }\n    }\n}",
              "shellQuote": false,
              "prefix": "--maximum-mapping-quality",
              "position": 5
            },
            "label": "Maximum mapping quality",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"MappingQualityReadFilter\" is specified:\nMaximum mapping quality to keep (inclusive)."
          },
          {
            "type": "int?",
            "id": "mem_overhead_per_job",
            "doc": "Memory overhead per job. By default this parameter value is set to '0' (zero megabytes). This parameter value is added to the Memory per job parameter value. This results in the allocation of the sum total (Memory per job and Memory overhead per job) amount of memory per job. By default the memory per job parameter value is set to 2048 megabytes, unless specified otherwise.",
            "label": "Memory overhead per job",
            "sbg:category": "Platform options"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2048",
            "id": "mem_per_job",
            "label": "Memory per job",
            "sbg:category": "Platform options",
            "doc": "Amount of RAM memory to be used per job. Defaults to 2048MB for Single threaded jobs,and all of the available memory on the instance for multi-threaded jobs."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "50",
            "id": "min_assembly_region_size",
            "doc": "Minimum size of an assembly region.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--min-assembly-region-size",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Min assembly region size"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "min_base_quality_score",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--min-base-quality-score",
              "position": 4
            },
            "doc": "Minimum base quality required to consider a base for calling.",
            "sbg:altPrefix": "-mbq",
            "sbg:category": "Optional Arguments",
            "label": "Min base quality score"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "4",
            "id": "min_dangling_branch_length",
            "doc": "Minimum length of a dangling branch to attempt recovery.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--min-dangling-branch-length",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Min dangling branch length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "min_pruning",
            "doc": "Minimum support to not prune paths in the graph.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--min-pruning",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Min pruning"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "20",
            "id": "minimum_mapping_quality",
            "doc": "Valid only if \"MappingQualityReadFilter\" is specified:\nMinimum mapping quality to keep (inclusive).",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"MappingQualityReadFilter\") != -1){\n            return self\n        }\n    }\n}",
              "shellQuote": false,
              "prefix": "--minimum-mapping-quality",
              "position": 5
            },
            "sbg:category": "Conditional Arguments",
            "label": "Minimum mapping quality"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "4",
            "id": "native_pair_hmm_threads",
            "doc": "How many threads should a native pairHMM implementation use.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--native-pair-hmm-threads",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Native pairHMM threads"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "native_pair_hmm_use_double_precision",
            "doc": "Use double precision in the native pairHMM. This is slower but matches the java implementation better.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--native-pair-hmm-use-double-precision",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Native pairHMM use double precision"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "num_pruning_samples",
            "doc": "Number of samples that must pass the minPruning threshold.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--num-pruning-samples",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Num pruning samples"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "num_reference_samples_if_no_call",
            "doc": "Number of hom-ref genotypes to infer at sites not present in a panel.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--num-reference-samples-if-no-call",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Num reference samples if no call"
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output prefix.",
            "sbg:altPrefix": "-O",
            "sbg:category": "Required Arguments",
            "label": "Output prefix"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_mode",
                "symbols": [
                  "EMIT_VARIANTS_ONLY",
                  "EMIT_ALL_CONFIDENT_SITES",
                  "EMIT_ALL_SITES"
                ]
              }
            ],
            "sbg:toolDefaultValue": "EMIT_VARIANTS_ONLY",
            "id": "output_mode",
            "doc": "Specifies which type of calls are contained output.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--output-mode",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Output mode"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "pair_hmm_gap_continuation_penalty",
            "doc": "Flat gap continuation penalty for use in the pairHMM.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--pair-hmm-gap-continuation-penalty",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Pair HMM gap continuation penalty"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "pair_hmm_implementation",
                "symbols": [
                  "EXACT",
                  "ORIGINAL",
                  "LOGLESS_CACHING",
                  "AVX_LOGLESS_CACHING",
                  "AVX_LOGLESS_CACHING_OMP",
                  "EXPERIMENTAL_FPGA_LOGLESS_CACHING",
                  "FASTEST_AVAILABLE"
                ]
              }
            ],
            "sbg:toolDefaultValue": "FASTEST_AVAILABLE",
            "id": "pair_hmm_implementation",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--pair-hmm-implementation",
              "position": 4
            },
            "doc": "The pairHMM implementation to use for genotype likelihood calculations.",
            "sbg:altPrefix": "-pairHMM",
            "sbg:category": "Advanced Arguments",
            "label": "Pair HMM implementation"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "pcr_indel_model",
                "symbols": [
                  "NONE",
                  "HOSTILE",
                  "AGGRESSIVE",
                  "CONSERVATIVE"
                ]
              }
            ],
            "sbg:toolDefaultValue": "CONSERVATIVE",
            "id": "pcr_indel_model",
            "doc": "The PCR indel model to use.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--pcr-indel-model",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "PCR indel model"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "pedigree",
            "sbg:fileTypes": "PED",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--pedigree",
              "position": 4
            },
            "doc": "Pedigree file for determining the population \"founders\".",
            "sbg:altPrefix": "-ped",
            "sbg:category": "Optional Arguments",
            "label": "Pedigree"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "45",
            "id": "phred_scaled_global_read_mismapping_rate",
            "doc": "The global assumed mismapping rate for reads.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--phred-scaled-global-read-mismapping-rate",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Phred scaled global read mismapping rate"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "population_callset",
            "sbg:fileTypes": "VCF",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--population-callset",
              "position": 4
            },
            "doc": "Callset to use in calculating genotype priors.",
            "sbg:altPrefix": "-population",
            "sbg:category": "Optional Arguments",
            "label": "Population callset"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "1.0",
            "id": "pruning_lod_threshold",
            "doc": "Log-10 likelihood ratio threshold for adaptive pruning algorithm.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--pruning-lod-threshold",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Pruning lod threshold"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": {
                  "type": "enum",
                  "name": "read_filter",
                  "symbols": [
                    "AlignmentAgreesWithHeaderReadFilter",
                    "AllowAllReadsReadFilter",
                    "AmbiguousBaseReadFilter",
                    "CigarContainsNoNOperator",
                    "FirstOfPairReadFilter",
                    "FragmentLengthReadFilter",
                    "GoodCigarReadFilter",
                    "HasReadGroupReadFilter",
                    "LibraryReadFilter",
                    "MappedReadFilter",
                    "MappingQualityAvailableReadFilter",
                    "MappingQualityNotZeroReadFilter",
                    "MappingQualityReadFilter",
                    "MatchingBasesAndQualsReadFilter",
                    "MateDifferentStrandReadFilter",
                    "MateOnSameContigOrNoMappedMateReadFilter",
                    "MetricsReadFilter",
                    "NonChimericOriginalAlignmentReadFilter",
                    "NonZeroFragmentLengthReadFilter",
                    "NonZeroReferenceLengthAlignmentReadFilter",
                    "NotDuplicateReadFilter",
                    "NotOpticalDuplicateReadFilter",
                    "NotSecondaryAlignmentReadFilter",
                    "NotSupplementaryAlignmentReadFilter",
                    "OverclippedReadFilter",
                    "PairedReadFilter",
                    "PassesVendorQualityCheckReadFilter",
                    "PlatformReadFilter",
                    "PlatformUnitReadFilter",
                    "PrimaryLineReadFilter",
                    "ProperlyPairedReadFilter",
                    "ReadGroupBlackListReadFilter",
                    "ReadGroupReadFilter",
                    "ReadLengthEqualsCigarLengthReadFilter",
                    "ReadLengthReadFilter",
                    "ReadNameReadFilter",
                    "ReadStrandFilter",
                    "SampleReadFilter",
                    "SecondOfPairReadFilter",
                    "SeqIsStoredReadFilter",
                    "ValidAlignmentEndReadFilter",
                    "ValidAlignmentStartReadFilter",
                    "WellformedReadFilter"
                  ]
                }
              }
            ],
            "id": "read_filter",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--read-filter ' + self.join(' --read-filter ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Read filters to be applied before analysis.",
            "sbg:altPrefix": "-RF",
            "sbg:category": "Optional Arguments",
            "label": "Read filter"
          },
          {
            "type": "string[]?",
            "id": "read_index",
            "inputBinding": {
              "valueFrom": "${\n    if (self) {\n        return '--read-index ' + self.join(' --read-index ')\n    } else {\n        return null\n    }\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically.",
            "sbg:altPrefix": "-read-index",
            "sbg:category": "Optional Arguments",
            "label": "Read index"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "read_validation_stringency",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "SILENT",
            "id": "read_validation_stringency",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--read-validation-stringency",
              "position": 4
            },
            "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value silent can improve performance when processing a bam file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded.",
            "sbg:altPrefix": "-VS",
            "sbg:category": "Optional Arguments",
            "label": "Read validation stringency"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "recover_dangling_heads",
            "doc": "This argument is deprecated since version 3.3.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--recover-dangling-heads",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Recover dangling heads"
          },
          {
            "type": "File",
            "sbg:toolDefaultValue": "FASTA, FA",
            "secondaryFiles": [
              ".fai",
              "^.dict"
            ],
            "id": "in_reference",
            "sbg:fileTypes": "FASTA, FA",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--reference",
              "position": 4
            },
            "doc": "Reference sequence file.",
            "sbg:altPrefix": "-R",
            "sbg:category": "Required Arguments",
            "label": "Reference"
          },
          {
            "type": "string?",
            "id": "sample_name",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sample-name",
              "position": 4
            },
            "doc": "Name of single sample to use from a multi-sample bam.",
            "sbg:altPrefix": "-ALIAS",
            "sbg:category": "Optional Arguments",
            "label": "Sample name"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "sample_ploidy",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sample-ploidy",
              "position": 4
            },
            "doc": "Ploidy (number of chromosomes) per sample. For pooled data, set to (number of samples in each pool x Sample Ploidy).",
            "sbg:altPrefix": "-ploidy",
            "sbg:category": "Optional Arguments",
            "label": "Sample ploidy"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "10.0",
            "id": "seconds_between_progress_updates",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--seconds-between-progress-updates",
              "position": 4
            },
            "doc": "Output traversal statistics every time this many seconds elapse.",
            "sbg:altPrefix": "-seconds-between-progress-updates",
            "sbg:category": "Optional Arguments",
            "label": "Seconds between progress updates"
          },
          {
            "type": "string?",
            "id": "sequence_dictionary",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sequence-dictionary",
              "position": 4
            },
            "doc": "Use the given sequence dictionary as the master/canonical sequence dictionary. Must be a .dict file.",
            "sbg:altPrefix": "-sequence-dictionary",
            "sbg:category": "Optional Arguments",
            "label": "Sequence dictionary"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "sites_only_vcf_output",
            "doc": "If true, don't emit genotype fields when writing VCF file output.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sites-only-vcf-output",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Sites only VCF output"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "smith_waterman",
                "symbols": [
                  "FASTEST_AVAILABLE",
                  "AVX_ENABLED",
                  "JAVA"
                ]
              }
            ],
            "sbg:toolDefaultValue": "JAVA",
            "id": "smith_waterman",
            "doc": "Which Smith-Waterman implementation to use, generally FASTEST_AVAILABLE is the right choice.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--smith-waterman",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Smith waterman"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "30.0",
            "id": "standard_min_confidence_threshold_for_calling",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--standard-min-confidence-threshold-for-calling",
              "position": 4
            },
            "doc": "The minimum phred-scaled confidence threshold at which variants should be called.",
            "sbg:altPrefix": "-stand-call-conf",
            "sbg:category": "Optional Arguments",
            "label": "Standard min confidence threshold for calling"
          },
          {
            "type": "string?",
            "id": "tmp_dir",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--tmp-dir",
              "position": 4
            },
            "label": "Tmp dir",
            "sbg:category": "Optional Arguments",
            "doc": "Temporary directory to use."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "use_alleles_trigger",
            "doc": "Use additional trigger on variants found in an external alleles file.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--use-alleles-trigger",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Use alleles trigger"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "use_filtered_reads_for_annotations",
            "doc": "Use the contamination-filtered read maps for the purposes of annotating variants.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--use-filtered-reads-for-annotations",
              "position": 4
            },
            "sbg:category": "Advanced Arguments",
            "label": "Use filtered reads for annotations"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "use_jdk_deflater",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--use-jdk-deflater",
              "position": 4
            },
            "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater).",
            "sbg:altPrefix": "-jdk-deflater",
            "sbg:category": "Optional Arguments",
            "label": "Use JdkDeflater"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "use_jdk_inflater",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--use-jdk-inflater",
              "position": 4
            },
            "doc": "Whether to use the jdkinflater (as opposed to IntelInflater).",
            "sbg:altPrefix": "-jdk-inflater",
            "sbg:category": "Optional Arguments",
            "label": "Use JdkInflater"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "use_new_qual_calculator",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "use_new_qual_calculator",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--use-new-qual-calculator",
              "position": 4
            },
            "doc": "Use the new AF model instead of the so-called exact model.",
            "sbg:altPrefix": "-new-qual",
            "sbg:category": "Optional Arguments",
            "label": "Use new qual calculator"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "use_old_qual_calculator",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--use-old-qual-calculator",
              "position": 4
            },
            "doc": "Use the old AF model.",
            "sbg:altPrefix": "-old-qual",
            "sbg:category": "Optional Arguments",
            "label": "Use old qual calculator"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "verbosity",
                "symbols": [
                  "ERROR",
                  "WARNING",
                  "INFO",
                  "DEBUG"
                ]
              }
            ],
            "sbg:toolDefaultValue": "INFO",
            "id": "verbosity",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--verbosity",
              "position": 4
            },
            "doc": "Control verbosity of logging.",
            "sbg:altPrefix": "-verbosity",
            "sbg:category": "Optional Arguments",
            "label": "Verbosity"
          },
          {
            "type": "File?",
            "id": "exclude_intervals_file",
            "sbg:fileTypes": "INTERVAL_LIST",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--exclude-intervals",
              "position": 4
            },
            "doc": "One or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude genomic intervals"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform options",
            "doc": "Number of CPUs to be used per job."
          },
          {
            "type": "int?",
            "id": "ambig_filter_bases",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"AmbiguousBaseReadFilter\") != -1 &&\n        inputs.read_filter.indexOf(\"maxAmbiguousBaseFraction\") == -1){\n            return self\n        }\n    }\n}\n",
              "shellQuote": false,
              "prefix": "--ambig-filter-bases",
              "position": 5
            },
            "label": "Ambig filter bases",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"AmbiguousBaseReadFilter\" is specified:\nThreshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjuction with argument(s) maxAmbiguousBaseFraction."
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.05",
            "id": "ambig_filter_frac",
            "doc": "Valid only if \"AmbiguousBaseReadFilter\" is specified:\nThreshold fraction of ambiguous bases. Cannot be used in conjuction with argument(s) maxAmbiguousBases.",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"AmbiguousBaseReadFilter\") != -1 &&\n        inputs.read_filter.indexOf(\"maxAmbiguousBases\") == -1){\n            return self\n        }\n    }\n}\n",
              "shellQuote": false,
              "prefix": "--ambig-filter-frac",
              "position": 5
            },
            "sbg:category": "Conditional Arguments for read-filter option",
            "label": "Ambig filter frac"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1000000",
            "id": "max_fragment_length",
            "doc": "Valid only if \"FragmentLengthReadFilter\" is specified:\nMaximum length of fragment (insert size).",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"FragmentLengthReadFilter\") != -1){\n            return self\n        }\n    }\n}\n",
              "shellQuote": false,
              "prefix": "--max-fragment-length",
              "position": 5
            },
            "sbg:category": "Conditional Arguments for read-filter option",
            "label": "Max fragment length"
          },
          {
            "type": "string[]?",
            "id": "library",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter && inputs.read_filter.indexOf(\"LibraryReadFilter\") != -1){\n            return '--library ' + self.join(' --library ')\n        } else {\n            return null\n        }\n}\n\n",
              "shellQuote": false,
              "prefix": "",
              "position": 5
            },
            "label": "Library",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"LibraryReadFilter\" is specified:\nName of the library to keep. This argument must be specified at least once."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "dont_require_soft_clips_both_ends",
            "doc": "Valid only if \"OverclippedReadFilter\" is specified:\nAllow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block.",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"OverclippedReadFilter\") != -1){\n            return self\n        }\n    }\n}",
              "shellQuote": false,
              "prefix": "--dont-require-soft-clips-both-ends",
              "position": 5
            },
            "sbg:category": "Conditional Arguments for read-filter option",
            "label": "Do not require soft clips"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "30",
            "id": "filter_too_short",
            "doc": "Valid only if \"OverclippedReadFilter\" is specified:\nMinimum number of aligned bases.",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"OverclippedReadFilter\") != -1){\n            return self\n        }\n    }\n}",
              "shellQuote": false,
              "prefix": "--filter-too-short",
              "position": 5
            },
            "sbg:category": "Conditional Arguments for read-filter option",
            "label": "Filter too short"
          },
          {
            "type": "string[]?",
            "id": "platform_filter_name",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter && inputs.read_filter.indexOf(\"PlatformReadFilter\") != -1){\n        return \"--platform-filter-name \" + self.join(' --platform-filter-name ')\n    } else {\n        return null\n    }\n}\n\n",
              "shellQuote": false,
              "prefix": "",
              "position": 5
            },
            "label": "Platform filter name",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"PlatformReadFilter\" is specified:\nPlatform attribute (PL) to match.  This argument must be specified at least once."
          },
          {
            "type": "string[]?",
            "id": "black_listed_lanes",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter && inputs.read_filter.indexOf(\"PlatformUnitReadFilter\") != -1){\n            return \"--black-listed-lanes \" + self.join(' --black-listed-lanes ')\n    } else {\n        return null\n    }\n}\n\n",
              "shellQuote": false,
              "prefix": "",
              "position": 5
            },
            "label": "Black listed lanes",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"PlatformUnitReadFilter\" is specified:\nPlatform unit (PU) to filter out. This argument must be specified at least once."
          },
          {
            "type": "string[]?",
            "id": "read_group_black_list",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter && inputs.read_filter.indexOf(\"ReadGroupBlackListReadFilter\") != -1){\n            return \"--read-group-black-list \" + self.join(' --read-group-black-list ')\n    } else {\n        return null\n    }\n}\n\n",
              "shellQuote": false,
              "prefix": "",
              "position": 5
            },
            "label": "Read group black list",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"ReadGroupBlackListReadFilter\" is specified:\nThe name of the read group to filter out. This argument must be specified at least once."
          },
          {
            "type": "string?",
            "id": "keep_read_group",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"ReadGroupReadFilter\") != -1){\n            return self\n        }\n    }\n}",
              "shellQuote": false,
              "prefix": "--keep-read-group",
              "position": 5
            },
            "label": "Keep read group",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"ReadGroupReadFilter\" is specified:\nThe name of the read group to keep."
          },
          {
            "type": "int?",
            "id": "max_read_length",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"ReadLengthReadFilter\") != -1){\n            return self\n        }\n    }\n}",
              "shellQuote": false,
              "prefix": "--max-read-length",
              "position": 5
            },
            "label": "Max read length",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"ReadLengthReadFilter\" is specified:\nKeep only reads with length at most equal to the specified value."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "min_read_length",
            "doc": "Valid only if \"ReadLengthReadFilter\" is specified:\nKeep only reads with length at least equal to the specified value.",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"ReadLengthReadFilter\") != -1){\n            return self\n        }\n    }\n}",
              "shellQuote": false,
              "prefix": "--min-read-length",
              "position": 5
            },
            "sbg:category": "Conditional Arguments for read-filter option",
            "label": "Min read length"
          },
          {
            "type": "string?",
            "id": "read_name",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"ReadNameReadFilter\") != -1){\n            return self\n        }\n    }\n}",
              "shellQuote": false,
              "prefix": "--read-name",
              "position": 5
            },
            "label": "Read name",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"ReadNameReadFilter\" is specified:\nKeep only reads with this read name."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "keep_reverse_strand_only",
            "doc": "Valid only if \"ReadStrandFilter\" is specified:\nKeep only reads on the reverse strand.",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter){\n        if(inputs.read_filter.indexOf(\"ReadStrandFilter\") != -1){\n            return self\n        }\n    }\n}",
              "shellQuote": false,
              "prefix": "--keep-reverse-strand-only",
              "position": 5
            },
            "sbg:category": "Conditional Arguments for read-filter option",
            "label": "Keep reverse strand only"
          },
          {
            "type": "string[]?",
            "id": "sample",
            "inputBinding": {
              "valueFrom": "${\n    if(self && inputs.read_filter && inputs.read_filter.indexOf(\"SampleReadFilter\") != -1){\n            return \"--sample \" + self.join(' --sample ')\n    } else {\n        return null\n    }\n}\n\n",
              "shellQuote": false,
              "prefix": "",
              "position": 5
            },
            "label": "Sample",
            "sbg:category": "Conditional Arguments for read-filter option",
            "doc": "Valid only if \"SampleReadFilter\" is specified:\nThe name of the sample(s) to keep, filtering out all others  This argument must be specified at least once."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_extension",
                "symbols": [
                  "vcf",
                  "vcf.gz"
                ]
              }
            ],
            "sbg:toolDefaultValue": "vcf",
            "id": "output_extension",
            "doc": "Output VCF extension.",
            "sbg:category": "Required Arguments",
            "label": "Output VCF extension",
            "default": "vcf"
          }
        ],
        "cwlVersion": "v1.0",
        "baseCommand": [
          "/opt/gatk"
        ],
        "arguments": [
          {
            "valueFrom": "--java-options",
            "shellQuote": false,
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.mem_per_job) {\n        return '\\\"-Xmx'.concat(inputs.mem_per_job, 'M') + '\\\"'\n    } else {\n        // this is required for Best Practice GATK RNA-seq workflow\n        return '\\\"-Xms6000m\\\"'\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "HaplotypeCaller",
            "shellQuote": false,
            "position": 3
          },
          {
            "valueFrom": "${\n    // if output parameter is set, return output file name\n    if(inputs.output_prefix && inputs.output_extension){\n        return inputs.output_prefix + '.' + inputs.output_extension;\n    } else {\n        // determine output file extenstion\n        var out_ext;\n        if(inputs.emit_ref_confidence == 'GVCF' && inputs.output_extension){\n            out_ext = '.g.' + inputs.output_extension\n        } else {\n            out_ext = '.' + inputs.output_extension\n        }\n        var in_prefix;\n        var in_num = [].concat(inputs.in_alignments).length;\n        // create output file name if there is one input file\n        if(in_num == 1){\n            var in_align = [].concat(inputs.in_alignments)[0];\n            // check if the sample_id metadata value is defined for the input file\n            if(in_align.metadata && in_align.metadata.sample_id){\n                in_prefix = in_align.metadata.sample_id\n            // if sample_id is not defined\n            } else {\n                in_prefix = [].concat(inputs.in_alignments)[0].nameroot\n            }\n            return in_prefix + out_ext\n        }\n        // create output file name if there are more than one input files\n        else if(in_num > 1){\n            var in_align = [].concat(inputs.in_alignments);\n            var in_sample_ids = [];\n            var in_align_names = [];\n            for (var i = 0; i < in_align.length; i++) {\n                // check if the sample_id metadata value is defined for the input file\n                if(in_align[i].metadata && in_align[i].metadata.sample_id){\n                    in_sample_ids.push(in_align[i].metadata.sample_id)\n                }\n                in_align_names.push(in_align[i].nameroot)\n            }\n            if(in_sample_ids.length != 0){\n                in_prefix = in_sample_ids.sort()[0]\n            // if sample_id is not defined\n            } else {\n                in_prefix = in_align_names.sort()[0]\n            }\n            return in_prefix + '.' + in_num + out_ext\n        } else {\n            return null\n        }\n    }\n}",
            "shellQuote": false,
            "prefix": "--output",
            "position": 4
          }
        ],
        "sbg:modifiedOn": 1559750439,
        "sbg:publisher": "sbg",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "4.1.0.0",
        "sbg:revision": 7,
        "sbg:categories": [
          "Genomics",
          "Variant Calling"
        ]
      },
      "in": [
        {
          "source": "known_snps",
          "id": "dbsnp"
        },
        {
          "id": "dont_use_soft_clipped_bases",
          "default": true
        },
        {
          "source": [
            "gatk_applybqsr_4_1_0_0/out_alignments"
          ],
          "id": "in_alignments",
          "valueFrom": "$([self])"
        },
        {
          "source": "gatk_intervallisttools_4_1_0_0/output_interval_list",
          "id": "include_intervals"
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        },
        {
          "source": "in_reference",
          "id": "in_reference"
        },
        {
          "source": "standard_min_confidence_threshold_for_calling",
          "id": "standard_min_confidence_threshold_for_calling"
        }
      ],
      "sbg:y": -151.56219482421875,
      "scatter": [
        "include_intervals"
      ],
      "label": "GATK HaplotypeCaller",
      "sbg:x": 1927.5069580078125,
      "out": [
        {
          "id": "out_variants"
        },
        {
          "id": "out_alignments"
        },
        {
          "id": "out_graph"
        }
      ]
    },
    {
      "id": "gatk_intervallisttools_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 4,
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-intervallisttools-4-1-0-0/19",
        "sbg:toolAuthor": "Broad Institute",
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 2048;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [
              {
                "entry": "import glob, os\n# Works around a JES limitation where multiples files with the same name overwrite each other when globbed\nintervals = sorted(glob.glob(\"out/*/*.interval_list\"))\nfor i, interval in enumerate(intervals):\n    (directory, filename) = os.path.split(interval)\n    newName = os.path.join(directory, str(i + 1) + filename)\n    os.rename(interval, newName)\nprint(len(intervals))",
                "writable": false,
                "entryname": "rename_intervals.py"
              }
            ],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "This tool offers multiple interval list file manipulation capabilities including sorting, merging, subtracting, padding, and other set-theoretic operations. \n\nThe default action is to merge and sort genomic intervals provided as the input. Compatible input files are INTERVAL_LIST and VCF files. **IntervalListTools** can also \"scatter\" the output into many interval files. This can be useful for creating multiple interval lists for scattering an analysis execution.\n\n###Common Use Cases\n\n- Combine the intervals from two interval lists:\n```\njava -jar picard.jar IntervalListTools \\\n      ACTION=CONCAT \\\n      I=input.interval_list \\\n      I=input_2.interval_list \\\n      O=new.interval_list\n```\n- Combine the intervals from two interval lists, sorting and merging overlapping and abutting intervals:\n```\n java -jar picard.jar IntervalListTools \\\n       ACTION=CONCAT \\\n       SORT=true \\\n       UNIQUE=true \\\n       I=input.interval_list \\\n       I=input_2.interval_list \\\n       O=new.interval_list \n```\n- Subtract the intervals in **second_input** (`SECOND_INPUT`) from those in **in_intervals** (`INPUT`):\n```\n java -jar picard.jar IntervalListTools \\\n       ACTION=SUBTRACT \\\n       I=input.interval_list \\\n       SI=input_2.interval_list \\\n       O=new.interval_list \n```\n- Find bases that are in either *input1.interval_list* or *input2.interval_list*, and also in *input3.interval_list*:\n```\n java -jar picard.jar IntervalListTools \\\n       ACTION=INTERSECT \\\n       I=input1.interval_list \\\n       I=input2.interval_list \\\n       SI=input3.interval_list \\\n       O=new.interval_list \n```\n- Split intervals list file using * scatter_count* (`SCATTER_COUNT`) option:\n```\n java -jar picard.jar IntervalListTools \\\n       I=input.interval_list \\\n       SCATTER_COUNT=2 \n```\n\n\n###Common Issues and Important Notes\n\n- A SAM style header must be present at the top of the *interval_list* file. After the header, the file then contains records, one per line in text format with the following tab-separated values. Example of the *interval_list* file: \n```\n@HD    VN:1.0\n@SQ    SN:chr1    LN:501\n@SQ    SN:chr2    LN:401\nchr1    1    100    +    starts at the first base of the contig and covers 100 bases\nchr2    100    100    +    interval with exactly one base\n```\n- The coordinate system is 1-based, closed-ended so that the first base in a sequence has position 1, and both the start and the end positions are included in an interval.\n-  The **Interval list** input file should be denoted with the extension INTERVAL_LIST.\n\n\n###Changes Introduced by Seven Bridges\n\nIf no additional parameter is set, the app will output the INTERVAL_LIST file given on the input.\n\n\n###Performance Benchmarking\nThe execution time takes several minutes on the default instance. Unless specified otherwise, the default AWS instance used to run the **IntervalListTools** will be c4.2xlarge (8CPUs and 16GB RAM).",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:createdOn": 1553015434,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-intervallisttools-4-1-0-0/4",
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:image_url": null,
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-intervallisttools-4-1-0-0/19",
        "sbg:modifiedBy": "veliborka_josipovic",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1553015434,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-intervallisttools-4-1-0-0/14",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1553023178,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-intervallisttools-4-1-0-0/16",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554720910,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-intervallisttools-4-1-0-0/17",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999245,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-intervallisttools-4-1-0-0/18",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559740786,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-intervallisttools-4-1-0-0/19",
            "sbg:modifiedBy": "veliborka_josipovic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:toolkit": "GATK",
        "label": "GATK IntervalListTools",
        "sbg:content_hash": "ad8098a8ef53e9c95647c2c4b16fb6e2616f49f3b2589d1241f7c1a034153332b",
        "outputs": [
          {
            "type": "File[]?",
            "label": "Output interval list",
            "sbg:fileTypes": "INTERVAL_LIST",
            "id": "output_interval_list",
            "outputBinding": {
              "glob": "${\n    var scatter_count = inputs.scatter_count ? inputs.scatter_count : 1;\n    if (scatter_count > 1)\n    {\n        return \"out/*/*.interval_list\";\n    }\n    else\n    {\n        return \"test.interval_list\";\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_intervals))"
            },
            "doc": "Output list of intervals, processed per the tool's specifications (union, intersection, split list... )."
          }
        ],
        "sbg:id": "h-6dc7b311/h-53220b36/h-b97d575b/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "action",
                "symbols": [
                  "CONCAT",
                  "UNION",
                  "INTERSECT",
                  "SUBTRACT",
                  "SYMDIFF",
                  "OVERLAPS"
                ]
              }
            ],
            "sbg:toolDefaultValue": "CONCAT",
            "id": "action",
            "doc": "Action to take on inputs. Possible values: { CONCAT (the concatenation of all the intervals in all the inputs, no sorting or merging of overlapping/abutting intervals implied. Will result in a possibly unsorted list unless requested otherwise.) UNION (like concatenate but with UNIQUE and SORT implied, the result being the set-wise union of all inputs, with overlapping and abutting intervals merged into one.) INTERSECT (the sorted and merged set of all loci that are contained in all of the inputs.) SUBTRACT (subtracts the intervals in second_input from those in input. The resulting loci are those in input that are not in second_input.) symdiff (results in loci that are in input or second_input but are not in both.) overlaps (outputs the entire intervals from input that have bases which overlap any interval from second_input. Note that this is different than intersect in that each original interval is either emitted in its entirety, or not at all.) }.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--ACTION",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Action"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "break_bands_at_multiples_of",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--BREAK_BANDS_AT_MULTIPLES_OF",
              "position": 4
            },
            "doc": "If set to a positive value will create a new interval list with the original intervals broken up at integer multiples of this value. Set to 0 to not break up intervals.",
            "sbg:altPrefix": "-BRK",
            "sbg:category": "Optional Arguments",
            "label": "Break bands at multiples of"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "comment",
            "doc": "One or more lines of comment to add to the header of the output file (as @CO lines in the SAM header).  This argument may be specified 0 or more times.",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--COMMENT', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Comment"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "compression_level",
            "doc": "Compression level for all compressed files created (e.g. BAM and VCF).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--COMPRESSION_LEVEL",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Compression level"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform options",
            "doc": "Number of CPUs to be used per job."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "include_filtered",
            "doc": "Whether to include filtered variants in the VCF when generating an interval list from VCF.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--INCLUDE_FILTERED",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Include filtered"
          },
          {
            "type": "File[]",
            "id": "in_intervals",
            "sbg:fileTypes": "VCF, INTERVAL_LIST",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--INPUT', self[i].path);\n        }\n        return cmd.join(' ');\n    }\n    \n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more interval lists. If multiple interval lists are provided the output is the result of merging the inputs. Supported formats are interval_list and VCF. This argument must be specified at least once.",
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "label": "Interval list"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "invert",
            "doc": "Produce the inverse list of intervals, that is, the regions in the genome that are not covered by any of the input intervals. Will merge abutting intervals first. Output will be sorted.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--INVERT",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Invert"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "500000",
            "id": "max_records_in_ram",
            "doc": "When writing files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort the file, and increases the amount of RAM needed.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MAX_RECORDS_IN_RAM",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Max records in ram"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "7",
            "id": "memory_overhead_per_job",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped)."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2048",
            "id": "memory_per_job",
            "label": "Memory per job",
            "sbg:category": "Platform options",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped)."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_value",
                "symbols": [
                  "NONE",
                  "BASES",
                  "INTERVALS"
                ]
              }
            ],
            "sbg:toolDefaultValue": "NONE",
            "id": "output_value",
            "doc": "What value (if anything) to output to stdout (for scripting).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--OUTPUT_VALUE",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Output value"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "padding",
            "doc": "The amount to pad each end of the intervals by before other operations are undertaken. Negative numbers are allowed and indicate intervals should be shrunk. Resulting intervals < 0 bases long will be removed. Padding is applied to the interval lists (both INPUT and SECOND_INPUT, if provided) before the ACTION is performed.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--PADDING",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Padding"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "in_reference",
            "sbg:fileTypes": "FASTA, FA",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--REFERENCE_SEQUENCE",
              "position": 4
            },
            "doc": "Reference sequence file.",
            "sbg:altPrefix": "-R",
            "sbg:category": "Optional Arguments",
            "label": "Reference sequence"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "null",
            "id": "scatter_content",
            "doc": "When scattering with this argument, each of the resultant files will (ideally) have this amount of 'content', which means either base-counts or interval-counts depending on SUBDIVISION_MODE. When provided, overrides SCATTER_COUNT.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SCATTER_CONTENT",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Scatter content"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "description": "The number of files into which to scatter the resulting list by locus; in some situations, fewer intervals may be emitted.",
            "id": "scatter_count",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SCATTER_COUNT",
              "position": 4
            },
            "doc": "The number of files into which to scatter the resulting list by locus; in some situations, fewer intervals may be emitted.",
            "sbg:category": "Optional Arguments",
            "label": "Scatter count"
          },
          {
            "type": "File[]?",
            "sbg:toolDefaultValue": "null",
            "id": "second_input",
            "sbg:fileTypes": "VCF, INTERVAL_LIST",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SECOND_INPUT",
              "position": 4
            },
            "doc": "Second set of intervals for SUBTRACT and DIFFERENCE operations. This argument may be specified 0 or more times.",
            "sbg:altPrefix": "-SI",
            "sbg:category": "Optional Arguments",
            "label": "Second input"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "true",
            "id": "sort",
            "doc": "If true, sort the resulting interval list by coordinate.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SORT",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Sort"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "subdivision_mode",
                "symbols": [
                  "INTERVAL_SUBDIVISION",
                  "BALANCING_WITHOUT_INTERVAL_SUBDIVISION",
                  "BALANCING_WITHOUT_INTERVAL_SUBDIVISION_WITH_OVERFLOW",
                  "INTERVAL_COUNT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "INTERVAL_SUBDIVISION",
            "id": "subdivision_mode",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SUBDIVISION_MODE",
              "position": 4
            },
            "doc": "The mode used to scatter the interval list. Possible values: { INTERVAL_SUBDIVISION (scatter the interval list into similarly sized interval lists (by base count), breaking up intervals as needed.) BALANCING_WITHOUT_INTERVAL_SUBDIVISION (scatter the interval list into similarly sized interval lists (by base count), but without breaking up intervals.) BALANCING_WITHOUT_INTERVAL_SUBDIVISION_WITH_OVERFLOW (scatter the interval list into similarly sized interval lists (by base count), but without breaking up intervals. Will overflow current interval list so that the remaining lists will not have too many bases to deal with.) interval_count (scatter the interval list into similarly sized interval lists (by interval count, not by base count). Resulting interval lists will contain similar number of intervals.) }.",
            "sbg:altPrefix": "-M",
            "sbg:category": "Optional Arguments",
            "label": "Subdivision mode"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "unique",
            "doc": "If true, merge overlapping and adjacent intervals to create a list of unique intervals. Implies SORT=true.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--UNIQUE",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Unique"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "validation_stringency",
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ]
              }
            ],
            "sbg:toolDefaultValue": "STRICT",
            "id": "validation_stringency",
            "doc": "Validation stringency for all SAM files read by this program. Setting stringency to silent can improve performance when processing a bam file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--VALIDATION_STRINGENCY",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Validation stringency"
          }
        ],
        "sbg:contributors": [
          "uros_sipetic",
          "veliborka_josipovic"
        ],
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "--java-options",
            "shellQuote": false,
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    return '\\\"-Xms1g\\\"';\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "IntervalListTools",
            "shellQuote": false,
            "position": 3
          },
          {
            "valueFrom": "${\n    var scatter_count = inputs.scatter_count ? inputs.scatter_count : 1;\n    if (scatter_count > 1)\n    {\n        return \"--OUTPUT out\";\n    }\n    else\n    {\n        return \"--OUTPUT test.interval_list\";\n    }\n    \n}",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          },
          {
            "valueFrom": "${\n    return \"mkdir out && \";\n}",
            "shellQuote": false,
            "prefix": "",
            "position": -1
          },
          {
            "valueFrom": "rename_intervals.py",
            "shellQuote": false,
            "prefix": "&& python",
            "position": 99
          }
        ],
        "sbg:modifiedOn": 1559740786,
        "sbg:publisher": "sbg",
        "sbg:toolkitVersion": "4.1.0.0",
        "cwlVersion": "v1.0",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_util_IntervalListTools.php"
          }
        ],
        "sbg:revision": 4,
        "sbg:wrapperAuthor": "nemanja.vucic, veliborka_josipovic",
        "sbg:categories": [
          "Utilities",
          "BED Processing"
        ]
      },
      "in": [
        {
          "source": [
            "in_intervals"
          ],
          "id": "in_intervals"
        },
        {
          "source": "scatter_count",
          "id": "scatter_count",
          "default": 6
        },
        {
          "id": "sort",
          "default": true
        },
        {
          "id": "subdivision_mode",
          "default": "BALANCING_WITHOUT_INTERVAL_SUBDIVISION_WITH_OVERFLOW"
        },
        {
          "id": "unique",
          "default": true
        }
      ],
      "sbg:y": -435.5,
      "label": "GATK IntervalListTools",
      "sbg:x": 1680,
      "out": [
        {
          "id": "output_interval_list"
        }
      ]
    },
    {
      "id": "gatk_mergevcfs_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 6,
        "sbg:modifiedBy": "nemanja.vucic",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk/"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
          },
          {
            "label": "Publications",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_vcf_MergeVcfs.php"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 3500;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "The **GATK MergeVcfs** tool combines multiple variant files into a single variant file. \n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases\n\n* The **MergeVcfs** tool requires one or more input files in VCF format on its **Input variant files** (`--INPUT`) input. The input files can be in VCF format (can be gzipped, i.e. ending in \".vcf.gz\", or binary compressed, i.e. ending in \".bcf\"). The tool generates a VCF file on its **Output merged VCF or BCF file** output.\n\n* The **MergeVcfs** tool supports a sequence dictionary file (typically name ending in .dict) on its **Sequence dictionary** (`--SEQUENCE_DICTIONARY`) input if the input VCF does not contain a complete contig list and if the output index is to be created (true by default).\n\n* The output file is sorted (i) according to the dictionary and (ii) by coordinate.\n\n* Usage example:\n\n```\ngatk MergeVcfs \\\n          --INPUT input_variants.01.vcf \\\n          --INPUT input_variants.02.vcf.gz \\\n          --OUTPUT output_variants.vcf.gz\n```\n\n###Changes Introduced by Seven Bridges\n\n* The output file will be prefixed using the **Output prefix** parameter. In case **Output prefix** is not provided, the input files provided on the **Input variant files** input will be alphabetically sorted by name and  output prefix will be equal to the Sample ID metadata from the first element from that list, if the Sample ID metadata exists. Otherwise, output prefix will be inferred from the filename of the first element from this list. Moreover, the number of input files will be added after the output prefix as well as the tool specific extension which is **merged**. This way, having identical names of the output files between runs is avoided.\n\n* The user has a possibility to specify the output file format using the **Output file format** argument. The default output format is \"vcf.gz\".\n\n###Common Issues and Important Notes\n\n* Note 1: If running this tool on multi-sample input files (originating from e.g. some scatter-gather runs), the input files must contain the same sample names in the same column order. \n\n* Note 2: Input file headers must contain compatible declarations for common annotations (INFO, FORMAT fields) and filters.\n\n* Note 3: Input files variant records must be sorted by their contig and position following the sequence dictionary provided or the header contig list.\n\n###Performance Benchmarking\n\nThis tool is ultra fast, with a running time less than a minute on the default AWS c4.2xlarge instance.\n\n###References\n\n[1] [GATK MergeVcfs](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/picard_vcf_MergeVcfs.php)",
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergevcfs-4-1-0-0/20",
        "sbg:createdOn": 1552929960,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-mergevcfs-4-1-0-0/6",
        "sbg:image_url": null,
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:toolkit": "GATK",
        "sbg:content_hash": "a87aa57d3b522bb67ebf53b10fa06b540cbc280f16bf46b7fd668e5a31af1934a",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1552929960,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergevcfs-4-1-0-0/7",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554493122,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergevcfs-4-1-0-0/14",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554720843,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergevcfs-4-1-0-0/15",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999276,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergevcfs-4-1-0-0/16",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559740771,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergevcfs-4-1-0-0/18",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559746042,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergevcfs-4-1-0-0/19",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559750444,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergevcfs-4-1-0-0/20",
            "sbg:modifiedBy": "nemanja.vucic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-mergevcfs-4-1-0-0/20",
        "label": "GATK MergeVcfs",
        "sbg:contributors": [
          "uros_sipetic",
          "nemanja.vucic",
          "veliborka_josipovic"
        ],
        "outputs": [
          {
            "type": "File?",
            "secondaryFiles": [
              "${\n    return self.basename + \".tbi\";\n}\n"
            ],
            "label": "Output merged VCF or BCF file",
            "sbg:fileTypes": "VCF, VCF.GZ, BCF",
            "id": "out_variants",
            "outputBinding": {
              "glob": "${\n    if (inputs.output_file_format)\n        return \"*\" + inputs.output_file_format;\n    else\n        return \"*vcf.gz\";\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_variants))"
            },
            "doc": "The merged VCF or BCF file. File format is determined by file extension."
          }
        ],
        "sbg:id": "h-adafefbc/h-9274ad9a/h-12208b1b/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": "File[]",
            "secondaryFiles": [
              "${\n    if (self.nameext == \".vcf\")\n    {\n        return self.basename + \".idx\";\n    }\n    else\n    {\n        return self.basename + \".tbi\";\n    }\n}"
            ],
            "id": "in_variants",
            "sbg:fileTypes": "VCF, VCF.GZ, BCF",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--INPUT', self[i].path);\n            \n        }\n        return cmd.join(' ');\n    }\n}",
              "shellQuote": false,
              "position": 4
            },
            "doc": "VCF or BCF input files (file format is determined by file extension).",
            "sbg:altPrefix": "-I",
            "sbg:category": "Required Arguments",
            "label": "Input variants file"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "compression_level",
            "doc": "Compression level for all compressed files created (e.g. BAM and VCF).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--COMPRESSION_LEVEL",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Compression level"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "500000",
            "id": "max_records_in_ram",
            "doc": "When writing files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort the file, and increases the amount of RAM needed.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--MAX_RECORDS_IN_RAM",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Max records in RAM"
          },
          {
            "type": "int?",
            "id": "memory_overhead_per_job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2048 MB",
            "id": "memory_per_job",
            "label": "Memory per job",
            "sbg:category": "Platform Options",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped)."
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "sequence_dictionary",
            "sbg:fileTypes": "DICT",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--SEQUENCE_DICTIONARY",
              "position": 4
            },
            "doc": "The index sequence dictionary to use instead of the sequence dictionary in the input files.",
            "sbg:altPrefix": "-D",
            "sbg:category": "Optional Arguments",
            "label": "Sequence dictionary"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform options",
            "doc": "This input allows a user to set the desired CPU requirement when running a tool or adding it to a workflow."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_file_format",
                "symbols": [
                  "vcf",
                  "bcf",
                  "vcf.gz"
                ]
              }
            ],
            "sbg:toolDefaultValue": "VCF.GZ",
            "id": "output_file_format",
            "label": "Output file format",
            "sbg:category": "Optional Arguments",
            "doc": "Output file format."
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output file name prefix.",
            "label": "Output prefix",
            "sbg:category": "Optional Arguments"
          }
        ],
        "cwlVersion": "v1.0",
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "--java-options",
            "shellQuote": false,
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    return '\\\"-Xms2000m\\\"';\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "MergeVcfs",
            "shellQuote": false,
            "position": 3
          },
          {
            "valueFrom": "${\n    var in_variants = [].concat(inputs.in_variants);\n    var output_prefix = \"\";\n    var output_ext = inputs.output_file_format ? inputs.output_file_format : \"vcf.gz\";\n    if (inputs.output_prefix)\n    {\n        output_prefix = inputs.output_prefix;\n    }\n    else\n    {\n        if (in_variants.length > 1)\n        {\n            in_variants.sort(function(file1, file2) {\n                var file1_name = file1.path.split('/').pop().toUpperCase();\n                var file2_name = file2.path.split('/').pop().toUpperCase();\n                if (file1_name < file2_name) {\n                    return -1;\n                }\n                if (file1_name > file2_name) {\n                    return 1;\n                }\n                // names must be equal\n                return 0;\n            });\n        }\n        \n        var in_variants_first =  in_variants[0];\n        if (in_variants_first.metadata && in_variants_first.metadata.sample_id)\n        {\n            output_prefix = in_variants_first.metadata.sample_id;\n\n        }\n        else\n        {\n            output_prefix = in_variants_first.path.split('/').pop().split('.')[0];\n        }\n        \n        if (in_variants.length > 1)\n        {\n            output_prefix = output_prefix + \".\" + in_variants.length;\n        }\n    }\n    \n    return \"--OUTPUT \" + output_prefix + \".merged.\" + output_ext;\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          }
        ],
        "sbg:modifiedOn": 1559750444,
        "sbg:publisher": "sbg",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "4.0.12.0",
        "sbg:revision": 6,
        "sbg:categories": [
          "Utilities",
          "VCF Processing"
        ]
      },
      "in": [
        {
          "linkMerge": "merge_flattened",
          "id": "in_variants",
          "source": [
            "gatk_haplotypecaller_4_1_0_0/out_variants"
          ]
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        }
      ],
      "sbg:y": -248.1025390625,
      "label": "GATK MergeVcfs",
      "sbg:x": 2178.44580078125,
      "out": [
        {
          "id": "out_variants"
        }
      ]
    },
    {
      "id": "gatk_variantfiltration_4_1_0_0",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "uros_sipetic",
        "sbg:latestRevision": 7,
        "sbg:modifiedBy": "nemanja.vucic",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://software.broadinstitute.org/gatk/"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/broadinstitute/gatk/"
          },
          {
            "label": "Download",
            "id": "https://github.com/broadinstitute/gatk/releases/download/4.1.0.0/gatk-4.1.0.0.zip"
          },
          {
            "label": "Publications",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed?term=20644199"
          },
          {
            "label": "Documentation",
            "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/org_broadinstitute_hellbender_tools_walkers_filters_VariantFiltration.php"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n    var memory = 3500;\n    if (inputs.memory_per_job) \n    {\n        memory = inputs.memory_per_job;\n    }\n    if (inputs.memory_overhead_per_job)\n    {\n        memory += inputs.memory_overhead_per_job;\n    }\n    return memory;\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 1;\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/stefan_stojanovic/gatk:4.1.0.0",
            "class": "DockerRequirement"
          },
          {
            "listing": [],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};",
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "doc": "The **GATK VariantFiltration** tool filters variant calls of the input VCF file based on INFO and/or FORMAT annotations and outputs a filter VCF file. \n\nThis tool is designed for hard-filtering variant calls based on certain criteria. Records are hard-filtered by changing the value in the FILTER field to something other than PASS. Filtered records will be preserved in the output unless their removal is requested in the command line [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n###Common Use Cases\n\n* The **GATK VariantFiltration** tool requires the VCF file on its **Input variants file** (`--variant`) input and a reference file on its **Reference** (`--reference`) input. The tool generates a filtered VCF file on its **Output filtered variants file** output.\n\n* Usage example:\n```\n   gatk VariantFiltration \\\n   --reference reference.fasta \\\n   --variant input.vcf.gz \\\n   --output output.vcf.gz \\\n   --filter-name \"my_filter1\" \\\n   --filter-expression \"AB < 0.2\" \\\n   --filter-name \"my_filter2\" \\\n   --filter-expression \"MQ0 > 50\"\n\n```\n\n###Changes Introduced by Seven Bridges\n\n* All output files will be prefixed using the **Output prefix** parameter. In case **Output prefix** is not provided, output prefix will be the same as the Sample ID metadata from **Input variants file**, if the Sample ID metadata exists. Otherwise, output prefix will be inferred from the **Input variants** filename. This way, having identical names of the output files between runs is avoided. Moreover,  **filtered** will be added before the extension of the output file name. \n\n* The user has a possibility to specify the output file format using the **Output file format** argument. Otherwise, the output will be in the compressed VCF file format.\n\n###Common Issues and Important Notes\n\n* Note: Composing filtering expressions can range from very simple to extremely complicated depending on what you're trying to do.\n\nCompound expressions (ones that specify multiple conditions connected by &&, AND, ||, or OR, and reference multiple attributes) require special consideration. By default, variants that are missing one or more of the attributes referenced in a compound expression are treated as PASS for the entire expression, even if the variant would satisfy the filter criteria for another part of the expression. This can lead to unexpected results if any of the attributes referenced in a compound expression are present for some variants, but missing for others.\n\nIt is strongly recommended to provide such expressions as individual arguments, each referencing a single attribute and specifying a single criteria. This ensures that all of the individual expression are applied to each variant, even if a given variant is missing values for some of the expression conditions.\n\nAs an example, multiple individual expressions provided like this:\n\n```\n   gatk VariantFiltration \\\n   --reference reference.fasta \\\n   --variant input.vcf.gz \\\n   --output output.vcf.gz \\\n   --filter-name \"my_filter1\" \\\n   --filter-expression \"AB < 0.2\" \\\n   --filter-name \"my_filter2\" \\\n   --filter-expression \"MQ0 > 50\"\n \n```\n\nare preferable to a single compound expression such as this:\n\n```\n    gatk VariantFiltration \\\n    --reference reference.fasta \\\n    --variant input.vcf.gz \\\n    --output output.vcf.gz \\\n    --filter-name \"my_filter\" \\\n    --filter-expression \"AB < 0.2 || MQ0 > 50\"\n  \n```\n\n###Performance Benchmarking\n\nThis tool is ultra fast, with a running time less than a minute on the default AWS c4.2xlarge instance.\n\n\n###References\n\n[1] [GATK VariantFiltration](https://software.broadinstitute.org/gatk/documentation/tooldocs/4.1.0.0/org_broadinstitute_hellbender_tools_walkers_filters_VariantFiltration.php)",
        "sbg:project": "uros_sipetic/gatk-4-1-0-0-demo",
        "sbg:sbgMaintained": false,
        "sbg:copyOf": "veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/25",
        "sbg:createdOn": 1552930494,
        "id": "uros_sipetic/gatk-4-1-0-0-demo/gatk-variantfiltration-4-1-0-0/7",
        "sbg:image_url": null,
        "sbg:projectName": "GATK 4.1.0.0 - Demo",
        "sbg:license": "Open source BSD (3-clause) license",
        "sbg:toolkit": "GATK",
        "sbg:content_hash": "af9e0b8951e53e09339a0fba5101279797fcd3c73268fbaeb60a4c376556222eb",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1552930494,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/10",
            "sbg:modifiedBy": "uros_sipetic"
          },
          {
            "sbg:modifiedOn": 1554493100,
            "sbg:revision": 1,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/18",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554720852,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/19",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1554999320,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/20",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1557837718,
            "sbg:revision": 4,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/21",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1558964200,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/22",
            "sbg:modifiedBy": "stefan_stojanovic"
          },
          {
            "sbg:modifiedOn": 1559734534,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/24",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1559750433,
            "sbg:revision": 7,
            "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/25",
            "sbg:modifiedBy": "nemanja.vucic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:revisionNotes": "Copy of veliborka_josipovic/gatk-4-1-0-0-toolkit-dev/gatk-variantfiltration-4-1-0-0/25",
        "label": "GATK VariantFiltration",
        "sbg:contributors": [
          "uros_sipetic",
          "stefan_stojanovic",
          "nemanja.vucic",
          "veliborka_josipovic"
        ],
        "outputs": [
          {
            "type": "File?",
            "secondaryFiles": [
              "${\n    var output_ext = inputs.output_file_format ? inputs.output_file_format : \"vcf.gz\";\n    if (output_ext == \"vcf\")\n    {\n        return self.basename + \".idx\";\n    }\n    else \n    {\n        return self.basename + \".tbi\";\n    }\n    \n}"
            ],
            "label": "Ouput filtered variants file",
            "sbg:fileTypes": "VCF.GZ",
            "id": "out_variants",
            "outputBinding": {
              "glob": "${\n    var output_ext = inputs.output_file_format ? inputs.output_file_format : \"vcf.gz\";\n    return \"*\" + output_ext;\n        \n    \n    \n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_variants))"
            },
            "doc": "Ouput filtered variants file"
          }
        ],
        "sbg:id": "h-19aa970c/h-48bd1b69/h-0fc9c122/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "add_output_vcf_command_line",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "add_output_vcf_command_line",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--add-output-vcf-command-line",
              "position": 4
            },
            "doc": "If true, adds a command line header line to created vcf files.",
            "sbg:altPrefix": "-add-output-vcf-command-line",
            "sbg:category": "Optional Arguments",
            "label": "Add output vcf command line"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "3",
            "id": "cluster_size",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--cluster-size",
              "position": 4
            },
            "doc": "The number of SNPs which make up a cluster. Must be at least 2.",
            "sbg:altPrefix": "-cluster",
            "sbg:category": "Optional Arguments",
            "label": "Cluster size"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "cluster_window_size",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--cluster-window-size",
              "position": 4
            },
            "doc": "The window size (in bases) in which to evaluate clustered SNPs.",
            "sbg:altPrefix": "-window",
            "sbg:category": "Optional Arguments",
            "label": "Cluster window size"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "create_output_variant_index",
                "symbols": [
                  "true",
                  "false"
                ]
              }
            ],
            "sbg:toolDefaultValue": "true",
            "id": "create_output_variant_index",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--create-output-variant-index",
              "position": 4
            },
            "doc": "If true, create a VCF index when writing a coordinate-sorted VCF file.",
            "sbg:altPrefix": "-OVI",
            "sbg:category": "Optional Arguments",
            "label": "Create output variant index"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_bam_index_caching",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-bam-index-caching",
              "position": 4
            },
            "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified.",
            "sbg:altPrefix": "-DBIC",
            "sbg:category": "Optional Arguments",
            "label": "Disable BAM index caching"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_sequence_dictionary_validation",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-sequence-dictionary-validation",
              "position": 4
            },
            "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk!",
            "sbg:altPrefix": "-disable-sequence-dictionary-validation",
            "sbg:category": "Optional Arguments",
            "label": "Disable sequence dictionary validation"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "disable_tool_default_read_filters",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--disable-tool-default-read-filters",
              "position": 4
            },
            "doc": "Disable all tool default read filters (warning: many tools will not function correctly without their default read filters on).",
            "sbg:altPrefix": "-disable-tool-default-read-filters",
            "sbg:category": "Advanced Arguments",
            "label": "Disable tool default read filters"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals_file",
            "sbg:fileTypes": "BED",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--exclude-intervals",
              "position": 4
            },
            "doc": "File which contains one or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude intervals file"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "exclude_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--exclude-intervals', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    return '';\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals to exclude from processing.",
            "sbg:altPrefix": "-XL",
            "sbg:category": "Optional Arguments",
            "label": "Exclude intervals string"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "filter_expression",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--filter-expression', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    return '';\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more expressions used with INFO fields to filter.",
            "sbg:altPrefix": "-filter",
            "sbg:category": "Optional Arguments",
            "label": "Filter expression"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "filter_name",
            "doc": "Names to use for the list of filters.",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--filter-name', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    return '';\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Filter name"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "filter_not_in_mask",
            "doc": "Filter records not in given input mask.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--filter-not-in-mask",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Filter not in mask"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "genotype_filter_expression",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--genotype-filter-expression', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    return '';\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more expressions used with FORMAT (sample/genotype-level) fields to filter (see documentation guide for more info).",
            "sbg:altPrefix": "-G-filter",
            "sbg:category": "Optional Arguments",
            "label": "Genotype filter expression"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "genotype_filter_name",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--genotype-filter-name', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    return '';\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "Names to use for the list of sample/genotype filters (must be a 1-to-1 mapping); this name is put in the FILTER field for variants that get filtered.",
            "sbg:altPrefix": "-G-filter-name",
            "sbg:category": "Optional Arguments",
            "label": "Genotype filter name"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_exclusion_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-exclusion-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are excluding.",
            "sbg:altPrefix": "-ixp",
            "sbg:category": "Optional Arguments",
            "label": "Interval exclusion padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_merging_rule",
                "symbols": [
                  "ALL",
                  "OVERLAPPING_ONLY"
                ]
              }
            ],
            "sbg:toolDefaultValue": "ALL",
            "id": "interval_merging_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-merging-rule",
              "position": 4
            },
            "doc": "Interval merging rule for abutting intervals.",
            "sbg:altPrefix": "-imr",
            "sbg:category": "Optional Arguments",
            "label": "Interval merging rule"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "interval_padding",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-padding",
              "position": 4
            },
            "doc": "Amount of padding (in bp) to add to each interval you are including.",
            "sbg:altPrefix": "-ip",
            "sbg:category": "Optional Arguments",
            "label": "Interval padding"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "interval_set_rule",
                "symbols": [
                  "UNION",
                  "INTERSECTION"
                ]
              }
            ],
            "sbg:toolDefaultValue": "UNION",
            "id": "interval_set_rule",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--interval-set-rule",
              "position": 4
            },
            "doc": "Set merging approach to use for combining interval inputs.",
            "sbg:altPrefix": "-isr",
            "sbg:category": "Optional Arguments",
            "label": "Interval set rule"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals_file",
            "sbg:fileTypes": "BED",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--intervals",
              "position": 4
            },
            "doc": "File which contains one or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Include intervals file"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "null",
            "id": "include_intervals_string",
            "inputBinding": {
              "valueFrom": "${\n    if (self)\n    {\n        var cmd = [];\n        for (var i = 0; i < self.length; i++) \n        {\n            cmd.push('--intervals', self[i]);\n        }\n        return cmd.join(' ');\n    }\n    return '';\n}",
              "shellQuote": false,
              "prefix": "",
              "position": 4
            },
            "doc": "One or more genomic intervals over which to operate.",
            "sbg:altPrefix": "-L",
            "sbg:category": "Optional Arguments",
            "label": "Include intervals string"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "invalidate_previous_filters",
            "doc": "Remove previous filters applied to the VCF.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--invalidate-previous-filters",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Invalidate previous filters"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "invert_filter_expression",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--invert-filter-expression",
              "position": 4
            },
            "doc": "Invert the selection criteria for --filter-expression.",
            "sbg:altPrefix": "-invfilter",
            "sbg:category": "Optional Arguments",
            "label": "Invert filter expression"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "invert_genotype_filter_expression",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--invert-genotype-filter-expression",
              "position": 4
            },
            "doc": "Invert the selection criteria for --genotype-filter-expression.",
            "sbg:altPrefix": "-invG-filter",
            "sbg:category": "Optional Arguments",
            "label": "Invert genotype filter expression"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "lenient",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--lenient",
              "position": 4
            },
            "doc": "Lenient processing of VCF files.",
            "sbg:altPrefix": "-LE",
            "sbg:category": "Optional Arguments",
            "label": "Lenient"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "null",
            "id": "mask",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--mask",
              "position": 4
            },
            "doc": "Input mask.",
            "sbg:altPrefix": "-mask",
            "sbg:category": "Optional Arguments",
            "label": "Mask"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "mask_extension",
            "doc": "How many bases beyond records from a provided 'mask' should variants be filtered.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--mask-extension",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Mask extension"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "Mask",
            "id": "mask_name",
            "doc": "The text to put in the FILTER field if a 'mask' is provided and overlaps with a variant call.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--mask-name",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Mask name"
          },
          {
            "type": "int?",
            "id": "memory_overhead_per_job",
            "doc": "This input allows a user to set the desired overhead memory when running a tool or adding it to a workflow. This amount will be added to the Memory per job in the Memory requirements section but it will not be added to the -Xmx parameter leaving some memory not occupied which can be used as stack memory (-Xmx parameter defines heap memory). This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory overhead per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "int?",
            "id": "memory_per_job",
            "doc": "This input allows a user to set the desired memory requirement when running a tool or adding it to a workflow. This value should be propagated to the -Xmx parameter too.This input should be defined in MB (for both the platform part and the -Xmx part if Java tool is wrapped).",
            "label": "Memory per job",
            "sbg:category": "Platform Options"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "missing_values_evaluate_as_failing",
            "doc": "When evaluating the JEXL expressions, missing values should be considered failing the expression.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--missing-values-evaluate-as-failing",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Missing values evaluate as failing"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "secondaryFiles": [
              ".fai",
              "^.dict"
            ],
            "id": "in_reference",
            "sbg:fileTypes": "FASTA, FA",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--reference",
              "position": 4
            },
            "doc": "Reference sequence.",
            "sbg:altPrefix": "-R",
            "sbg:category": "Optional Arguments",
            "label": "Reference"
          },
          {
            "type": "File?",
            "sbg:toolDefaultValue": "null",
            "id": "sequence_dictionary",
            "sbg:fileTypes": "DICT",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sequence-dictionary",
              "position": 4
            },
            "doc": "Use the given sequence dictionary as the master/canonical sequence dictionary. Must be a .dict file.",
            "sbg:altPrefix": "-sequence-dictionary",
            "sbg:category": "Optional Arguments",
            "label": "Sequence dictionary"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "set_filtered_genotype_to_no_call",
            "doc": "Set filtered genotypes to no-call.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--set-filtered-genotype-to-no-call",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Set filtered genotype to no call"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "false",
            "id": "sites_only_vcf_output",
            "doc": "If true, don't emit genotype fields when writing VCF file output.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sites-only-vcf-output",
              "position": 4
            },
            "sbg:category": "Optional Arguments",
            "label": "Sites only vcf output"
          },
          {
            "type": "File",
            "secondaryFiles": [
              "${\n    if (self.nameext == \".vcf\")\n    {\n        return \".idx\";\n    }\n    else\n    {\n        return self.basename + \".tbi\";\n    }\n}"
            ],
            "id": "in_variants",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--variant",
              "position": 4
            },
            "doc": "A VCF file containing variants.",
            "sbg:altPrefix": "-V",
            "sbg:category": "Required Arguments",
            "label": "Input variants file"
          },
          {
            "type": "string?",
            "id": "output_prefix",
            "doc": "Output file name prefix.",
            "label": "Output prefix",
            "sbg:category": "Optional Arguments"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "output_file_format",
                "symbols": [
                  "vcf",
                  "vcf.gz"
                ]
              }
            ],
            "sbg:toolDefaultValue": "VCF.GZ",
            "id": "output_file_format",
            "label": "Output file format",
            "sbg:category": "Optional Arguments",
            "doc": "Output file format."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Optional Arguments",
            "doc": "CPU per job."
          }
        ],
        "cwlVersion": "v1.0",
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "/opt/gatk",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job)\n    {\n        return \"--java-options\";\n    }\n    else\n    {\n        return '';\n    }\n}\n    ",
            "shellQuote": false,
            "prefix": "",
            "position": 1
          },
          {
            "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"';\n    }\n    return '';\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "VariantFiltration",
            "shellQuote": false,
            "position": 3
          },
          {
            "valueFrom": "${\n    var in_variants = inputs.in_variants;\n    var output_ext = inputs.output_file_format ? inputs.output_file_format : \"vcf.gz\";\n    var output_prefix = '';\n    if (inputs.output_prefix)\n    {\n        output_prefix = inputs.output_prefix;\n    }\n    else \n    {\n        if (in_variants.metadata && in_variants.metadata.sample_id)\n        {\n            output_prefix = in_variants.metadata.sample_id;\n        }\n        else \n        {\n            output_prefix = in_variants.path.split('/').pop().split('.')[0];\n        }\n    }\n    \n    return \"--output \" + output_prefix + \".variant_filtered.\" + output_ext;\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 4
          }
        ],
        "sbg:modifiedOn": 1559750433,
        "sbg:publisher": "sbg",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "4.1.0.0",
        "sbg:revision": 7,
        "sbg:categories": [
          "Utilities",
          "VCF Processing",
          "Variant Filtration"
        ]
      },
      "in": [
        {
          "id": "cluster_size",
          "default": 3
        },
        {
          "id": "cluster_window_size",
          "default": 35
        },
        {
          "id": "filter_expression",
          "default": [
            "\"FS > 30.0\"",
            "\"QD < 2.0\""
          ]
        },
        {
          "id": "filter_name",
          "default": [
            "\"FS\"",
            "\"QD\""
          ]
        },
        {
          "source": "in_reference",
          "id": "in_reference"
        },
        {
          "source": "gatk_mergevcfs_4_1_0_0/out_variants",
          "id": "in_variants"
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "output_prefix"
        }
      ],
      "sbg:y": -106,
      "label": "GATK VariantFiltration",
      "sbg:x": 2423.5,
      "out": [
        {
          "id": "out_variants"
        }
      ]
    },
    {
      "id": "star_align_2_5_3a_modified",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "nemanja.vucic",
        "sbg:latestRevision": 6,
        "sbg:modifiedBy": "nemanja.vucic",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://github.com/alexdobin/STAR"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/alexdobin/STAR"
          },
          {
            "label": "Download",
            "id": "https://github.com/alexdobin/STAR/archive/2.7.0d.tar.gz"
          },
          {
            "label": "Publication",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed/23104886"
          },
          {
            "label": "Documentation",
            "id": "http://labshare.cshl.edu/shares/gingeraslab/www-data/dobin/STAR/STAR.sandbox/doc/STARmanual.pdf"
          }
        ],
        "sbg:cmdPreview": "str='SE' && count=`samtools view -h /test-data/chr20sample_pe1.bam | head -n 500000 | samtools view -c -f 0x1 -` && if [ $count != 0 ]; then str='PE'; fi; tar -xvf chr20genome.ext && STARlong --runThreadN 6 --readFilesCommand samtools view -h  --twopass1readsN -1  --outSAMattrRGline ID:SAMPLE_TEST PI:rg_mfl PL:Ion_Torrent_PGM PU:rg_platform_unit SM:rg_sample --outFileNamePrefix ./SAMPLE_TEST.twopass-basic.  --solotype Droplet  --readFilesType SAM $str --readFilesIn /test-data/chr20sample_pe1.bam  && tar -vcf SAMPLE_TEST.twopass-basic._STARgenome.tar ./SAMPLE_TEST.twopass-basic._STARgenome   && cat SAMPLE_TEST.twopass-basic.Unmapped.out.mate1 | sed 's/\\t.*//' | paste - - - - | sort -k1,1 -S 10G | tr '\\t' '\\n' > SAMPLE_TEST.twopass-basic.Unmapped.out.mate1.fastq && rm SAMPLE_TEST.twopass-basic.Unmapped.out.mate1  && bash index_bam SAMPLE_TEST.twopass-basic.Aligned.sortedByCoord.out.bam",
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n  var memory = 46080;\n  if(inputs.mem_per_job){\n  \t memory = inputs.mem_per_job\n  }\n return memory\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 8\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/veliborka_josipovic/star:2.5.3a_modified",
            "class": "DockerRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
            ]
          }
        ],
        "doc": "**STAR** is an ultrafast universal RNA-seq aligner. \n\n**STAR** (Spliced Transcripts Alignment to a Reference), an ultrafast RNA-seq aligner, is capable of mapping full length RNA sequences and detecting de novo canonical junctions, non-canonical splices, and chimeric (fusion) transcripts. **STAR** employs an RNA-seq alignment algorithm that uses sequential maximum mappable seed search in uncompressed suffix arrays followed by seed clustering and stitching procedure. It is optimized for mammalian sequence reads, but fine tuning of its parameters enables customization to satisfy unique needs [1].\n\n**STAR** works with reads starting from lengths ~15 bases up to ~300 bases. In case of having longer reads, the use of **STAR Long** tool is recommended instead.\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of this page.*\n\n### Common Use Cases\n\nThe main purpose of **STAR** is to generate aligned BAM files (in genome and transcriptome coordinates) from RNA-seq data, which can later be used in further RNA studies, like gene expression analysis for example. \n\nSome important notes about this tool are: \n\n- The main input to the tool are **Reads** (`--readFilesIn`) in FASTQ format (single end or paired end), or unaligned BAM format.\n- **Genome files** in the form of a **STAR index archive**, outputted by the **STAR Genome Generate** tool, also need to be provided.\n- It\u2019s generally a good idea to always provide a GTF file to the inputs, if you want to get the **Transcriptome aligned reads** and **Reads per gene** outputs. \n- The main output of this tool is the **Aligned reads** output in coordinate sorted BAM format. The **Transcriptome aligned reads** BAM file is produced if the **Quantification mode** (`--quantMode`) parameter is set to **TranscriptomeSAM**. \n- Gene counts are produced if the **Quantification mode** (`--quantMode`) parameter is set to **GeneCounts**.  \n- **STAR** can detect chimeric transcripts, but the parameter **Min chimeric segment** (`--chimSegmentMin`) in *Chimeric Alignments*  category must be adjusted to a desired minimum chimeric segment length (12 is a good value, as recommended by the **STAR-Fusion** wiki). This output can later be used in **STAR-Fusion** for further fusion analysis. \n- If you want to use **STAR** results as an input to an RNA-seq differential expression analysis(using the **Cufflinks** app), set the parameter **Strand field flag** (`--outSAMstrandField`) to **intronMotif**.\n- Unmapped reads in FASTQ format are outputted on the **Unmapped reads** output if the **Output unmapped reads** (`--outReadsUnmapped`) parameter is set to the **Fastx** value. \n- Unmapped reads can be outputted within the main out BAM file on the **Aligned reads** and **Transcriptome aligned reads** outputs if the **Write unmapped in SAM** (`--outSAMunmapped`) parameter is set to **Within** or **Within KeepPairs**. \n- A basic **Two-pass mode** can be turned during the alignment step, which means that all the first pass junctions will be inserted into the genome indices for the second pass, by setting the **Two-pass mode** (`--twopassMode`) option to **Basic**. \n\nAdditionally, if you have long reads available and wish to map them with STAR, setting the **STARlong** option will run the **STARlong** algorithm instead, which uses a more efficient seed stitching algorithm for long reads (>200b), and also uses different array allocations. Selecting this boolean option will also automatically change the following parameters of STAR to comply with long read alignment best practices:\n`--outFilterMultimapScoreRange 20`\n`--outFilterScoreMinOverLread 0`\n`--outFilterMismatchNmax 1000`\n`--winAnchorMultimapNmax 200`\n`--seedSearchLmax 30`\n`--seedSearchStartLmax 12`\n`--seedPerReadNmax 100000`\n`--seedPerWindowNmax 100`\n`--alignTranscriptsPerReadNmax 100000`\n`--alignTranscriptsPerWindowNmax 10000`\n\n###Common issues###\n- For paired-end read files, it is important to properly set the **Paired-end** metadata field on your read files.\n- For FASTQ reads in multi-file format (i.e. two FASTQ files for paired-end 1 and two FASTQ files for paired-end2), the proper metadata needs to be set (the following hierarchy is valid: **Sample ID/Library ID/Platform Unit ID/File Segment Number**).\n\n### Changes Introduced by Seven Bridges\n\n- All output files will be prefixed by the input sample ID (inferred from the **Sample ID** metadata if existent, of from filename otherwise), unless the **Output file name prefix** option is explicitly specified.\n- **Unmapped reads** in FASTQ format are by default unsorted by read ID. This can induce problems if these files are used in subsequent analysis (i.e. downstream alignment). The option to sort unmapped reads by read ID is added to this wrapper, by setting the **Sort unmapped reads** parameter to True. The suffix for the **Unmapped reads** output can be controlled by the **Unmapped output file names** options (the default is *Unmapped*).\n- The tool can accept uncompressed FASTQ files, as well as GZ and BZ2 compressed FASTQ files, without the user having to specify anything. Also, if unaligned BAM files are used as inputs, the single-end/paired-end flag (SE/PE) needn't be specified - it will be inferred automatically using a built-in **Samtools** script. \n\n### Performance Benchmarking\n\nBelow is a table describing the runtimes and task costs for a couple of samples with different file sizes, with the following options in mind - unmapped reads are sorted by read id, output BAM is sorted by coordinate and basic two pass mode is turned on:\n\n| Experiment type |  Input size | Paired-end | # of reads | Read length | Duration |  Cost |  Instance (AWS) |\n|:---------------:|:-----------:|:----------:|:----------:|:-----------:|:--------:|:-----:|:----------:|\n|     RNA-Seq     |  2 x 230 MB |     Yes    |     1M     |     101     |   18min   | $0.40 | c4.8xlarge |\n|     RNA-Seq     |  2 x 4.5 GB |     Yes    |     20M     |     101     |   30min   | $0.60 | c4.8xlarge |\n|     RNA-Seq     | 2 x 17.4 GB |     Yes    |     76M    |     101     |   64min  | $1.20 | c4.8xlarge |\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n### References\n\n[1] [STAR paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3530905/)",
        "sbg:project": "nemanja.vucic/star-2-5-3a-modified-demo",
        "sbg:sbgMaintained": false,
        "sbg:createdOn": 1553263204,
        "sbg:toolkitVersion": "2.5.3a_modified",
        "sbg:image_url": null,
        "sbg:projectName": "STAR 2.5.3a_modified - Demo",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:toolkit": "STAR",
        "sbg:content_hash": "aa91bd21a289b80c6555b27638d519f17cef5356588990f0181fcb308658c7a5f",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1553263204,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "nemanja.vucic"
          },
          {
            "sbg:modifiedOn": 1553263777,
            "sbg:revision": 1,
            "sbg:revisionNotes": "",
            "sbg:modifiedBy": "nemanja.vucic"
          },
          {
            "sbg:modifiedOn": 1559667867,
            "sbg:revision": 2,
            "sbg:revisionNotes": "tested with cwltool",
            "sbg:modifiedBy": "nemanja.vucic"
          },
          {
            "sbg:modifiedOn": 1561561602,
            "sbg:revision": 3,
            "sbg:revisionNotes": "added expression which adds metadata",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1561564707,
            "sbg:revision": 4,
            "sbg:revisionNotes": "keep only platform info in expression",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1561633860,
            "sbg:revision": 5,
            "sbg:revisionNotes": "added ID:1 in--outSAMattrRGline arg",
            "sbg:modifiedBy": "veliborka_josipovic"
          },
          {
            "sbg:modifiedOn": 1571322491,
            "sbg:revision": 6,
            "sbg:revisionNotes": "back to revision 2",
            "sbg:modifiedBy": "nemanja.vucic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:toolAuthor": "Alexander Dobin/CSHL",
        "sbg:revisionNotes": "back to revision 2",
        "label": "STAR Align",
        "sbg:contributors": [
          "nemanja.vucic",
          "veliborka_josipovic"
        ],
        "outputs": [
          {
            "type": "File?",
            "secondaryFiles": [
              ".bai"
            ],
            "label": "Aligned SAM/BAM",
            "sbg:fileTypes": "SAM, BAM",
            "id": "out_aligned_reads",
            "outputBinding": {
              "glob": "${\n    var sam_name;\n    \n    if (inputs.outSortingType && inputs.outSortingType == \"SortedByCoordinate\") {\n        var sort_name = \".sortedByCoord\";\n    } else {\n        var sort_name = \"\";\n    }\n    if (inputs.outSAMtype && inputs.outSAMtype == \"SAM\") {\n        var sam_name = \"*.Aligned.out.sam\";\n    } else {\n        var sam_name = \"*.Aligned\".concat(sort_name, \".out.bam\");\n    }\n    return sam_name;\n}",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "Aligned sequence in SAM/BAM format."
          },
          {
            "type": "File?",
            "label": "Chimeric alignments",
            "sbg:fileTypes": "SAM",
            "id": "out_chimeric_alignments",
            "outputBinding": {
              "glob": "*.Chimeric.out.sam",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "Aligned Chimeric sequences SAM - if chimSegmentMin = 0, no Chimeric Alignment SAM and Chimeric Junctions outputs."
          },
          {
            "type": "File?",
            "label": "Chimeric junctions",
            "sbg:fileTypes": "JUNCTION",
            "id": "out_chimeric_junctions",
            "outputBinding": {
              "glob": "*Chimeric.out.junction",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "Chimeric junctions file. If chimSegmentMin in 'Chimeric Alignments' section is set to 0, 'Chimeric Junctions' won't be output."
          },
          {
            "type": "File?",
            "label": "Intermediate genome files",
            "sbg:fileTypes": "TAR",
            "id": "out_intermediate_genome",
            "outputBinding": {
              "glob": "*_STARgenome.tar",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "Archive with genome files produced when annotations are included on the fly (in the mapping step)."
          },
          {
            "type": "File[]?",
            "label": "Log files",
            "sbg:fileTypes": "OUT",
            "id": "out_log_files",
            "outputBinding": {
              "glob": "*Log*.out",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "Log files produced during alignment."
          },
          {
            "type": "File?",
            "label": "Reads per gene",
            "sbg:fileTypes": "TAB",
            "id": "out_reads_per_gene",
            "outputBinding": {
              "glob": "*ReadsPerGene*",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "File with number of reads per gene. A read is counted if it overlaps (1nt or more) one and only one gene."
          },
          {
            "type": "File?",
            "label": "Splice junctions",
            "sbg:fileTypes": "TAB",
            "id": "out_splice_junctions",
            "outputBinding": {
              "glob": "*SJ.out.tab",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "High confidence collapsed splice junctions in tab-delimited format. Only junctions supported by uniquely mapping reads are reported."
          },
          {
            "type": "File?",
            "label": "Transcriptome alignments",
            "sbg:fileTypes": "SAM, BAM",
            "id": "out_transcriptome_aligned_reads",
            "outputBinding": {
              "glob": "*Transcriptome*",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "Alignments translated into transcript coordinates."
          },
          {
            "type": "File[]?",
            "label": "Unmapped reads",
            "sbg:fileTypes": "FASTQ",
            "id": "out_unmapped_reads",
            "outputBinding": {
              "glob": "${\n    if (inputs.unmappedOutputName) {\n        return \"*\" + inputs.unmappedOutputName + \"*\";\n    } else {\n        return \"*Unmapped.out*\";\n    }\n\n}",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "Unmapped reads in FASTQ format."
          },
          {
            "type": "File[]?",
            "label": "Wiggle files",
            "sbg:fileTypes": "WIG, BG",
            "id": "out_wiggle_files",
            "outputBinding": {
              "glob": "{*.wig, *.bg}",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reads)\n\n}"
            },
            "doc": "Wiggle output files (either wiggle or bedgraph, depending on which input parameter is set)."
          }
        ],
        "sbg:id": "h-1c7acc86/h-74195fa8/h-5619d09e/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": "string?",
            "sbg:toolDefaultValue": "0 ConcordantPair",
            "id": "alignEndsProtrude",
            "doc": "Allow protrusion of alignment ends, i.e. start (end) of the +strand mate downstream of the start (end) of the -strand mate. The input should two arguments separated by a space: the first is the maximum number of protrusion bases allowed, and the second is [Concordantpair or DiscordantPair], telling whether to report alignments with non-zero protrusion as concordant/discordant pairs.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignEndsProtrude",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Protrusion of alignment ends"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignEndsType",
                "symbols": [
                  "Local",
                  "EndToEnd",
                  "Extend5pOfRead1",
                  "Extend3pOfRead1",
                  "Extend5pOfReads12"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Local",
            "id": "alignEndsType",
            "doc": "Type of read ends alignment. Local: standard local alignment with soft-clipping allowed. EndToEnd: force end to end read alignment, do not soft-clip; Extend5pOfRead1: fully extend only the 5p of the read1, all other ends: local alignment; Extend5pOfReads12: full extension of 5' ends of both mates.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignEndsType",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Alignment type"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignInsertionFlush",
                "symbols": [
                  "None",
                  "Right"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "alignInsertionFlush",
            "doc": "How to flush ambiguous insertion positions. None: old method, insertions are not flushed; Right: insertions are flushed to the right.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignInsertionFlush",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Align insertion flush"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "alignIntronMax",
            "doc": "Maximum intron size, if 0, max intron size will be determined by (2^winBinNbits)*winAnchorDistNbins.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignIntronMax",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Max intron size"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "21",
            "id": "alignIntronMin",
            "doc": "Minimum intron size: genomic gap is considered intron if its length >= alignIntronMin, otherwise it is considered Deletion (int>=0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignIntronMin",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Min intron size"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "alignMatesGapMax",
            "doc": "Maximum gap between two mates, if 0, max intron gap will be determined by (2^winBinNbits)*winAnchorDistNbins.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignMatesGapMax",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Max mates gap"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "3",
            "id": "alignSJDBoverhangMin",
            "doc": "Minimum overhang (i.e. block size) for annotated (sjdb) spliced alignments (int>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignSJDBoverhangMin",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Min overhang: annotated"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "5",
            "id": "alignSJoverhangMin",
            "doc": "Minimum overhang (i.e. block size) for spliced alignments (int>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignSJoverhangMin",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Min overhang"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "0 -1 0 0",
            "id": "alignSJstitchMismatchNmax",
            "doc": "4*int>=0: maximum number of mismatches for stitching of the splice junctions (-1: no limit). (1) non-canonical motifs, (2) GT/AG and CT/AC motif, (3) GC/AG and CT/GC motif, (4) AT/AC and GT/AT motif.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignSJstitchMismatchNmax",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Splice junction stich max mismatch"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignSoftClipAtReferenceEnds",
                "symbols": [
                  "Yes",
                  "No"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Yes",
            "id": "alignSoftClipAtReferenceEnds",
            "doc": "Option which allows soft clipping of alignments at the reference (chromosome) ends. Can be disabled for compatibility with Cufflinks/Cuffmerge. Yes: Enables soft clipping; No: Disables soft clipping.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignSoftClipAtReferenceEnds",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Soft clipping"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "alignSplicedMateMapLmin",
            "doc": "Minimum mapped length for a read mate that is spliced (int>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignSplicedMateMapLmin",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Min mapped length"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.66",
            "id": "alignSplicedMateMapLminOverLmate",
            "doc": "AlignSplicedMateMapLmin normalized to mate length (float>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignSplicedMateMapLminOverLmate",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Min mapped length normalized"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10000",
            "id": "alignTranscriptsPerReadNmax",
            "label": "Max transcripts per read",
            "sbg:category": "Alignments and Seeding",
            "doc": "Max number of different alignments per read to consider (int>0)."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "100",
            "id": "alignTranscriptsPerWindowNmax",
            "label": "Max transcripts per window",
            "sbg:category": "Alignments and Seeding",
            "doc": "Max number of transcripts per window (int>0)."
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "10000",
            "id": "alignWindowsPerReadNmax",
            "doc": "Max number of windows per read (int>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--alignWindowsPerReadNmax",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Max windows per read"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "bamRemoveDuplicatesMate2basesN",
            "label": "BAM remove duplicates mate2 bases",
            "sbg:category": "BAM processing",
            "doc": "Number of bases from the 5' end of mate 2 to use in collapsing (e.g. for RAMPAGE)."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "bamRemoveDuplicatesType",
                "symbols": [
                  "UniqueIdentical",
                  "UniqueIdenticalNotMulti"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Off",
            "id": "bamRemoveDuplicatesType",
            "label": "BAM remove duplicates type",
            "sbg:category": "BAM processing",
            "doc": "Mark duplicates in the BAM file. For now, only works with paired-end alignments. UniqueIdentical: mark all mutlimappers and duplicate unique mappers. The coordinates, FLAG, CIGAR must be identical. UniqueIdenticalNotMulti: mark duplicate unique mappers but not multimappers."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "chimFilter",
                "symbols": [
                  "banGenomicN",
                  "None"
                ]
              }
            ],
            "sbg:toolDefaultValue": "banGenomicN",
            "id": "chimFilter",
            "doc": "Different filters for chimeric alignments None no filtering banGenomicN Ns are not allowed in the genome sequence around the chimeric junction.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimFilter",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Chimeric filter"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "20",
            "id": "chimJunctionOverhangMin",
            "doc": "Minimum overhang for a chimeric junction (int>=0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimJunctionOverhangMin",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Min junction overhang"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "chimMainSegmentMultNmax",
            "doc": "Maximum number of multi-alignments for the main chimeric segment. The value of 1 will prohibit multimapping main segments.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimMainSegmentMultNmax",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Max main chimeric segment alignments"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "chimMultimapNmax",
            "doc": "Maximum number of chimeric multi-alignments (0 - use the old scheme for chimeric detection which only considered unique alignments).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimMultimapNmax",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Chimeric multimap max number"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "chimMultimapScoreRange",
            "doc": "The score range for multi-mapping chimeras below the best chimeric score. Only works with chimMultimapNmax > 1.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimMultimapScoreRange",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Chimeric multimap score range"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "20",
            "id": "chimNonchimScoreDropMin",
            "doc": "To trigger chimeric detection, the drop in the best non-chimeric alignment score with respect to the read lenght has to be smaller than this value.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimNonchimScoreDropMin",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Minimum no-chimeric drop score"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "chimOutJunctionFormat",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:toolDefaultValue": "0",
            "id": "chimOutJunctionFormat",
            "doc": "Formatting type for the Chimeric.out.junction file. 0 - no comment lines/headers; 1 - comment lines at the end of the file: command line and Nreads: total, unique, multi.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimOutJunctionFormat",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Chimeric file format"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "chimOutType",
                "symbols": [
                  "Junctions",
                  "SeparateSAMold",
                  "WithinBAM",
                  "WithinBAM HardClip",
                  "WithinBAM SoftClip",
                  "Junctions SeparateSAMold"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Junctions",
            "id": "chimOutType",
            "doc": "Type of chimeric output. SeparateSAMold: output old SAM into separate Chimeric.out.sam file; WithinBAM: output into main aligned SAM/BAM files. WithinBAM HardClip -  hard-clipping in the CIGAR for supplemental chimeric alignments; WithinBAM SoftClip - soft-clipping in the CIGAR for supplemental chimeric alignments. Outputs in both SAM and junctions file format are available with the 'Junctions SeparateSAMold' option.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimOutType",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Chimeric output type"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "20",
            "id": "chimScoreDropMax",
            "doc": "Max drop (difference) of chimeric score (the sum of scores of all chimeric segements) from the read length (int>=0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimScoreDropMax",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Max drop score"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-1",
            "id": "chimScoreJunctionNonGTAG",
            "doc": "Penalty for a non-GT/AG chimeric junction.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimScoreJunctionNonGTAG",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Non-GT/AG penalty"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "chimScoreMin",
            "doc": "Minimum total (summed) score of the chimeric segments (int>=0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimScoreMin",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Min total score"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "chimScoreSeparation",
            "doc": "Minimum difference (separation) between the best chimeric score and the next one (int>=0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimScoreSeparation",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Min separation score"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "chimSegmentMin",
            "doc": "Minimum length of chimeric segment length, if =0, no chimeric output (int>=0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimSegmentMin",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Min chimeric segment"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "chimSegmentReadGapMax",
            "doc": "Maximum gap in the read sequence between chimeric segments (int>=0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--chimSegmentReadGapMax",
              "position": 2
            },
            "sbg:category": "Chimeric Alignments",
            "label": "Chimeric segment gap"
          },
          {
            "type": "float[]?",
            "sbg:toolDefaultValue": "0.1",
            "id": "clip3pAdapterMMp",
            "doc": "Max proportion of mismatches for 3p adapter clipping for each mate. In case only one value is given, it will be assumed the same for both mates.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--clip3pAdapterMMp",
              "position": 2
            },
            "sbg:category": "Read parameters",
            "label": "Max mismatches proportions"
          },
          {
            "type": "string[]?",
            "sbg:toolDefaultValue": "-",
            "id": "clip3pAdapterSeq",
            "doc": "Adapter sequence to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--clip3pAdapterSeq",
              "position": 2
            },
            "sbg:category": "Read parameters",
            "label": "Clip 3p adapter sequence"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "0",
            "id": "clip3pAfterAdapterNbases",
            "doc": "Number of bases to clip from 3p of each mate after the adapter clipping. In case only one value is given, it will be assumed the same for both mates.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--clip3pAfterAdapterNbases",
              "position": 2
            },
            "sbg:category": "Read parameters",
            "label": "Clip 3p after adapter seq"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "0",
            "id": "clip3pNbases",
            "doc": "Number of bases to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--clip3pNbases",
              "position": 2
            },
            "sbg:category": "Read parameters",
            "label": "Clip 3p bases"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "0",
            "id": "clip5pNbases",
            "doc": "Number of bases to clip from 5p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--clip5pNbases",
              "position": 2
            },
            "sbg:category": "Read parameters",
            "label": "Clip 5p bases"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform options",
            "doc": "Number of CPUs to be used per job."
          },
          {
            "type": "File",
            "id": "in_index",
            "sbg:fileTypes": "TAR",
            "label": "Genome files",
            "sbg:category": "Basic",
            "doc": "Genome files created using STAR Genome Generate."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "genomeDir",
            "id": "genomeDirName",
            "label": "Genome dir name",
            "sbg:category": "Basic",
            "doc": "Name of the directory which contains genome files (when genome.tar is uncompressed)."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "57000000000",
            "id": "limitBAMsortRAM",
            "label": "Limit BAM sorting memory",
            "sbg:category": "Limits",
            "doc": "Maximum available RAM for sorting BAM. If set to 0, it will be set to the genome index size."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1000000",
            "id": "limitOutSJcollapsed",
            "doc": "Max number of collapsed junctions.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--limitOutSJcollapsed",
              "position": 2
            },
            "sbg:category": "Limits",
            "label": "Collapsed junctions max number"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1000",
            "id": "limitOutSJoneRead",
            "doc": "Max number of junctions for one read (including all multi-mappers).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--limitOutSJoneRead",
              "position": 2
            },
            "sbg:category": "Limits",
            "label": "Junctions max number"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1000000",
            "id": "limitSjdbInsertNsj",
            "doc": "Maximum number of junction to be inserted to the genome on the fly at the mapping stage, including those from annotations and those detected in the 1st step of the 2-pass run.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--limitSjdbInsertNsj",
              "position": 2
            },
            "sbg:category": "Limits",
            "label": "Max insert junctions"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2048",
            "id": "mem_per_job",
            "label": "Memory per job",
            "sbg:category": "Platform options",
            "doc": "Amount of RAM memory to be used per job. Defaults to 2048MB for Single threaded jobs,and all of the available memory on the instance for multi-threaded jobs."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "Off",
            "id": "no_read_groups",
            "label": "No read groups",
            "sbg:category": "Read group",
            "doc": "If this boolean argument is specified, no read groups will be set in the resulting BAM header."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-1",
            "id": "outBAMcompression",
            "doc": "BAM compression level. -1=default compression (6), 0=no compression, 10=maximum compression.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outBAMcompression",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Output BAM compression"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "50",
            "id": "outBAMsortingBinsN",
            "doc": "Number of genome bins fo coordinate-sorting. number of genome bins fo coordinate-sorting",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outBAMsortingBinsN",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Output BAM sorting bins"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "outBAMsortingThreadN",
            "doc": "Number of threads for BAM sorting. 0 will default to min(6,\u2013runThreadN).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outBAMsortingThreadN",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Output BAM sorting threads"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "sample_id",
            "id": "out_prefix",
            "label": "Output file name prefix",
            "sbg:category": "Output",
            "doc": "Prefix to be added to all output files."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outFilterIntronMotifs",
                "symbols": [
                  "None",
                  "RemoveNoncanonical",
                  "RemoveNoncanonicalUnannotated"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "outFilterIntronMotifs",
            "doc": "Filter alignment using their motifs. None: no filtering; RemoveNoncanonical: filter out alignments that contain non-canonical junctions; RemoveNoncanonicalUnannotated: filter out alignments that contain non-canonical unannotated junctions when using annotated splice junctions database. The annotated non-canonical junctions will be kept.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outFilterIntronMotifs",
              "position": 2
            },
            "sbg:category": "Output filtering",
            "label": "Motifs filtering"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outFilterIntronStrands",
                "symbols": [
                  "RemoveInconsistentStrands",
                  "None"
                ]
              }
            ],
            "sbg:toolDefaultValue": "RemoveInconsistentStrands",
            "id": "outFilterIntronStrands",
            "doc": "Remove alignments that have junctions with inconsistent strands. On by default.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outFilterIntronStrands",
              "position": 2
            },
            "sbg:category": "Output filtering",
            "label": "Filter intron strands"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "outFilterMatchNmin",
            "doc": "Alignment will be output only if the number of matched bases is higher than this value.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outFilterMatchNmin",
              "position": 2
            },
            "sbg:category": "Output filtering",
            "label": "Min matched bases"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.66",
            "id": "outFilterMatchNminOverLread",
            "doc": "'Minimum matched bases' normalized to read length (sum of mates lengths for paired-end reads).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outFilterMatchNminOverLread",
              "position": 2
            },
            "sbg:category": "Output filtering",
            "label": "Min matched bases normalized"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "outFilterMismatchNmax",
            "label": "Max number of mismatches",
            "sbg:category": "Output filtering",
            "doc": "Alignment will be output only if it has fewer mismatches than this value."
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.3",
            "id": "outFilterMismatchNoverLmax",
            "doc": "Alignment will be output only if its ratio of mismatches to *mapped* length is less than this value.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outFilterMismatchNoverLmax",
              "position": 2
            },
            "sbg:category": "Output filtering",
            "label": "Mismatches to *mapped* length"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "1",
            "id": "outFilterMismatchNoverReadLmax",
            "doc": "Alignment will be output only if its ratio of mismatches to *read* length is less than this value.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outFilterMismatchNoverReadLmax",
              "position": 2
            },
            "sbg:category": "Output filtering",
            "label": "Mismatches to *read* length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "outFilterMultimapNmax",
            "doc": "Read alignments will be output only if the read maps fewer than this value, otherwise no alignments will be output.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outFilterMultimapNmax",
              "position": 2
            },
            "sbg:category": "Output filtering",
            "label": "Max number of mappings"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "outFilterMultimapScoreRange",
            "label": "Multimapping score range",
            "sbg:category": "Output filtering",
            "doc": "The score range below the maximum score for multimapping alignments."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "outFilterScoreMin",
            "doc": "Alignment will be output only if its score is higher than this value.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outFilterScoreMin",
              "position": 2
            },
            "sbg:category": "Output filtering",
            "label": "Min score"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.66",
            "id": "outFilterScoreMinOverLread",
            "label": "Min score normalized",
            "sbg:category": "Output filtering",
            "doc": "'Minimum score' normalized to read length (sum of mates' lengths for paired-end reads)."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outFilterType",
                "symbols": [
                  "Normal",
                  "BySJout"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Normal",
            "id": "outFilterType",
            "doc": "Type of filtering. Normal: standard filtering using only current alignment; BySJout: keep only those reads that contain junctions that passed filtering into SJ.out.tab.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outFilterType",
              "position": 2
            },
            "sbg:category": "Output filtering",
            "label": "Filtering type"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outMultimapperOrder",
                "symbols": [
                  "Random",
                  "Old_2.4"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Old_2.4",
            "id": "outMultimapperOrder",
            "doc": "Random option outputs multiple alignments for each read in random order, and also also randomizes the choice of the primary alignment from the highest scoring alignments.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outMultimapperOrder",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Order of multimapping alignment"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "outQSconversionAdd",
            "doc": "Add this number to the quality score (e.g. to convert from Illumina to Sanger, use -31).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outQSconversionAdd",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Quality conversion"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outReadsUnmapped",
                "symbols": [
                  "None",
                  "Fastx"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "outReadsUnmapped",
            "doc": "Output of unmapped reads (besides SAM). None: no output; Fastx: output in separate fasta/fastq files, Unmapped.out.mate1/2.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outReadsUnmapped",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Output unmapped reads"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "outSAMattrIHstart",
            "doc": "Start value for the IH attribute. 0 may be required by some downstream software, such as Cufflinks or StringTie.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMattrIHstart",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "IH attribute start value"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "Standard",
            "id": "outSAMattributes",
            "doc": "Desired SAM attributes, in the order desired for the output SAM. Standard - NH HI AS nM; All - NH HI AS nM NM MD jM jI MC ch; None - no attributes. The combination used in RSEM is: NH HI AS NM MD. Variants overlapping alignments attributes available as well: vA - variant allele; vG - genomic coordinate of the variant overlapped by the read; vW - 0/1 - alignment does not pass / passes WASP filtering. Requires --waspOutputMode SAMtag. Unsupported: rB - alignment block read/genomic coordinates; vR - read coordinate of the variant.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMattributes",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "SAM attributes"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSAMfilter",
                "symbols": [
                  "KeepOnlyAddedReferences",
                  "None",
                  "KeepAllAddedReferences"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "outSAMfilter",
            "doc": "Filter the output into main SAM/BAM files.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMfilter",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Output filter"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "65535",
            "id": "outSAMflagAND",
            "doc": "Set specific bits of the SAM FLAG.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMflagAND",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "AND SAM flag"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "outSAMflagOR",
            "doc": "Set specific bits of the SAM FLAG.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMflagOR",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "OR SAM flag"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "-",
            "id": "outSAMheaderHD",
            "doc": "@HD (header) line of the SAM header.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMheaderHD",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "SAM header @HD"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "-",
            "id": "outSAMheaderPG",
            "doc": "Extra @PG (software) line of the SAM header (in addition to STAR).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMheaderPG",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "SAM header @PG"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "255",
            "id": "outSAMmapqUnique",
            "doc": "MAPQ value for unique mappers (0 to 255).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMmapqUnique",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "MAPQ value"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSAMmode",
                "symbols": [
                  "Full",
                  "NoQS",
                  "None"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Full",
            "id": "outSAMmode",
            "doc": "Mode of SAM output. Full: full SAM output; NoQS: full SAM but without quality scores.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMmode",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "SAM mode"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-1",
            "id": "outSAMmultNmax",
            "doc": "Max number of multiple alignments for a read that will be output to the SAM/BAM files.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMmultNmax",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Max number of multiple alignment"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSAMorder",
                "symbols": [
                  "Paired",
                  "PairedKeepInputOrder"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Paired",
            "id": "outSAMorder",
            "doc": "Type of sorting for the SAM output. Paired: one mate after the other for all paired alignments; PairedKeepInputOrder: one mate after the other for all paired alignments, the order is kept the same as in the input FASTQ files.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMorder",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Sorting in SAM"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSAMprimaryFlag",
                "symbols": [
                  "OneBestScore",
                  "AllBestScore"
                ]
              }
            ],
            "sbg:toolDefaultValue": "OneBestScore",
            "id": "outSAMprimaryFlag",
            "doc": "Which alignments are considered primary - all others will be marked with 0x100 bit in the FLAG. OneBestScore: only one alignment with the best score is primary; AllBestScore: all alignments with the best score are primary.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMprimaryFlag",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Primary alignments"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSAMreadID",
                "symbols": [
                  "Standard",
                  "Number"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Standard",
            "id": "outSAMreadID",
            "doc": "Read ID record type. Standard: first word (until space) from the FASTx read ID line, removing /1,/2 from the end; Number: read number (index) in the FASTx file.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMreadID",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Read ID"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSAMstrandField",
                "symbols": [
                  "None",
                  "intronMotif"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "outSAMstrandField",
            "doc": "Cufflinks-like strand field flag. None: not used; intronMotif: strand derived from the intron motif. Reads with inconsistent and/or non-canonical introns are filtered out.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMstrandField",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Strand field flag"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSAMtlen",
                "symbols": [
                  "1",
                  "2"
                ]
              }
            ],
            "sbg:toolDefaultValue": "1",
            "id": "outSAMtlen",
            "doc": "Calculation method for the TLEN field in the SAM/BAM files. 1 - leftmost base of the (+)strand mate to rightmost base of the (-)mate. (+)sign for the (+)strand mate; 2 - leftmost base of any mate to rightmost base of any mate. (+)sign for the mate with the leftmost base. This is different from 1 for overlapping mates with protruding ends.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMtlen",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Out SAM TLEN"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSAMtype",
                "symbols": [
                  "SAM",
                  "BAM"
                ]
              }
            ],
            "sbg:toolDefaultValue": "BAM",
            "id": "outSAMtype",
            "label": "Output format",
            "sbg:category": "Output",
            "doc": "Format of output alignments."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSAMunmapped",
                "symbols": [
                  "None",
                  "Within",
                  "Within KeepPairs"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "outSAMunmapped",
            "doc": "Output of unmapped reads in the SAM format. None: no output Within: output unmapped reads within the main SAM file (i.e. Aligned.out.sam).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSAMunmapped",
              "position": 2
            },
            "sbg:category": "Output",
            "label": "Write unmapped in SAM"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "3 1 1 1",
            "id": "outSJfilterCountTotalMin",
            "doc": "Minimum total (multi-mapping+unique) read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--outSJfilterCountTotalMin",
              "position": 2
            },
            "sbg:category": "Output filtering: splice junctions",
            "label": "Min total count"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "3 1 1 1",
            "id": "outSJfilterCountUniqueMin",
            "doc": "Minimum uniquely mapping read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--outSJfilterCountUniqueMin",
              "position": 2
            },
            "sbg:category": "Output filtering: splice junctions",
            "label": "Min unique count"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "10 0 5 10",
            "id": "outSJfilterDistToOtherSJmin",
            "doc": "Minimum allowed distance to other junctions' donor/acceptor for each of the motifs (int >= 0). Does not apply to annotated junctions.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--outSJfilterDistToOtherSJmin",
              "position": 2
            },
            "sbg:category": "Output filtering: splice junctions",
            "label": "Min distance to other donor/acceptor"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "50000 100000 200000",
            "id": "outSJfilterIntronMaxVsReadN",
            "doc": "Maximum gap allowed for junctions supported by 1,2,3...N reads (int >= 0) i.e. by default junctions supported by 1 read can have gaps <=50000b, by 2 reads: <=100000b, by 3 reads: <=200000. By 4 or more reads: any gap <=alignIntronMax. Does not apply to annotated junctions.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--outSJfilterIntronMaxVsReadN",
              "position": 2
            },
            "sbg:category": "Output filtering: splice junctions",
            "label": "Max gap allowed"
          },
          {
            "type": "int[]?",
            "sbg:toolDefaultValue": "30 12 12 12",
            "id": "outSJfilterOverhangMin",
            "doc": "Minimum overhang length for splice junctions on both sides for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Does not apply to annotated junctions.",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--outSJfilterOverhangMin",
              "position": 2
            },
            "sbg:category": "Output filtering: splice junctions",
            "label": "Min overhang SJ"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSJfilterReads",
                "symbols": [
                  "All",
                  "Unique"
                ]
              }
            ],
            "sbg:toolDefaultValue": "All",
            "id": "outSJfilterReads",
            "doc": "Which reads to consider for collapsed splice junctions output. All: all reads, unique- and multi-mappers; Unique: uniquely mapping reads only.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outSJfilterReads",
              "position": 2
            },
            "sbg:category": "Output filtering: splice junctions",
            "label": "Collapsed junctions reads"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outSortingType",
                "symbols": [
                  "Unsorted",
                  "SortedByCoordinate"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Unsorted",
            "id": "outSortingType",
            "label": "Output sorting type",
            "sbg:category": "Output",
            "doc": "Type of output sorting."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outWigNorm",
                "symbols": [
                  "None",
                  "RPM"
                ]
              }
            ],
            "sbg:toolDefaultValue": "RPM",
            "id": "outWigNorm",
            "label": "Output wiggle normalization",
            "sbg:category": "Output Wiggle",
            "doc": "Type of normalization for the output wiggle signal. RPM - reads per million of mapped reads; None - no normalization, \"raw\" counts."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "-",
            "id": "outWigReferencePrefix",
            "label": "Output wiggle reference prefix",
            "sbg:category": "Output Wiggle",
            "doc": "Prefix matching reference names to include in the output wiggle file, e.g. \"chr\". Default is \"-\", to include all references."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outWigStrand",
                "symbols": [
                  "Stranded",
                  "Unstranded"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Stranded",
            "id": "outWigStrand",
            "label": "Output wiggle strand",
            "sbg:category": "Output Wiggle",
            "doc": "Strandedness of wiggle/bedGraph output. Stranded - separate strands, str1 and str2; Unstranded - collapsed strands."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "outWigType",
                "symbols": [
                  "bedGraph",
                  "bedGraph read1_5p",
                  "bedGraph read2",
                  "wiggle",
                  "wiggle read1_5p",
                  "wiggle read2"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "outWigType",
            "doc": "Type of wiggle signal output. Options are bedGraph and wiggle, with the second word indicating whether to include signal only from 5' of the 1st read (useful for CAGE/RAMPAGE etc) or only from the 2nd read, respectively.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--outWigType",
              "position": 2
            },
            "sbg:category": "Output Wiggle",
            "label": "Output wiggle type"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "0.1",
            "id": "peOverlapMMp",
            "doc": "Maximum proportion of mismatched bases in the overlap area (value must be between 0 and 1).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--peOverlapMMp",
              "position": 2
            },
            "sbg:category": "Paired-End reads",
            "label": "Paired end overlap max mismatches proportion"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "peOverlapNbasesMin",
            "doc": "Minimum number of overlap bases to trigger mates merging and realignment.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--peOverlapNbasesMin",
              "position": 2
            },
            "sbg:category": "Paired-End reads",
            "label": "Paired end overlap min bases number"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quantMode",
                "symbols": [
                  "TranscriptomeSAM",
                  "GeneCounts",
                  "TranscriptomeSAM GeneCounts"
                ]
              }
            ],
            "sbg:toolDefaultValue": "-",
            "id": "quantMode",
            "doc": "Types of quantification requested. 'TranscriptomeSAM' option outputs SAM/BAM alignments to transcriptome into a separate file. With 'GeneCounts' option, STAR will count number of reads per gene while mapping.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--quantMode",
              "position": 2
            },
            "sbg:category": "Quantification of Annotations",
            "label": "Quantification mode"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quantTranscriptomeBan",
                "symbols": [
                  "IndelSoftclipSingleend",
                  "Singleend"
                ]
              }
            ],
            "sbg:toolDefaultValue": "IndelSoftclipSingleend",
            "id": "quantTranscriptomeBan",
            "doc": "Prohibit various alignment type. IndelSoftclipSingleend: prohibit indels, soft clipping and single-end alignments - compatible with RSEM; Singleend: prohibit single-end alignments.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--quantTranscriptomeBan",
              "position": 2
            },
            "sbg:category": "Quantification of Annotations",
            "label": "Prohibit alignment type"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "100",
            "doc": "The length of the reads.",
            "label": "Read length",
            "id": "read_length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-1",
            "id": "readMapNumber",
            "doc": "Number of reads to map from the beginning of the file.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--readMapNumber",
              "position": 2
            },
            "sbg:category": "Read parameters",
            "label": "Reads to map"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "readMatesLengthsIn",
                "symbols": [
                  "NotEqual",
                  "Equal"
                ]
              }
            ],
            "sbg:toolDefaultValue": "NotEqual",
            "id": "readMatesLengthsIn",
            "doc": "Equal/Not equal - lengths of names, sequences, qualities for both mates are the same/not the same. \"Not equal\" is safe in all situations.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--readMatesLengthsIn",
              "position": 2
            },
            "sbg:category": "Read parameters",
            "label": "Reads lengths"
          },
          {
            "type": "File[]",
            "id": "in_reads",
            "sbg:fileTypes": "FASTA, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2, SAM, BAM",
            "inputBinding": {
              "valueFrom": "${\n    function get_meta_map(m, file, meta) {\n        if (meta in file.metadata) {\n            return m[file.metadata[meta]];\n        } else {\n            return m['Undefined'];\n        }\n    }\n\n    function create_new_map(map, file, meta) {\n        if (meta in file.metadata) {\n            map[file.metadata[meta]] = {}\n            return map[file.metadata[meta]];\n        } else {\n            map['Undefined'] = {}\n            return map['Undefined'];\n        }\n    }\n\n    var arr = [].concat(inputs.in_reads);\n    var ext = arr[0].path.split('.').pop().toLowerCase();\n\n    // if bam input\n    if (ext == 'bam' || ext == 'sam') {\n        return \"--readFilesType SAM $str --readFilesIn \" + arr[0].path\n    }\n\n    var map = {};\n\n    if (arr.length == 1) {\n        return \"--readFilesIn \" + arr[0].path;\n    }\n\n    for (i in arr) {\n    \n        var sm_map = get_meta_map(map, arr[i], 'sample_id');\n        if (!sm_map) sm_map = create_new_map(map, arr[i], 'sample_id')\n\n        var lb_map = get_meta_map(sm_map, arr[i], 'library_id');\n        if (!lb_map) lb_map = create_new_map(sm_map, arr[i], 'library_id')\n        var pu_map = get_meta_map(lb_map, arr[i], 'platform_unit_id');\n        if (!pu_map) pu_map = create_new_map(lb_map, arr[i], 'platform_unit_id')\n\n        if ('file_segment_number' in arr[i].metadata) {\n            if (pu_map[arr[i].metadata['file_segment_number']]) {\n                var a = pu_map[arr[i].metadata['file_segment_number']];\n                var ar = [].concat(a);\n                ar = ar.concat(arr[i])\n                pu_map[arr[i].metadata['file_segment_number']] = ar\n            } else {\n                pu_map[arr[i].metadata['file_segment_number']] = [].concat(arr[i])\n            }\n        } else {\n            if (pu_map['Undefined']) {\n                var a = pu_map['Undefined'];\n                var ar = [].concat(a);\n                ar = ar.concat(arr[i])\n                pu_map['Undefined'] = ar\n            } else {\n                pu_map['Undefined'] = [].concat(arr[i])\n            }\n        }\n    }\n    var tuple_list = [];\n    var sm;\n    var lb;\n    var pu;\n    var fsm;\n    for (sm in map)\n        for (lb in map[sm])\n            for (pu in map[sm][lb]) {\n                var list = [];\n                for (fsm in map[sm][lb][pu]) {\n                    list = map[sm][lb][pu][fsm]\n                    tuple_list.push(list)\n                }\n            }\n    //return tuple_list[0][0]\n\n    var pe_1 = [];\n    var pe_2 = [];\n    var se = [];\n    if (tuple_list[0].length == 1) {\n        for (var i = 0; i < tuple_list.length; i++) {\n            se = se.concat(tuple_list[i][0].path)\n        }\n    }\n    for (var i = 0; i < tuple_list.length; i++) {\n        for (var j = 0; j < tuple_list[i].length; j++) {\n            if (tuple_list[i][j].metadata.paired_end == 1) {\n                pe_1 = pe_1.concat(tuple_list[i][j].path)\n            } else if (tuple_list[i][j].metadata.paired_end == 2) {\n                pe_2 = pe_2.concat(tuple_list[i][j].path)\n            }\n        }\n    }\n    \n    var cmd;\n    var tmp;\n    if (pe_2.length == 0) {\n        cmd = \"\"\n        if (se.length > 0) {\n            tmp = se\n        } else if (pe_1.length > 0) {\n            tmp = pe_1\n        }\n        for (var i = 0; i < tmp.length; i++) {\n            cmd += tmp[i] + \" \"\n        }\n        return \"--readFilesIn \" + cmd\n    } else if (pe_1.length > 0) {\n        var cmd1 = [];\n        var cmd2 = [];\n        for (i = 0; i < pe_1.length; i++) {\n            cmd1.push(pe_1[i])\n            cmd2.push(pe_2[i])\n        }\n        return \"--readFilesIn \" + cmd1.join(',') + \" \" + cmd2.join(',');\n    } else {\n        return \"\";\n    }\n\n}",
              "shellQuote": false,
              "itemSeparator": " ",
              "position": 12
            },
            "label": "Read sequence",
            "sbg:category": "Basic",
            "doc": "Read files, either in FASTQ or SAM/BAM formats."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_library_id",
            "label": "Library ID",
            "sbg:category": "Read group",
            "doc": "Specify the library ID for RG line."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_mfl",
            "label": "Median fragment length",
            "sbg:category": "Read group",
            "doc": "Specify the median fragment length for RG line."
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "rg_platform",
                "symbols": [
                  "LS 454",
                  "Helicos",
                  "Illumina",
                  "ABI SOLiD",
                  "Ion Torrent PGM",
                  "PacBio"
                ]
              }
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_platform",
            "label": "Platform",
            "sbg:category": "Read group",
            "doc": "Specify the version of the technology that was used for sequencing or assaying."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_platform_unit_id",
            "label": "Platform unit ID",
            "sbg:category": "Read group",
            "doc": "Specify the platform unit ID for RG line."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_sample_id",
            "label": "Sample ID",
            "sbg:category": "Read group",
            "doc": "Specify the sample ID for RG line."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "Inferred from metadata",
            "id": "rg_seq_center",
            "label": "Sequencing center",
            "sbg:category": "Read group",
            "doc": "Specify the sequencing center for RG line."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "32",
            "id": "runThreadN",
            "label": "Number of threads",
            "sbg:category": "Run parameters",
            "doc": "Number of threads to use."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-2",
            "id": "scoreDelBase",
            "doc": "Deletion extension penalty per base (in addition to --scoreDelOpen).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreDelBase",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "Deletion extension penalty"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-2",
            "id": "scoreDelOpen",
            "doc": "Deletion open penalty.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreDelOpen",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "Deletion open penalty"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "scoreGap",
            "doc": "Gap open penalty.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreGap",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "Gap open penalty"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-8",
            "id": "scoreGapATAC",
            "doc": "AT/AC and GT/AT gap open penalty (in addition to --scoreGap).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreGapATAC",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "AT/AC and GT/AT gap open"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-4",
            "id": "scoreGapGCAG",
            "doc": "GC/AG and CT/GC gap open penalty (in addition to --scoreGap).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreGapGCAG",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "GC/AG and CT/GC gap open"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-8",
            "id": "scoreGapNoncan",
            "doc": "Non-canonical gap open penalty (in addition to --scoreGap).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreGapNoncan",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "Non-canonical gap open"
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "-0.25",
            "id": "scoreGenomicLengthLog2scale",
            "doc": "Extra score logarithmically scaled with genomic length of the alignment: <int>*log2(genomicLength).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreGenomicLengthLog2scale",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "Log scaled score"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-2",
            "id": "scoreInsBase",
            "doc": "Insertion extension penalty per base (in addition to --scoreInsOpen).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreInsBase",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "Insertion extension penalty"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-2",
            "id": "scoreInsOpen",
            "doc": "Insertion open penalty.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreInsOpen",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "Insertion Open Penalty"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "scoreStitchSJshift",
            "doc": "Maximum score reduction while searching for SJ boundaries in the stitching step.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--scoreStitchSJshift",
              "position": 2
            },
            "sbg:category": "Scoring",
            "label": "Max score reduction"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10000",
            "id": "seedMultimapNmax",
            "doc": "Only pieces that map fewer than this value are utilized in the stitching procedure (int>=0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--seedMultimapNmax",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Filter pieces for stitching"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "10",
            "id": "seedNoneLociPerWindow",
            "doc": "Max number of one seed loci per window (int>=0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--seedNoneLociPerWindow",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Max one-seed loci per window"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1000",
            "id": "seedPerReadNmax",
            "label": "Max seeds per read",
            "sbg:category": "Alignments and Seeding",
            "doc": "Max number of seeds per read (int>=0)."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "50",
            "id": "seedPerWindowNmax",
            "label": "Max seeds per window",
            "sbg:category": "Alignments and Seeding",
            "doc": "Max number of seeds per window (int>=0)."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "0",
            "id": "seedSearchLmax",
            "label": "Max seed length",
            "sbg:category": "Alignments and Seeding",
            "doc": "Defines the maximum length of the seeds, if =0 max seed length is infinite (int>=0)."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "50",
            "id": "seedSearchStartLmax",
            "label": "Search start point",
            "sbg:category": "Alignments and Seeding",
            "doc": "Defines the search start point through the read - the read is split into pieces no longer than this value (int>0)."
          },
          {
            "type": "float?",
            "sbg:toolDefaultValue": "1.0",
            "id": "seedSearchStartLmaxOverLread",
            "doc": "SeedSearchStartLmax normalized to read length (sum of mates' lengths for paired-end reads).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--seedSearchStartLmaxOverLread",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Search start point normalized"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "12",
            "id": "seedSplitMin",
            "doc": "Minimum length of the seed sequences split by Ns or mate gap. Changing this parameters to a value lower than the default (12), allows mapping of mates shorter than 12 base pairs.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--seedSplitMin",
              "position": 2
            },
            "sbg:category": "Alignments and Seeding",
            "label": "Seed split min"
          },
          {
            "type": "File[]?",
            "id": "in_intervals",
            "sbg:fileTypes": "TXT, SJDB, TAB",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--sjdbFileChrStartEnd",
              "position": 2
            },
            "label": "List of annotated junctions",
            "sbg:category": "Basic",
            "doc": "List of splice junction coordinates in a tab-separated file."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "-",
            "id": "sjdbGTFchrPrefix",
            "doc": "Prefix for chromosome names in a GTF file (e.g. 'chr' for using ENSEMBL annotations with UCSC genomes).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbGTFchrPrefix",
              "position": 2
            },
            "sbg:category": "Splice junctions database",
            "label": "Chromosome names"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "exon",
            "id": "sjdbGTFfeatureExon",
            "doc": "Feature type in GTF file to be used as exons for building transcripts.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbGTFfeatureExon",
              "position": 2
            },
            "sbg:category": "Splice junctions database",
            "label": "Set exons feature"
          },
          {
            "type": "File?",
            "id": "in_gene_annotation",
            "sbg:fileTypes": "GTF, GFF, GFF2, GFF3",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--sjdbGTFfile",
              "position": 2
            },
            "label": "Gene annotation file",
            "sbg:category": "Basic",
            "doc": "Gene model annotations and/or known transcripts. No need to include this input, except in case of using \"on the fly\" annotations. If you are providing a GFF3 file and wish to use STAR results for further downstream analysis, a good idea would be to set the \"Exons' parents name\" (id: sjdbGTFtagExonParentTranscript) option to \"Parent\"."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "gene_id",
            "id": "sjdbGTFtagExonParentGene",
            "doc": "Tag name to be used as exons gene-parents.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbGTFtagExonParentGene",
              "position": 2
            },
            "sbg:category": "Splice junctions database",
            "label": "Gene name"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "transcript_id",
            "id": "sjdbGTFtagExonParentTranscript",
            "doc": "Tag name to be used as exons transcript-parents.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbGTFtagExonParentTranscript",
              "position": 2
            },
            "sbg:category": "Splice junctions database",
            "label": "Exons' parents name"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "sjdbInsertSave",
                "symbols": [
                  "Basic",
                  "All",
                  "None"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "sjdbInsertSave",
            "doc": "Which files to save when sjdb junctions are inserted on the fly at the mapping step. None: not saving files at all; Basic: only small junction/transcript files; All: all files including big Genome, SA and SAindex. These files are output as archive.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbInsertSave",
              "position": 2
            },
            "sbg:category": "Splice junctions database",
            "label": "Save junction files"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "100",
            "id": "sjdbOverhang",
            "label": "\"Overhang\" length",
            "sbg:category": "Splice junctions database",
            "doc": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "sjdbScore",
            "doc": "Extra alignment score for alignments that cross database junctions.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbScore",
              "position": 2
            },
            "sbg:category": "Splice junctions database",
            "label": "Extra alignment score"
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "False",
            "id": "sortUnmappedReads",
            "label": "Sort unmapped reads",
            "sbg:category": "Output",
            "doc": "Legacy - in old versions of STAR, unmapped reads were sometime not sorted properly by read ID. Specifying this option introduced some Seven Bridges code to properly sort unmapped reads. As of version 2.6.1d, this option is no longer necessary."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "False",
            "id": "starlong",
            "label": "STARlong",
            "sbg:category": "General options",
            "doc": "Run the STARlong algorithm instead of the standard STAR. STARlong version uses a more efficient seed stitching algorithm for long reads (>200b), and also uses different array allocations. Selecting this boolean option will also automatically change some of the parameters of STAR to comply with long read alignment best practices."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-1",
            "id": "twopass1readsN",
            "doc": "Number of reads to process for the 1st step. 0: 1-step only, no 2nd pass; use very large number (or default -1) to map all reads in the first step (int>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--twopass1readsN",
              "position": 2
            },
            "sbg:category": "2-pass mapping",
            "label": "Reads to process in 1st step"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "twopassMode",
                "symbols": [
                  "None",
                  "Basic"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "twopassMode",
            "doc": "2-pass mapping mode. None: 1-pass mapping; Basic: basic 2-pass mapping, with all 1st pass junctions inserted into the genome indices on the fly.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--twopassMode",
              "position": 2
            },
            "sbg:category": "2-pass mapping",
            "label": "Two-pass mode"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "\"Unmapped.out\"",
            "id": "unmappedOutputName",
            "label": "Unmapped output file names",
            "sbg:category": "Output",
            "doc": "Names of the unmapped output files."
          },
          {
            "type": "File?",
            "id": "in_variants",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "label": "Variation VCF file",
            "sbg:category": "Variation parameters",
            "doc": "VCF file that contains variation data."
          },
          {
            "type": "boolean?",
            "sbg:toolDefaultValue": "False",
            "id": "verbose_indexing",
            "label": "Verbose indexing",
            "sbg:category": "Output",
            "doc": "If, for some reason, STAR produces an empty BAM file, the BAM index step will fail. Sometimes though, empty BAM files might be expected (if some contamination reference is used, for example), so in these cases, turning this option on will prevent samtools index from failing (en emtpy BAI file will also be created). )"
          },
          {
            "type": [
              "null",
              {
                "type": "enum",
                "name": "waspOutputMode",
                "symbols": [
                  "None",
                  "SAMtag"
                ]
              }
            ],
            "sbg:toolDefaultValue": "None",
            "id": "waspOutputMode",
            "doc": "WASP allele-specific output type. This is re-implemenation of the original WASP mappability filtering by Bryce van de Geijn, Graham McVicker, Yoav Gilad & Jonathan K Pritchard.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--waspOutputMode",
              "position": 2
            },
            "sbg:category": "WASP parameters",
            "label": "WASP output mode"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "9",
            "id": "winAnchorDistNbins",
            "doc": "Max number of bins between two anchors that allows aggregation of anchors into one window (int>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--winAnchorDistNbins",
              "position": 2
            },
            "sbg:category": "Windows, Anchors, Binning",
            "label": "Max bins between anchors"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "50",
            "id": "winAnchorMultimapNmax",
            "label": "Max loci anchors",
            "sbg:category": "Windows, Anchors, Binning",
            "doc": "Max number of loci anchors are allowed to map to (int>0)."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "16",
            "id": "winBinNbits",
            "doc": "=log2(winBin), where winBin is the size of the bin for the windows/clustering, each window will occupy an integer number of bins (int>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--winBinNbits",
              "position": 2
            },
            "sbg:category": "Windows, Anchors, Binning",
            "label": "Bin size"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "4",
            "id": "winFlankNbins",
            "doc": "=log2(winFlank), where win Flank is the size of the left and right flanking regions for each window (int>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--winFlankNbins",
              "position": 2
            },
            "sbg:category": "Windows, Anchors, Binning",
            "label": "Flanking regions size"
          }
        ],
        "cwlVersion": "v1.0",
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "${\n    if (inputs.in_reads) {\n\n        var list = [].concat(inputs.in_reads);\n        var ext = list[0].path.split('.').pop().toLowerCase();\n\n        if (ext == 'bam' || ext == 'sam') {\n            var bam_file = list[0].path;\n            var cmd_line = \"str='SE' && count=`samtools view -h \" + bam_file + \" | head -n 500000 | samtools view -c -f 0x1 -`\";\n            var cmd_line = cmd_line + \" && if [ $count != 0 ]; then str='PE'; fi;\";\n            return cmd_line\n        } else {\n            return \"\"\n        }\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "${\n    var cpus = inputs.runThreadN ? inputs.runThreadN : 8;\n\n    var STAR = inputs.starlong ? \"STARlong\" : \"STAR\";\n    var index_ext = inputs.in_index.path.split('.').pop();\n    \n    if(index_ext.toLowerCase() == 'gz'){\n        var prefix = ' -xvzf ';\n    }\n    else if(index_ext.toLowerCase() == 'tar'){\n        var prefix = ' -xvf ';\n    }\n    \n\n    return \"tar\" + prefix + inputs.in_index.path + \" && \" + STAR + \" --runThreadN \" + cpus;\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 1
          },
          {
            "valueFrom": "${\n    var arr = [].concat(inputs.in_reads);\n    var ext = arr[0].path.split('.').pop().toLowerCase();\n    \n    if (ext == \"gz\") {\n        return \"--readFilesCommand gunzip -c\";\n    } else if (ext == \"bz2\") {\n        return \"--readFilesCommand bzcat\";\n    } else if (ext == 'bam') {\n        return \"--readFilesCommand samtools view -h\";\n    } else {\n        return \"\"\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "${\n    // if genomic coordinates are provided\n    var out_ext;\n    if (inputs.in_intervals) {\n        var out_ext = \".twopass-multiple.\";\n    } \n    else if (inputs.twopassMode == 'Basic') {\n        var out_ext = \".twopass-basic.\";\n    }\n    else {\n        var out_ext = \".\";\n    }\n    \n    var intermediate;\n    var source;\n    var destination;\n    // if output name option is set\n    if(inputs.out_prefix){\n        intermediate = inputs.out_prefix + out_ext + \"_STARgenome\"\n        source = \"./\".concat(intermediate)\n        destination = intermediate.concat(\".tar\")\n    } else {\n        var in_prefix;\n        var in_num = [].concat(inputs.in_reads).length;\n        // create output file name if there is one input file\n        if(in_num == 1){\n            var in_reads = [].concat(inputs.in_reads)[0];\n            // check if the sample_id metadata value is defined for the input file\n            if(in_reads.metadata && in_reads.metadata.sample_id){\n                in_prefix = in_reads.metadata.sample_id\n            // if sample_id is not defined\n            } else {\n                in_prefix = [].concat(inputs.in_reads)[0].nameroot\n            }\n            intermediate = in_prefix + out_ext + \"_STARgenome\"\n            source = \"./\".concat(intermediate)\n            destination = intermediate.concat(\".tar\")\n        }\n        // create output file name if there are more than one input files\n        else if(in_num > 1){\n            var in_reads = [].concat(inputs.in_reads);\n            var in_sample_ids = [];\n            var in_read_names = [];\n            for (var i = 0; i < in_reads.length; i++) {\n                // check if the sample_id metadata value is defined for the input file\n                if(in_reads[i].metadata && in_reads[i].metadata.sample_id){\n                    in_sample_ids.push(in_reads[i].metadata.sample_id)\n                } else {\n                    in_sample_ids.push('')\n                }\n                in_read_names.push(in_reads[i].nameroot)\n            }\n            if(in_sample_ids.length != 0){\n                in_prefix = in_sample_ids.sort()[0]\n            // if sample_id is not defined\n            } else {\n                in_prefix = in_read_names.sort()[0]\n            }\n            intermediate = in_prefix + '.' + in_num + out_ext + \"_STARgenome\"\n            source = \"./\".concat(intermediate)\n            destination = intermediate.concat(\".tar\")\n        }\n    }\n    if ((inputs.in_gene_annotation || inputs.in_intervals) && inputs.sjdbInsertSave && inputs.sjdbInsertSave != \"None\") {\n        return \"&& tar -vcf \".concat(destination, \" \", source);\n    } else {\n        return \"\";\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 102
          },
          {
            "valueFrom": "${\n    // if output name option is set\n    if(inputs.out_prefix){\n        return inputs.out_prefix + \".\";\n    } else {\n        // if genomic coordinates are provided\n        var out_ext;\n        if (inputs.in_intervals) {\n            out_ext = \".twopass-multiple.\";\n        } \n        else if (inputs.twopassMode == 'Basic') {\n            out_ext = \".twopass-basic.\";\n        }\n        else {\n            out_ext = \".\";\n        }\n        var in_prefix;\n        var in_num = [].concat(inputs.in_reads).length;\n        // create output file name if there is one input file\n        if(in_num == 1){\n            var in_reads = [].concat(inputs.in_reads)[0];\n            // check if the sample_id metadata value is defined for the input file\n            if(in_reads.metadata && in_reads.metadata.sample_id){\n                in_prefix = in_reads.metadata.sample_id\n            // if sample_id is not defined\n            } else {\n                in_prefix = [].concat(inputs.in_reads)[0].nameroot\n            }\n            return in_prefix + out_ext;\n        }\n        // create output file name if there are more than one input files\n        else if(in_num > 1){\n            var in_reads = [].concat(inputs.in_reads);\n            var in_sample_ids = [];\n            var in_read_names = [];\n            for (var i = 0; i < in_reads.length; i++) {\n                // check if the sample_id metadata value is defined for the input file\n                if(in_reads[i].metadata && in_reads[i].metadata.sample_id){\n                    in_sample_ids.push(in_reads[i].metadata.sample_id)\n                }\n                in_read_names.push(in_reads[i].nameroot)\n            }\n            if(in_sample_ids.length != 0){\n                in_prefix = in_sample_ids.sort()[0]\n            // if sample_id is not defined\n            } else {\n                in_prefix = in_read_names.sort()[0]\n            }\n            return in_prefix + '.' + in_num + out_ext;\n        }\n    }\n}",
            "shellQuote": false,
            "prefix": "--outFileNamePrefix",
            "position": 2
          },
          {
            "valueFrom": "${\n    // if genomic coordinates are provided\n    var out_ext;\n    if (inputs.in_intervals) {\n        out_ext = \".twopass-multiple.\"\n    } \n    else if (inputs.twopassMode == 'Basic') {\n        out_ext = \".twopass-basic.\"\n    }\n    else {\n        out_ext = \".\" \n    }\n    \n    // if output name option is set\n    if(inputs.out_prefix){\n        var in_prefix = inputs.out_prefix + out_ext;\n    }\n    else {\n        var in_prefix;\n        var in_num = [].concat(inputs.in_reads).length;\n        // create output file name if there is one input file\n        if(in_num == 1){\n            var in_reads = [].concat(inputs.in_reads)[0]\n            // check if the sample_id metadata value is defined for the input file\n            if(in_reads.metadata && in_reads.metadata.sample_id){\n                in_prefix = in_reads.metadata.sample_id\n            // if sample_id is not defined\n            } else {\n                in_prefix = [].concat(inputs.in_reads)[0].nameroot + out_ext\n            }\n        }\n        // create output file name if there are more than one input files\n        else if(in_num > 1){\n            var in_reads = [].concat(inputs.in_reads);\n            var in_sample_ids = [];\n            var in_read_names = [];\n            for (var i = 0; i < in_reads.length; i++) {\n                // check if the sample_id metadata value is defined for the input file\n                if(in_reads[i].metadata && in_reads[i].metadata.sample_id){\n                    in_sample_ids.push(in_reads[i].metadata.sample_id)\n                } else {\n                    in_sample_ids.push('')\n                }\n                in_read_names.push(in_reads[i].nameroot)\n            }\n            if(in_sample_ids.length != 0){\n                in_prefix = in_sample_ids.sort()[0] + '.' + in_num + out_ext\n            // if sample_id is not defined\n            } else {\n                in_prefix = in_read_names.sort()[0] + '.' + in_num + out_ext\n            }\n        }\n    }\n    var mate1 = in_prefix.concat(\"Unmapped.out.mate1\");\n    var mate2 = in_prefix.concat(\"Unmapped.out.mate2\");\n    var arr = [].concat(inputs.in_reads);\n    var x = arr[0].path.split('/').pop();\n    var y = x.toLowerCase();\n\n    if (inputs.unmappedOutputName) {\n        var output_name = inputs.unmappedOutputName + \".\";\n    } else {\n        var output_name = \"Unmapped.out.\";\n    }\n\n    var mate1_1 = in_prefix.concat(output_name + \"mate1\");\n    var mate2_1 = in_prefix.concat(output_name + \"mate2\");\n\n\n    if (y.endsWith('fastq') || y.endsWith('fq') || y.endsWith('fastq.gz') || y.endsWith('fastq.bz2') || y.endsWith('fq.gz') || y.endsWith('fq.bz2') || y.endsWith('bam') || y.endsWith('sam')) {\n        var mate1fq = mate1_1.concat(\".fastq\");\n        var mate2fq = mate2_1.concat(\".fastq\");\n    } else if (y.endsWith('fasta') || y.endsWith('fa') || y.endsWith('fasta.gz') || y.endsWith('fasta.bz2') || y.endsWith('fa.gz') || y.endsWith('fa.bz2')) {\n        var mate1fq = mate1_1.concat(\".fasta\");\n        var mate2fq = mate2_1.concat(\".fasta\");\n    }\n\n\n    if (inputs.sortUnmappedReads) {\n\n        var cmd = \"\";\n        var sort_cmd = \" | sed 's/\\\\t.*//' | paste - - - - | sort -k1,1 -S 10G | tr '\\\\t' '\\\\n' > \";\n        if (inputs.outReadsUnmapped == \"Fastx\" && arr.length > 1) {\n            cmd = cmd.concat(\" && cat \", mate2, sort_cmd, mate2fq, \" && rm \", mate2)\n        }\n        else if (inputs.outReadsUnmapped == \"Fastx\") {\n            cmd = cmd.concat(\" && cat \", mate1, sort_cmd, mate1fq, \" && rm \", mate1)\n        }\n        return cmd;\n\n    } else {\n\n        if (inputs.outReadsUnmapped == \"Fastx\" && arr.length > 1) {\n            return \"&& mv \".concat(mate1, \" \", mate1fq, \" && mv \", mate2, \" \", mate2fq);\n        } else if (inputs.outReadsUnmapped == \"Fastx\" && arr.length == 1) {\n            return \"&& mv \".concat(mate1, \" \", mate1fq);\n        } else {\n            return \"\";\n        }\n\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 103
          },
          {
            "valueFrom": "${ // --genomeDir               \n    return inputs.genomeDirName ? inputs.genomeDirName : \"genomeDir\";\n}",
            "shellQuote": false,
            "prefix": "--genomeDir",
            "position": 2
          },
          {
            "valueFrom": "${//--limitBAMsortRAM\n  var memory = 46080;\n  if(inputs.mem_per_job){\n  \t memory = inputs.mem_per_job\n  }\n\n  return memory * 1000000;\n}\n",
            "shellQuote": false,
            "prefix": "--limitBAMsortRAM",
            "position": 2
          },
          {
            "valueFrom": "${// --outSAMtype SAM\n    var SAM_type = inputs.outSAMtype;\n    var SORT_type = inputs.outSortingType;\n    if (SAM_type && SORT_type) {\n        if (SAM_type == \"SAM\") {\n            return \"--outSAMtype SAM\";\n        } else {\n            return \"--outSAMtype \".concat(SAM_type, \" \", SORT_type);\n        }\n    } else if (SAM_type && SORT_type == null) {\n        if (SAM_type == \"SAM\") {\n            return \"--outSAMtype SAM\";\n        } else {\n            return \"--outSAMtype \".concat(SAM_type, \" Unsorted\");\n        }\n    } else {\n        if (SORT_type) {\n            return \"--outSAMtype \".concat(\"BAM\", \" \", SORT_type);\n        } else {\n            return \"--outSAMtype \".concat(\"BAM\", \" Unsorted\");\n        }\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 2
          },
          {
            "valueFrom": "${// --alignTranscriptsPerReadNmax\n    if (inputs.alignTranscriptsPerReadNmax) {\n        return inputs.alignTranscriptsPerReadNmax;\n    } else if (inputs.starlong) {\n        return 100000;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--alignTranscriptsPerReadNmax",
            "position": 2
          },
          {
            "valueFrom": "${// --alignTranscriptsPerWindowNmax\n    if (inputs.alignTranscriptsPerWindowNmax) {\n        return inputs.alignTranscriptsPerWindowNmax;\n    } else if (inputs.starlong) {\n        return 10000;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--alignTranscriptsPerWindowNmax",
            "position": 2
          },
          {
            "valueFrom": "${// --bamRemoveDuplicatesMate2basesN\n    var x = inputs.in_reads;\n    if (x.length == 2 && inputs.bamRemoveDuplicatesMate2basesN && inputs.bamRemoveDuplicatesType) {\n        return inputs.bamRemoveDuplicatesMate2basesN;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--bamRemoveDuplicatesMate2basesN",
            "position": 2
          },
          {
            "valueFrom": "${// --bamRemoveDuplicatesType\n    var x = inputs.in_reads;\n    if (x.length == 2 && inputs.bamRemoveDuplicatesType) {\n        return inputs.bamRemoveDuplicatesType;\n    } else {\n        return null;\n    }\n\n}",
            "shellQuote": false,
            "prefix": "--bamRemoveDuplicatesType",
            "position": 2
          },
          {
            "valueFrom": "${// --outFilterMismatchNmax\n    if (inputs.outFilterMismatchNmax) {\n        return inputs.outFilterMismatchNmax;\n    } else if (inputs.starlong) {\n        return 1000;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--outFilterMismatchNmax",
            "position": 2
          },
          {
            "valueFrom": "${// --outFilterMultimapScoreRange\n    if (inputs.outFilterMultimapScoreRange) {\n        return inputs.outFilterMultimapScoreRange;\n    } else if (inputs.starlong) {\n        return 20;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--outFilterMultimapScoreRange",
            "position": 2
          },
          {
            "valueFrom": "${// --outFilterScoreMinOverLread\n    if (inputs.outFilterScoreMinOverLread) {\n        return inputs.outFilterScoreMinOverLread;\n    } else if (inputs.starlong) {\n        return \"0\";\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--outFilterScoreMinOverLread",
            "position": 2
          },
          {
            "valueFrom": "${// --outWigNorm\n    if (inputs.outWigType && inputs.outWigNorm) {\n        return inputs.outWigNorm;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--outWigNorm",
            "position": 2
          },
          {
            "valueFrom": "${// --outWigReferencePrefix\n    if (inputs.outWigType && inputs.outWigReferencePrefix) {\n        return inputs.outWigReferencePrefix;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--outWigReferencePrefix",
            "position": 2
          },
          {
            "valueFrom": "${// --outWigStrand\n    if (inputs.outWigType && inputs.outWigStrand) {\n        return inputs.outWigStrand;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--outWigStrand",
            "position": 2
          },
          {
            "valueFrom": "${ // --varVCFfile\n    if (inputs.in_variants) {\n        var vcf = [].concat(inputs.in_variants)[0];\n        if (vcf.path.toLowerCase().endsWith('gz')) {\n            return \"<(zcat \" + vcf.path + \")\";\n        } else {\n            return vcf.path;\n        }\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--varVCFfile",
            "position": 2
          },
          {
            "valueFrom": "${// --seedPerReadNmax\n    if (inputs.seedPerReadNmax) {\n        return inputs.seedPerReadNmax;\n    } else if (inputs.starlong) {\n        return 100000;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--seedPerReadNmax",
            "position": 2
          },
          {
            "valueFrom": "${// --seedPerWindowNmax\n    if (inputs.seedPerWindowNmax) {\n        return inputs.seedPerWindowNmax;\n    } else if (inputs.starlong) {\n        return 100;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--seedPerWindowNmax",
            "position": 2
          },
          {
            "valueFrom": "${// --seedSearchLmax\n    if (inputs.seedSearchLmax) {\n        return inputs.seedSearchLmax;\n    } else if (inputs.starlong) {\n        return 30;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--seedSearchLmax",
            "position": 2
          },
          {
            "valueFrom": "${// --seedSearchStartLmax\n    if (inputs.seedSearchStartLmax) {\n        return inputs.seedSearchStartLmax;\n    } else if (inputs.starlong) {\n        return 12;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--seedSearchStartLmax",
            "position": 2
          },
          {
            "valueFrom": "${// --winAnchorMultimapNmax\n    if (inputs.winAnchorMultimapNmax) {\n        return inputs.winAnchorMultimapNmax;\n    } else if (inputs.starlong) {\n        return 200;\n    } else {\n        return null;\n    }\n}",
            "shellQuote": false,
            "prefix": "--winAnchorMultimapNmax",
            "position": 2
          },
          {
            "valueFrom": "${ // sjdbOverhang\n    return inputs.read_length? inputs.read_length -1: null;\n}",
            "shellQuote": false,
            "prefix": "--sjdbOverhang",
            "position": 2
          }
        ],
        "sbg:modifiedOn": 1571322491,
        "sbg:publisher": "sbg",
        "sbg:validationErrors": [],
        "id": "nemanja.vucic/star-2-5-3a-modified-demo/star-align-2-5-3a_modified/6",
        "sbg:revision": 6,
        "sbg:categories": [
          "Transcriptomics",
          "Alignment"
        ]
      },
      "in": [
        {
          "source": "cpu_per_star_align",
          "id": "cpu_per_job"
        },
        {
          "source": "star_genome_generate_2_5_3a_modified/out_references_or_index",
          "id": "in_index"
        },
        {
          "source": "limitOutSJcollapsed",
          "id": "limitOutSJcollapsed"
        },
        {
          "source": "mem_per_star_align",
          "id": "mem_per_job"
        },
        {
          "source": "sbg_extract_basename/out_name",
          "id": "out_prefix"
        },
        {
          "id": "outSAMtype",
          "default": "BAM"
        },
        {
          "id": "outSortingType",
          "default": "SortedByCoordinate"
        },
        {
          "source": "read_length",
          "id": "read_length"
        },
        {
          "source": [
            "gatk_samtofastq_4_1_0_0/out_reads"
          ],
          "id": "in_reads"
        },
        {
          "source": "cpu_per_star_align",
          "id": "runThreadN"
        },
        {
          "id": "twopassMode",
          "default": "Basic"
        }
      ],
      "sbg:y": -26,
      "label": "STAR Align",
      "sbg:x": -181.5723419189453,
      "out": [
        {
          "id": "out_aligned_reads"
        },
        {
          "id": "out_chimeric_alignments"
        },
        {
          "id": "out_chimeric_junctions"
        },
        {
          "id": "out_intermediate_genome"
        },
        {
          "id": "out_log_files"
        },
        {
          "id": "out_reads_per_gene"
        },
        {
          "id": "out_splice_junctions"
        },
        {
          "id": "out_transcriptome_aligned_reads"
        },
        {
          "id": "out_unmapped_reads"
        },
        {
          "id": "out_wiggle_files"
        }
      ]
    },
    {
      "id": "star_genome_generate_2_5_3a_modified",
      "run": {
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "sbg:createdBy": "nemanja.vucic",
        "sbg:latestRevision": 3,
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "https://github.com/alexdobin/STAR"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/alexdobin/STAR"
          },
          {
            "label": "Download",
            "id": "https://github.com/alexdobin/STAR/archive/2.7.0d.tar.gz"
          },
          {
            "label": "Publication",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed/23104886"
          },
          {
            "label": "Documentation",
            "id": "http://labshare.cshl.edu/shares/gingeraslab/www-data/dobin/STAR/STAR.sandbox/doc/STARmanual.pdf"
          }
        ],
        "sbg:toolAuthor": "Alexander Dobin/CSHL",
        "sbg:cmdPreview": "mkdir genomeDir && STAR --runMode genomeGenerate --genomeDir ./genomeDir --runThreadN 5 --genomeFastaFiles /sbgenomics/test-data/chr20.fa  && tar -vcf chr20.sjdbGTFfile.star-2.7.0d-index-archive.tar ./genomeDir   && mv Log.out Log.out.log",
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "ramMin": "${\n  var memory = 60000;\n  \n  if(inputs.mem_per_job){\n  \t memory = inputs.mem_per_job\n  }\n  else if(inputs.limitGenomeGenerateRAM){\n  memory = inputs.limitGenomeGenerateRAM *1000\n  }\n  return memory\n}",
            "coresMin": "${\n    return inputs.cpu_per_job ? inputs.cpu_per_job : 8\n}",
            "class": "ResourceRequirement"
          },
          {
            "dockerPull": "images.sbgenomics.com/veliborka_josipovic/star:2.5.3a_modified",
            "class": "DockerRequirement"
          },
          {
            "listing": [
              "$(inputs.in_reference_or_index)",
              "$(inputs.in_gene_annotation)"
            ],
            "class": "InitialWorkDirRequirement"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
            ]
          }
        ],
        "doc": "**STAR Genome Generate** produces the necessary index files for successful **STAR** alignment, from an input FASTA and GTF files.  \n\n**STAR** (Spliced Transcripts Alignment to a Reference), an ultrafast RNA-seq aligner, is capable of mapping full length RNA sequences and detecting de novo canonical junctions, non-canonical splices, and chimeric (fusion) transcripts. **STAR** employs an RNA-seq alignment algorithm that uses sequential maximum mappable seed search in uncompressed suffix arrays followed by seed clustering and stitching procedure. It is optimized for mammalian sequence reads, but fine tuning of its parameters enables customization to satisfy unique needs [1].\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of this page.*\n\n### Common Use Cases\n\n**STAR Genome Generate** is a tool that generates genome index files. One set of files should be generated per each FASTA/GTF combination. Once produced, these files could be used as long as FASTA/GTF combination stays the same. Also, **STAR Genome Generate** which produced these files and **STAR** aligner using them must be of the same toolkit version.\n\n* If the indexes for a desired FASTA/GTF pair have already been generated, make sure to supply the resulting TAR bundle to the tool input if you are using this tool in a workflow in order to skip unnecessary indexing and speed up the whole workflow process.\n* If you are providing a GFF3 file (which are usually downloaded from **NCBI's RefSeq database**) and wish to use **STAR** results for further downstream analysis, a good idea would be to set the **Exon parent name** (`--sjdbGTFtagExonParentTranscript`) option to **Parent**.\n* If you wish to run **STAR** in **multiple samples two-pass mode**, you need to provide the resulting **splice junction** outputs from **STAR** to the **List of annotated junctions** (`--sjdbFileChrStartEnd`) input of **STAR Genome Generate**, and generate the index archive with these, instead of supplying the GTF file [2]. \n\n###Common issues###\n\n* If the reference genome used has a bit number of contig sequences (>5000), a suggestion is to set the **Bins size** (`--genomeChrBinNbits`) parameter to the value of min(18, log2(GenomeLength/NumberOfReferences)). \n* If the reference genome used is a rather small genome, a suggestion is to set the **Pre-indexing string length** (`--genomeSAindexNbases`) parameter to the value of min(14, log2(GenomeLength)/2 - 1). \n* If **STAR Genome Generates** for some reason fails because of insufficient RAM problem, the **Limit Genome Generate RAM** (`--limitGenomeGenerateRAM`) parameter can be increased to make the RAM demands, though since the default value is 60GB, this should only be happening with extremely large reference files (for example, 30GB is enough for the human reference genome). \n* The GTF and FASTA files need to have compatible transcript IDs and chromosome names.\n\n### Changes Introduced by Seven Bridges\n\n* The directory containing the index files will be outputted as a TAR bundle (the **Genome files** output). This bundle can then be provided to the **STAR** aligner, which will automatically take care of untarring it and preparing it to run successfully without further issues. \n\n### Performance Benchmarking\n\nSince **STAR Genome Generate** is run with a FASTA/GTF combination, the runtime of this tool will be pretty much constant across a number of different genomes. For the human reference genome, the tool is expected to finish in around 30 minutes, costing around $0.75 on the c4.8xlarge AWS instance. \n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n### References\n\n[1] [STAR paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3530905/)\n[2] [STAR manual](http://labshare.cshl.edu/shares/gingeraslab/www-data/dobin/STAR/STAR.sandbox/doc/STARmanual.pdf)",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:createdOn": 1553263068,
        "id": "nemanja.vucic/star-2-5-3a-modified-demo/star-genome-generate-2-5-3a_modified/3",
        "sbg:projectName": "STAR 2.5.3a_modified - Demo",
        "sbg:image_url": null,
        "sbg:revisionNotes": "fixed secondaryFiles expression",
        "sbg:modifiedBy": "nemanja.vucic",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1553263068,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "nemanja.vucic"
          },
          {
            "sbg:modifiedOn": 1553263087,
            "sbg:revision": 1,
            "sbg:revisionNotes": "",
            "sbg:modifiedBy": "nemanja.vucic"
          },
          {
            "sbg:modifiedOn": 1559664996,
            "sbg:revision": 2,
            "sbg:revisionNotes": "tested with cwltool",
            "sbg:modifiedBy": "nemanja.vucic"
          },
          {
            "sbg:modifiedOn": 1559667429,
            "sbg:revision": 3,
            "sbg:revisionNotes": "fixed secondaryFiles expression",
            "sbg:modifiedBy": "nemanja.vucic"
          }
        ],
        "sbg:appVersion": [
          "v1.0"
        ],
        "sbg:project": "nemanja.vucic/star-2-5-3a-modified-demo",
        "sbg:toolkit": "STAR",
        "label": "STAR Genome Generate",
        "sbg:content_hash": "ac9ece6bf938e08631f0059eb7ac80b329ad0974821cb98eb69747caece76d7d4",
        "outputs": [
          {
            "type": "File?",
            "label": "Genome Files",
            "sbg:fileTypes": "TAR",
            "id": "out_references_or_index",
            "outputBinding": {
              "glob": "*.tar*",
              "outputEval": "${\n    return inheritMetadata(self, inputs.in_reference_or_index);\n\n}"
            },
            "doc": "Genome files comprise binary genome sequence, suffix arrays, text chromosome names/lengths, splice junctions coordinates, and transcripts/genes information."
          }
        ],
        "sbg:id": "h-47e35e44/h-69c78fd2/h-945e025c/0",
        "class": "CommandLineTool",
        "inputs": [
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "cpu_per_job",
            "label": "CPU per job",
            "sbg:category": "Platform options",
            "doc": "Number of CPUs to be used per job."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "18",
            "id": "genomeChrBinNbits",
            "doc": "Set log2(chrBin), where chrBin is the size (bits) of the bins for genome storage: each chromosome will occupy an integer number of bins. If you are using a genome with a large (>5,000) number of chrosomes/scaffolds, you may need to reduce this number to reduce RAM consumption. The following scaling is recomended: genomeChrBinNbits = min(18, log2(GenomeLength/NumberOfReferences)). For example, for 3 gigaBase genome with 100,000 chromosomes/scaffolds, this is equal to 15.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--genomeChrBinNbits",
              "position": 1
            },
            "sbg:category": "Genome generation parameters",
            "label": "Bins size"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "14",
            "id": "genomeSAindexNbases",
            "doc": "Length (bases) of the SA pre-indexing string. Typically between 10 and 15. Longer strings will use much more memory, but allow faster searches. For small genomes, this number needs to be scaled down, with a typical value of min(14, log2(GenomeLength)/2 - 1). For example, for 1 megaBase genome, this is equal to 9, for 100 kiloBase genome, this is equal to 7.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--genomeSAindexNbases",
              "position": 1
            },
            "sbg:category": "Genome generation parameters",
            "label": "Pre-indexing string length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "1",
            "id": "genomeSAsparseD",
            "doc": "Distance between indices: use bigger numbers to decrease needed RAM at the cost of mapping speed reduction (int>0).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--genomeSAsparseD",
              "position": 1
            },
            "sbg:category": "Genome generation parameters",
            "label": "Suffux array sparsity"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "-1",
            "id": "genomeSuffixLengthMax",
            "doc": "Maximum length of the suffixes, has to be longer than read length. -1 = infinite.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--genomeSuffixLengthMax",
              "position": 1
            },
            "sbg:category": "Genome generation parameters",
            "label": "Maximum genome suffic length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "60",
            "id": "limitGenomeGenerateRAM",
            "label": "Limit Genome Generate RAM",
            "sbg:category": "Run parameters",
            "doc": "Upper RAM limit for genome generation, in GB."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2048",
            "id": "mem_per_job",
            "label": "Memory per job",
            "sbg:category": "Platform options",
            "doc": "Amount of RAM memory to be used per job. Defaults to 2048MB for Single threaded jobs,and all of the available memory on the instance for multi-threaded jobs."
          },
          {
            "type": "File",
            "secondaryFiles": [
              "${ \n    return self.basename + \".fai\";\n}"
            ],
            "id": "in_reference_or_index",
            "sbg:fileTypes": "FASTA, FA, FNA, TAR",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--genomeFastaFiles",
              "position": 1
            },
            "label": "Reference/Index files",
            "sbg:category": "Basic",
            "doc": "Reference sequence to which to align the reads, or a TAR bundle containing already generated indices."
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "16",
            "id": "runThreadN",
            "label": "Number of threads",
            "sbg:category": "Run parameters",
            "doc": "Number of threads to use."
          },
          {
            "type": "File[]?",
            "id": "in_intervals",
            "sbg:fileTypes": "TXT, SJDB, TAB",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbFileChrStartEnd",
              "position": 1
            },
            "label": "List of annotated junctions",
            "sbg:category": "Basic",
            "doc": "List of splice junction coordinates in a tab-separated file."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "-",
            "id": "sjdbGTFchrPrefix",
            "doc": "Prefix for chromosome names in a GTF file (e.g. 'chr' for using ENSMEBL annotations with UCSC geneomes).",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbGTFchrPrefix",
              "position": 1
            },
            "sbg:category": "Splice junctions db parameters",
            "label": "Chromosome names"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "exon",
            "id": "sjdbGTFfeatureExon",
            "doc": "Feature type in GTF file to be used as exons for building transcripts.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbGTFfeatureExon",
              "position": 1
            },
            "sbg:category": "Splice junctions db parameters",
            "label": "Set exons feature"
          },
          {
            "type": "File?",
            "id": "in_gene_annotation",
            "sbg:fileTypes": "GTF, GFF, GFF2, GFF3",
            "inputBinding": {
              "shellQuote": false,
              "itemSeparator": " ",
              "prefix": "--sjdbGTFfile",
              "position": 1
            },
            "label": "Gene annotation file",
            "sbg:category": "Basic",
            "doc": "Gene annotation file in GTF/GFF format. If you are providing a GFF3 file and wish to use STAR results for further downstream analysis, a good idea would be to set the \"Exons' parents name\" (id: sjdbGTFtagExonParentTranscript) option to \"Parent\"."
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "gene_id",
            "id": "sjdbGTFtagExonParentGene",
            "doc": "Tag name to be used as exons gene-parents.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbGTFtagExonParentGene",
              "position": 1
            },
            "sbg:category": "Splice junctions db parameters",
            "label": "Gene name"
          },
          {
            "type": "string?",
            "sbg:toolDefaultValue": "transcript_id",
            "id": "sjdbGTFtagExonParentTranscript",
            "doc": "Tag name to be used as exons transcript-parents.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbGTFtagExonParentTranscript",
              "position": 1
            },
            "sbg:category": "Splice junctions db parameters",
            "label": "Exon parent name"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "100",
            "id": "sjdbOverhang",
            "doc": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbOverhang",
              "position": 1
            },
            "sbg:category": "Splice junctions db parameters",
            "label": "\"Overhang\" length"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "2",
            "id": "sjdbScore",
            "doc": "Extra alignment score for alignments that cross database junctions.",
            "inputBinding": {
              "shellQuote": false,
              "prefix": "--sjdbScore",
              "position": 1
            },
            "sbg:category": "Splice junctions db parameters",
            "label": "Extra alignment score"
          },
          {
            "type": "int?",
            "sbg:toolDefaultValue": "100",
            "doc": "The length of the reads.",
            "label": "Read length",
            "id": "read_length"
          }
        ],
        "sbg:contributors": [
          "nemanja.vucic"
        ],
        "baseCommand": [],
        "arguments": [
          {
            "valueFrom": "${\n    var x = inputs.in_reference_or_index.path.split('/').pop();\n    var y = x.split('.').pop();\n    var z = inputs.runThreadN ? inputs.runThreadN : 8;\n    if (y == 'fa' || y == 'fasta' || y == 'FA' || y == \"FASTA\") {\n        return \"mkdir genomeDir && STAR --runMode genomeGenerate --genomeDir ./genomeDir --runThreadN \" + z\n    } else if (y == 'tar' || y == 'TAR') {\n        return \"echo 'Tar bundle provided, skipping indexing.' \"\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 0
          },
          {
            "valueFrom": "${\n    var tmp1 = [].concat(inputs.in_reference_or_index)[0].path.split('/').pop();\n    if (inputs.in_gene_annotation) {\n        var tmp2 = [].concat(inputs.in_gene_annotation)[0].path.split('/').pop();\n    } else if (inputs.in_intervals) {\n        var tmp2 = [].concat(inputs.in_intervals)[0].path.split('/').pop();\n    } else {\n        var tmp2 = \"\";\n    }\n\n    var str1 = tmp1.split('.');\n    var x1 = \"\";\n    for (var i = 0; i < str1.length - 1; i++) {\n        if (i < str1.length - 2) {\n            x1 = x1 + str1[i] + \".\"\n        } else {\n            x1 = x1 + str1[i]\n        }\n    }\n\n    var str2 = tmp2.split('.');\n    var x2 = \"\";\n    for (var i = 0; i < str2.length - 1; i++) {\n        if (i < str2.length - 2) {\n            x2 = x2 + str2[i] + \".\"\n        } else {\n            x2 = x2 + str2[i] + \".\"\n        }\n    }\n    var tmp3 = inputs.in_reference_or_index.path.split('/').pop();\n    var tmp4 = tmp3.split('.').pop();\n    if (tmp4 == 'tar' || tmp4 == 'TAR') {\n        return \"\"\n    } else {\n        return \"&& (tar -zvcf \" + x1 + \".\" + x2 + \"star-2.5.3a_modified-index-archive.tar.gz genomeDir --warning=no-file-changed || [ $? -eq 1 ])\"\n    }\n}",
            "shellQuote": false,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": "${// --limitGenomeGenerateRAM\n    return inputs.limitGenomeGenerateRAM ? inputs.limitGenomeGenerateRAM * 1000000000 : 60000000000\n}",
            "shellQuote": false,
            "prefix": "--limitGenomeGenerateRAM",
            "position": 1
          },
          {
            "valueFrom": "${ // sjdbOverhang\n    return inputs.read_length? inputs.read_length -1:null\n}",
            "shellQuote": false,
            "prefix": "--sjdbOverhang",
            "position": 2
          }
        ],
        "sbg:modifiedOn": 1559667429,
        "sbg:publisher": "sbg",
        "sbg:toolkitVersion": "2.5.3a_modified",
        "cwlVersion": "v1.0",
        "sbg:revision": 3,
        "sbg:categories": [
          "Transcriptomics",
          "Alignment"
        ]
      },
      "in": [
        {
          "source": "cpu_per_job",
          "id": "cpu_per_job"
        },
        {
          "source": "mem_per_job",
          "id": "mem_per_job"
        },
        {
          "source": "in_reference_or_index",
          "id": "in_reference_or_index"
        },
        {
          "source": "cpu_per_job",
          "id": "runThreadN"
        },
        {
          "source": "in_gene_annotation",
          "id": "in_gene_annotation"
        },
        {
          "source": "read_length",
          "id": "read_length"
        }
      ],
      "sbg:y": 227.47145080566406,
      "label": "STAR Genome Generate",
      "sbg:x": -664.0675048828125,
      "out": [
        {
          "id": "out_references_or_index"
        }
      ]
    }
  ],
  "sbg:appVersion": [
    "v1.0"
  ],
  "id": "https://cgc-api.sbgenomics.com/v2/apps/phil_webster/bco-cwl-examples/broad-best-practices-rna-seq-variant-calling-4-1-0-0/0/raw/",
  "sbg:id": "phil_webster/bco-cwl-examples/broad-best-practices-rna-seq-variant-calling-4-1-0-0/0",
  "sbg:revision": 0,
  "sbg:revisionNotes": "Copy of admin/sbg-public-data/broad-best-practices-rna-seq-variant-calling-4-1-0-0/8",
  "sbg:modifiedOn": 1663787195,
  "sbg:modifiedBy": "phil_webster",
  "sbg:createdOn": 1663787195,
  "sbg:createdBy": "phil_webster",
  "sbg:project": "phil_webster/bco-cwl-examples",
  "sbg:sbgMaintained": false,
  "sbg:validationErrors": [],
  "sbg:contributors": [
    "phil_webster"
  ],
  "sbg:latestRevision": 0,
  "sbg:publisher": "sbg",
  "sbg:content_hash": "a4b6dddc2b21ea44e2d508e06153062276e85367abd77c236f3af08d2ff930b85",
  "sbg:workflowLanguage": "CWL",
  "sbg:copyOf": "admin/sbg-public-data/broad-best-practices-rna-seq-variant-calling-4-1-0-0/8"
}