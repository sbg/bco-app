{
  "class": "Workflow",
  "cwlVersion": "v1.1",
  "doc": "**ChIP-Seq** Analysis studies chromatin modifications and binding patterns of transcription factors and other proteins.\nIt combines chromatin immunoprecipitation (ChIP) assays with standard NGS sequencing. The workflow is based on ChIP-Seq 2 pipeline, developed by Encode consortia [1].\nThe steps of the ChIP-Seq Analysis workflow consist of mapping of reads including duplicate removal, cross correlation analysis, peak calling with blacklist filtering and a statistical framework, applied to the replicated peaks at the end in order to assess concordance of biological replicates. \n\n\n*A list of **all inputs and parameters** with corresponding descriptions can be found at the bottom of the page.*\n\n***Please note that any cloud infrastructure costs resulting from app and pipeline executions, including the use of public apps, are the sole responsibility of you as a user. To avoid excessive costs, please read the app description carefully and set the app parameters and execution settings accordingly.*** \n\n### Common Use Cases\n\n\n* **ENCODE ChIP-Seq Pipeline 2** is designed for processing single-end and paired-end ChIP-Seq data. It takes **List of bio-replicates FASTQ files**,  **Reference file**, **Index TAR** file and a **Chromosome sizes** file as required inputs. Optionally, a **Blacklist interval file** file can also be provided. It contains blacklist regions, genomic regions that are associated with artifact signals and may need to be removed.\nRequired AppSettings are sequence endedness for **Paired-end bio-replicates** (**Paired-end control files**, if controls files are provided), **Pipeline type**, that defines the type of analysis that will be performed (**tf**, **histone** or **control**), and **True replicates only** parameter that disables all analyses related to pseudo-replicates. Also, **Enable count signal track**, **Enable GC bias** and **Enable Jsd** should be set to true in order to include **Count Signal Track**, **GC bias** and **Jsd** tools in the analysis. \n\n* Pipeline recognizes biological replicates, on which the analysis is performed, as well as control replicates, which are being used to increase the specificity in peak calling. Technical replicates for each biological replicate can be provided and they will be merged in the first step in the pipeline. Next, the input reads are aligned, and the deduplication is performed along with the removal of unmapped and low-quality reads. This step is performed for both biological replicates and control reads. Users can choose the **Aligner** to be used, Bowtie2 or BWA-MEM. Also, there are two **Marker for duplicate reads** options to choose from in the filtering step, Picard and sambamba. The cross-correlation analysis is done on a filtered (but not-deduped) and subsampled BAM. There is a special FASTQ trimming for cross-correlation analysis. Read1 FASTQ file is trimmed to 50bp and then separately mapped as SE. Reads are filtered but duplicates are not removed, according to the workflow design [2]. \n\n* After alignment and filtering, resulting BAM files are converted to TAG-ALIGN (6 col. BED) format for each of the bio-replicates. Simplified TAG-ALIGN files serve as inputs to several tools, apart from peak caller. **Count Signal Track** and **Macs2 Signal Track** tools generate signal tracks, whereas the **Spr** tool creates self-pseudoreplicate reads. If there are at least two bio-replicates provided on input, pooling of the reads from different bio-replicates and pseudoreplicates is performed by **Pool TA**. This way additional files are provided for the IDR framework in order to have an unbiased quantitative way to determine if the peak came from all input replicates. \n\n* **Choose Ctl** and **Subsample Ctl** tools are used as a means to select an appropriate control file for peak calling.     \n\n* Peak calling is then performed on all replicates, pooled data, self-pseudoreplicates of each bio-replicate and the pooled pseudoreplicates. The workflow supports calling of two general types of peaks: narrow and region.The MACS2 and SPP methods are used for peak calling. The MACS2 software has a mode for narrow peak calling and can be used for both tf and histone pipeline type, while SPP is preferably used for region peak calling when analysing transcription factor binding sites.\n\n\n* As a way to assess concordance of peak calls between replicates, the **IDR** tool is used as the next step, along with **Overlap**, providing input peak files for the **Reproducibility** tool in order to obtain reproducibility QC. The basic idea is that if two replicates measure the same underlying biology, the most significant peaks, which are likely to be genuine signals, are expected to have high consistency between replicates, whereas peaks with low significance, which are more likely to be noise, are expected to have low consistency. Finally, **QC Report** collects all previously generated QC files and produces the final HTML and JSON QC reports, in an attempt to assess the quality of performed analysis.\n\n\n### Changes Introduced by Seven Bridges\n* Input FASTQ files belonging to Read1 and Read2 should be provided at the same input port. **SBG Pair FASTQs by Metadata** tool is added at the beginning of the pipeline in order to properly separate R1 and R2 for the **Align** tool.\n* Choosing the adequate control file for peak calling on replicates and pooled replicates is performed inside the **Subsample Ctl** and **Subsample Pool Ctl** tools.\n* In order to ensure that all the combinations of pairs of replicates are provided to cross-validation analyses (IDR/overlap), **SBG Cross Files** tool is added after the peak calling step. \n* **SBG Scatter Prepare** is added to the pipeline to pair the TAGALIGN bio-replicate files to corresponding control files forming a dictionary where the keys are bio-replicate files basenames, and values are corresponding control files basenames if there is at least one control file provided, or empty strings if no controls were included in the analysis. Dictionaries are then forwarded as an input to peak callers in order to select an appropriate control file for each bio-replicate TAGALIGN file. Since there are viable use cases where the number of biological replicates and control files do not match, scatter cannot be performed on bio-replicates and controls simultaneously.  \n \n\n\n### Common Issues and Important Notes\n* This pipeline supports up to 10 biological replicates and 10 controls, but it is recommended to keep up to 4 biological replicates, as the cross-validation (IDR/overlap) step is comparing every pair of the provided replicates.\n*  All files provided to the **List of control FASTQ files** and **List of bio-replicates FASTQ files** must have  **Sample ID** and **Case ID** metadata fields set. **Paired-end** metadata field must be set appropriately just for paired-end samples; if providing single-end files, do not set the **Paired-end** metadata field. All biological replicates must have a unique **Sample ID**, which can be an arbitrary string. For each biological replicate a single or multiple technical replicates can be provided and they will be merged in the first step in the pipeline. All technical replicates that correspond to one bio-replicate must have the same **Sample ID**. In addition to that all technical replicates must have an integer **Case ID** set such that it represents the order in which the technical replicates will be merged. Same logic applies if control files are provided.\nExamples of correctly set metadata for different scenarios:\\\n**Scenario 1**: There are 3 bio-replicates with a single technical replicate each, which makes a 3 input FASTQ files in total for single-end (or 6 for paired-end)\\\nFile1(SE) - metadata:{**Sample id**:<bio-rep1>, **Case id**: 1}\\\nFile2(SE) - metadata:{**Sample id**:<bio-rep2>, **Case id**: 1}\\\nFile3(SE) - metadata:{**Sample id**:<bio-rep3>, **Case id**: 1}\\\n**Scenario2**: There is one bio-replicate with 3 technical replicates, which makes a 3 input FASTQ files in total for single-end (or 6 for paired-end)\\\nFile1(SE) - metadata:{**Sample id**:<bio-rep1>, **Case id**: 1}\\\nFile2(SE) - metadata:{**Sample id**:<bio-rep1>, **Case id**: 2}\\\nFile3(SE) - metadata:{**Sample id**:<bio-rep1>, **Case id**: 3}\n*  The reference index file provided at the **Index TAR** input must be in concordance with the chosen **Aligner type**. \n* User controls the analysis type, **tf**, **histone**, or **control** by choosing the appropriate peak caller and pipeline type.\n* Default peak caller is **macs2**, and can be used with both **tf** and **histone** analysis, while the **spp** is used only with **tf**. Regardless of pipeline type, spp peak caller requires control files, whereas the control files are optional for macs2.\n* If the **control** mode is chosen, input control files should be provided at the  **List of bio-replicates FASTQ files** input port, while the **List of control FASTQ files** input port should be left empty. \n* All genome specific reference and additional files (Bowtie2 Index TAR, Chromosome sizes TSV, Reference FASTA file, Blacklist file) for hg38, mm10, hg19, and mm9 genomes can be found in the ENCODE ChIP-seq pipeline GitHub repository.\n\n\n\n### Performance Benchmarking\n\nThe most time consuming step of the workflow is the alignment of the bio-replicates/controls. Increasing the number of parallel instances to match the number of jobs of all the alignment steps will speed up the execution.\n\n| No of bio-replicates/ controls | Pipelyne type | Size per fastq.gz (control) | paired-end | Peak caller | Execution time | Price | Instances  (AWS)               |No of parallel instances\n| ------------------------------ | ------------- | --------------------------- | ---------- | ----------- | -------------- | ----- | ------------------------- |--------------|\n| 2/2                            | tf            | 2.4 (3.5) GB                | true       | spp         | 2h 36min       |  $5.81 | c4.2xlarge | 6 |\n| 2/2                            | tf            | 2.4 (3.5) GB                | true       | spp         | 3h 29min       |  $5.62 | c4.2xlarge | 4 |\n| 2/2                            | tf            | 2.4 (3.5) GB                | true       | spp         | 5h 37min       | $5.51 | c4.2xlarge | 2 |\n| 2/2                            | tf            | 2.4 (3.5) GB                | true       | macs2       | 5h 6min       | $4.92 | c4.2xlarge | 2 | \n| 2/0                            | histone       | 2.4 (/) GB                  | true       | macs2       | 3h 7min        | $2.91 | c4.2xlarge | 2 |\n| 2/0                            | control       | 3.5 (/) GB                  | true       | /           | 2h 52m          | $3.04 | c4.2xlarge | 2 |\n| 2/2                            | tf            | 900 (450) MB                | false      | spp         | 1h 3min        | $1.45 | c4.2xlarge | 2 |\n| 3/3                            | tf            | 650 (850) MB                | false      | spp         | 2h 11min       | $2.24 | c4.2xlarge | 2 |\n\n\n*Cost can be significantly reduced by using **spot instances**. Visit the [Knowledge Center](https://docs.sevenbridges.com/docs/about-spot-instances) for more details.*\n\n\n### API Python Implementation\nThe app's draft task can also be submitted via the **API**. In order to learn how to get your **Authentication token** and **API endpoint** for corresponding platform visit our [documentation](https://github.com/sbg/sevenbridges-python#authentication-and-configuration).\n\u200b\n```python\n# Initialize the SBG Python API\nfrom sevenbridges import Api\napi = Api(token=\"enter_your_token\", url=\"enter_api_endpoint\")\n# Get project_id/app_id from your address bar. Example: https://igor.sbgenomics.com/u/your_username/project/app\nproject_id = \"your_username/project\"\napp_id = \"your_username/project/app\"\n# Replace inputs with appropriate values\ninputs = {\n\t\"in_reference\": api.files.query(project=project_id, names=[\"enter_filename\"])[0], \n\t\"in_index\": api.files.query(project=project_id, names=[\"enter_filename\"])[0], \n\t\"in_chrsz\": api.files.query(project=project_id, names=[\"enter_filename\"])[0], \n\t\"in_reads\": list(api.files.query(project=project_id, names=[\"enter_filename\", \"enter_filename\"])), \n\t\"paired_end\": True, \n\t\"true_replicates_only\": True, \n\t\"enable_count_signal_track\": True, \n\t\"enable_gc_bias\": True, \n\t\"pipeline_type\": \"tf\", \n\t\"enable_jsd\": True}\n# Creates draft task\ntask = api.tasks.create(name=\"ChIP-Seq WF - API Run\", project=project_id, app=app_id, inputs=inputs, run=False)\n```\n\u200b\nInstructions for installing and configuring the API Python client, are provided on [github](https://github.com/sbg/sevenbridges-python#installation). For more information about using the API Python client, consult [the client documentation](http://sevenbridges-python.readthedocs.io/en/latest/). **More examples** are available [here](https://github.com/sbg/okAPI).\n\u200b\n\nAdditionally, [API R](https://github.com/sbg/sevenbridges-r) and [API Java](https://github.com/sbg/sevenbridges-java) clients are available. To learn more about using these API clients please refer to the [API R client documentation](https://sbg.github.io/sevenbridges-r/), and [API Java client documentation](https://docs.sevenbridges.com/docs/java-library-quickstart).\n\n\n### References\n\n[1] [https://github.com/ENCODE-DCC/chip-seq-pipeline2](https://github.com/ENCODE-DCC/chip-seq-pipeline2)\n\n[2] [chip.wdl](https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568)",
  "label": "ENCODE ChIP-Seq Pipeline 2",
  "$namespaces": {
    "sbg": "https://sevenbridges.com"
  },
  "inputs": [
    {
      "id": "in_reference",
      "sbg:fileTypes": "FA, FASTA, FA.GZ, FASTA.GZ",
      "type": "File",
      "label": "Reference genome",
      "doc": "Reference FASTA file.",
      "sbg:x": -3313.376220703125,
      "sbg:y": -1803.603759765625
    },
    {
      "id": "in_index",
      "sbg:fileTypes": "TAR, TAR.GZ",
      "type": "File",
      "label": "Index TAR",
      "doc": "Index TAR file.",
      "sbg:x": -3319.4365234375,
      "sbg:y": -1686.7244873046875
    },
    {
      "id": "in_chrsz",
      "sbg:fileTypes": "TSV",
      "type": "File",
      "label": "Chromosome sizes file",
      "doc": "A 2-col chromosome sizes file.",
      "sbg:x": -3553.724365234375,
      "sbg:y": -1557.5784912109375
    },
    {
      "id": "in_ctl_reads",
      "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
      "type": "File[]?",
      "label": "List of control FASTQ files",
      "doc": "List of the FASTQ files with properly set metadata fileds.",
      "sbg:x": -3184.195068359375,
      "sbg:y": -2189.839111328125
    },
    {
      "id": "in_reads",
      "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
      "type": "File[]",
      "label": "List of bio-replicates FASTQ files",
      "doc": "List of the FASTQ files with properly set metadata fileds.",
      "sbg:x": -3151.71826171875,
      "sbg:y": -1126.0604248046875
    },
    {
      "id": "custom_align_py",
      "sbg:fileTypes": "PY",
      "type": "File?",
      "label": "Custom aligner script",
      "doc": "Python script for a custom aligner.",
      "sbg:x": -3319.476806640625,
      "sbg:y": -1567.8251953125
    },
    {
      "id": "aligner",
      "type": [
        "null",
        {
          "type": "enum",
          "symbols": [
            "custom",
            "bowtie2",
            "bwa"
          ],
          "name": "aligner"
        }
      ],
      "label": "Aligner",
      "doc": "Aligner to be used in the alignment step. To use a custom aligner, define chip.custom_align_py and chip.custom_aligner_idx_tar.",
      "sbg:x": -3312.3359375,
      "sbg:y": -1923.4427490234375
    },
    {
      "id": "mito_chr_name",
      "type": "string?",
      "label": "Mitochondrial chromosome name",
      "doc": "Mitochondrial reads defined here will be filtered out during filtering BAMs in \"filter\" task. e.g. chrM, MT.",
      "sbg:x": -3320.496826171875,
      "sbg:y": -1437.7647705078125
    },
    {
      "id": "ctl_paired_end",
      "type": "boolean?",
      "label": "Paired-end control files",
      "doc": "Sequencing endedness. Setting this on means that all replicates are paired ended.",
      "sbg:x": -3197.215087890625,
      "sbg:y": -2302.697998046875
    },
    {
      "id": "use_bwa_mem_for_pe",
      "type": "boolean?",
      "label": "Use bwa mem",
      "doc": "For paired end dataset with read length >= 70bp, use bwa mem instead of bwa aln.",
      "sbg:x": -3324.537109375,
      "sbg:y": -1318.74462890625
    },
    {
      "id": "ctl_subsample",
      "type": "int?",
      "label": "Subsample reads controls",
      "doc": "Number of reads to subsample TAGALIGN file. Reads are shuffled and subsampled. This affects all downstream analyses after filtering BAM. (e.g. all TAG-ALIGN files, peak-calling). Reads will be shuffled only if actual number of reads in BAM exceeds this number.  0 means disabled.",
      "sbg:x": -3184.25537109375,
      "sbg:y": -2062.798828125
    },
    {
      "id": "paired_end",
      "type": "boolean",
      "label": "Paired-end bio-replicates",
      "doc": "Sequencing endedness. Setting this on means that all replicates are paired ended.",
      "sbg:x": -3151.677978515625,
      "sbg:y": -1009.0805053710938
    },
    {
      "id": "true_replicates_only",
      "type": "boolean",
      "label": "True replicates only",
      "doc": "Disables all analyses related to pseudo-replicates.",
      "sbg:x": -3154.758544921875,
      "sbg:y": -760.1006469726562
    },
    {
      "id": "enable_count_signal_track",
      "type": "boolean",
      "label": "Enable count signal track",
      "doc": "Enable count signal track.",
      "sbg:x": -3152.778564453125,
      "sbg:y": -638.140869140625
    },
    {
      "id": "enable_gc_bias",
      "type": "boolean",
      "label": "Enable GC bias",
      "doc": "Enable GC bias.",
      "sbg:x": -3149.798828125,
      "sbg:y": -524.1610107421875
    },
    {
      "id": "subsample",
      "type": "int?",
      "label": "Subsample reads bio-replicates",
      "doc": "Number of reads to subsample TAGALIGN file. Reads are shuffled and subsampled. This affects all downstream analyses after filtering BAM. (e.g. all TAG-ALIGN files, peak-calling). Reads will be shuffled only if actual number of reads in BAM exceeds this number.  0 means disabled.",
      "sbg:x": -3153.71826171875,
      "sbg:y": -886.0805053710938
    },
    {
      "id": "pipeline_type",
      "type": {
        "type": "enum",
        "symbols": [
          "tf",
          "histone",
          "control"
        ],
        "name": "pipeline_type"
      },
      "label": "Pipeline type",
      "doc": "Pipeline {tf, histone, control}. Default: tf.",
      "sbg:x": -3560.063720703125,
      "sbg:y": -1434.177490234375
    },
    {
      "id": "trim_bp",
      "type": "int?",
      "label": "Trim bp",
      "doc": "Trim experiment read1 FASTQ (for both SE and PE) for cross-correlation analysis. This does not affect alignment of experimental/control replicates. Pipeline additionaly aligns R1 FASTQ only for cross-correlation analysis only. This parameter is used for it.",
      "sbg:x": -3045.476806640625,
      "sbg:y": -2061.040283203125
    },
    {
      "id": "crop_length",
      "type": "int?",
      "label": "Crop FASTQs",
      "doc": "Crop FASTQ reads longer than this length. Also drop all reads shorter than crop_length - crop_length_tol.",
      "sbg:x": -3052.496826171875,
      "sbg:y": -1940.040283203125
    },
    {
      "id": "crop_length_tol",
      "type": "int?",
      "label": "Crop FASTQs tolerance",
      "doc": "Tolerance for cropping reads in FASTQs. Drop all reads shorter than chip.crop_length - chip.crop_length_tol. Activated only when chip.crop_length is defined.",
      "sbg:x": -3045.496826171875,
      "sbg:y": -1818.0201416015625
    },
    {
      "id": "trimmomatic_phred_score_format",
      "type": [
        "null",
        {
          "type": "enum",
          "symbols": [
            "auto",
            "phred33",
            "phred64"
          ],
          "name": "trimmomatic_phred_score_format"
        }
      ],
      "label": "Phred score encoding",
      "doc": "Base encoding format for Phred score in FASTQs. This is used for Trimmomatic only. It is auto by default, which means that Trimmomatic automatically detect it from FASTQs. Otherwise -phred33 or -phred64 will be passed to the Trimmomatic command line. Use this if you see an error like \"Error: Unable to detect quality encoding\".",
      "sbg:x": -3041.51708984375,
      "sbg:y": -1696.0201416015625
    },
    {
      "id": "dup_marker",
      "type": [
        "null",
        {
          "type": "enum",
          "symbols": [
            "picard",
            "sambamba"
          ],
          "name": "dup_marker"
        }
      ],
      "label": "Marker for duplicate reads",
      "doc": "Marker for duplicate reads. Choose picard for Picard MarkDuplicates or sambamba for sambamba markdup.",
      "sbg:x": -3041.577392578125,
      "sbg:y": -1581.0604248046875
    },
    {
      "id": "filter_chrs",
      "type": "string[]?",
      "label": "Chromosomes to be filtered",
      "doc": "List of chromosomes to be filtered out while filtering BAM. It is empty by default, hence no filtering out of specfic chromosomes. It is case-sensitive. Use exact word for chromosome names.",
      "sbg:x": -3048.657958984375,
      "sbg:y": -1456.0804443359375
    },
    {
      "id": "exclusion_range_min",
      "type": "int?",
      "label": "Exclusion minimum for cross-correlation analysis",
      "doc": "Exclusion minimum for cross-correlation analysis.",
      "sbg:exposed": true
    },
    {
      "id": "exclusion_range_max",
      "type": "int?",
      "label": "Exclusion maximum for cross-correlation analysis",
      "doc": "Exclusion maximum for cross-correlation analysis.",
      "sbg:exposed": true
    },
    {
      "id": "in_intervals",
      "sbg:fileTypes": "BED, BED.GZ",
      "type": "File?",
      "label": "Blacklist interval file",
      "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
      "sbg:x": -3541.3671875,
      "sbg:y": -1680.0875244140625
    },
    {
      "id": "enable_jsd",
      "type": "boolean",
      "label": "Enable Jsd",
      "doc": "Enable Jsd.",
      "sbg:x": -3140.657958984375,
      "sbg:y": -1241.040283203125
    },
    {
      "id": "peak_caller",
      "type": "string?",
      "label": "Peak caller",
      "doc": "Peak caller {macs2, spp}.\nPeak calling is performed on all replicates, pooled data, sel-pseudoreplicates of each bio-replicate and the pooled pseudoreplicates. The workflow supports calling of two general types of peaks: narrow and region.The macs2 and spp methods are used for peak calling. The macs2 software has a mode for narrow peak calling and can be used for both tf and histone pipeline type, while spp is preferably used for region peak calling when analysing transcription factor binding sites. Default: macs2.",
      "sbg:x": -3544.459716796875,
      "sbg:y": -1817.6160888671875
    },
    {
      "id": "pipeline_ver",
      "type": "string?",
      "label": "Pipeline version",
      "doc": "Pipeline metadata. Current version: 1.7.1.",
      "sbg:exposed": true
    },
    {
      "id": "title",
      "type": "string?",
      "label": "Title",
      "doc": "Metadata for a pipeline (e.g. title and description). Default, 'Untitled'.",
      "sbg:exposed": true
    },
    {
      "id": "description",
      "type": "string?",
      "label": "Description",
      "doc": "Metadata for a pipeline (e.g. title and description). Default, 'No description'.",
      "sbg:exposed": true
    },
    {
      "id": "mem_factor",
      "type": "float?",
      "label": "Memory factor",
      "doc": "Multiplication factor to determine memory required for task. This factor will be multiplied to the size of FASTQs to determine required memory of instance or job.\nThe default value for Bowtie2 aligner is 0.15, and 0.3 for BWA aligner.",
      "sbg:x": -3335.640869140625,
      "sbg:y": -2131.543701171875
    },
    {
      "id": "trimmomatic_java_heap",
      "type": "float?",
      "label": "Trimmomatic max memory",
      "doc": "Maximum memory for Trimmomatic. If not defined, 90% of align task's memory will be used.",
      "sbg:x": -3333.339599609375,
      "sbg:y": -2290.436767578125
    }
  ],
  "outputs": [
    {
      "id": "out_alignments",
      "outputSource": [
        "filter_bio_replicates/out_nodup_bam"
      ],
      "sbg:fileTypes": "BAM",
      "type": "File?",
      "label": "Filtered BAM bio-replicates",
      "doc": "Filtered BAM file.",
      "secondaryFiles": [
        {
          "pattern": ".bai",
          "required": false
        }
      ],
      "sbg:x": -1625.990234375,
      "sbg:y": -816.8092651367188
    },
    {
      "id": "out_pos_bw",
      "outputSource": [
        "count_signal_track/out_pos_bw"
      ],
      "sbg:fileTypes": "BIGWIG",
      "type": "File?",
      "label": "Positive bigWig bio-replicates",
      "doc": "Positive bigWig.",
      "sbg:x": -1413.7408447265625,
      "sbg:y": -687.01708984375
    },
    {
      "id": "out_neg_bw",
      "outputSource": [
        "count_signal_track/out_neg_bw"
      ],
      "sbg:fileTypes": "BIGWIG",
      "type": "File?",
      "label": "Negative bigWig bio-replicates",
      "doc": "Negative bigWig.",
      "sbg:x": -1419.7408447265625,
      "sbg:y": -817.9823608398438
    },
    {
      "id": "out_report",
      "outputSource": [
        "qc_report/out_report"
      ],
      "sbg:fileTypes": "HTML",
      "type": "File?",
      "label": "Output report",
      "doc": "Output HTML report.",
      "sbg:x": 717.4223022460938,
      "sbg:y": -1382.924072265625
    },
    {
      "id": "out_qc_json",
      "outputSource": [
        "qc_report/out_qc_json"
      ],
      "sbg:fileTypes": "JSON",
      "type": "File?",
      "label": "Output QC",
      "doc": "Output QC in JSON format.",
      "sbg:x": 740.2550048828125,
      "sbg:y": -1008.692138671875
    },
    {
      "id": "out_br_peak",
      "outputSource": [
        "call_peak_bio_replicates/out_peak"
      ],
      "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ",
      "type": "File?",
      "label": "Peak bio-replicates",
      "doc": "Generated by encode_task_macs2_atac.py.",
      "sbg:x": -607.237060546875,
      "sbg:y": -2375.869873046875
    },
    {
      "id": "out_br_pval_bw",
      "outputSource": [
        "macs2_signal_track_bio_replicates/out_pval_bw"
      ],
      "sbg:fileTypes": "BIGWIG",
      "type": "File?",
      "label": "P-value bigWig bio-replicates",
      "doc": "P-value bigWig file.",
      "sbg:x": -285.4384765625,
      "sbg:y": -2514.341796875
    },
    {
      "id": "out_br_fc_bw",
      "outputSource": [
        "macs2_signal_track_bio_replicates/out_fc_bw"
      ],
      "sbg:fileTypes": "BIGWIG",
      "type": "File?",
      "label": "FC bigWig bio-replicates",
      "doc": "Fold-change bigWig file.",
      "sbg:x": -600.0407104492188,
      "sbg:y": -2505.819091796875
    },
    {
      "id": "out_pool_peak",
      "outputSource": [
        "call_peak_pooled_replicates/out_peak"
      ],
      "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ",
      "type": "File?",
      "label": "Peak pooled replicates",
      "doc": "Generated by encode_task_macs2_atac.py.",
      "sbg:x": 2.5411901473999023,
      "sbg:y": -2512.01025390625
    },
    {
      "id": "out_pool_pval_bw",
      "outputSource": [
        "macs2_signal_track_pooled_replicates/out_pval_bw"
      ],
      "sbg:fileTypes": "BIGWIG",
      "type": "File?",
      "label": "P-value bigWig pooled replicates",
      "doc": "P-value bigWig file.",
      "sbg:x": -297.6988830566406,
      "sbg:y": -2389.7041015625
    },
    {
      "id": "out_pool_fc_bw",
      "outputSource": [
        "macs2_signal_track_pooled_replicates/out_fc_bw"
      ],
      "sbg:fileTypes": "BIGWIG",
      "type": "File?",
      "label": "FC bigWig pooled replicates",
      "doc": "Fold-change bigWig file.",
      "sbg:x": -6.091563701629639,
      "sbg:y": -2406.3369140625
    },
    {
      "id": "out_bfilt_overlap_peak",
      "outputSource": [
        "overlap_bio_replicates/out_bfilt_overlap_peak"
      ],
      "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ",
      "type": "File?",
      "label": "Blacklist-filtered overlap peak",
      "doc": "Blacklist-filtered overlap peak (BigBed).",
      "sbg:x": 684.1434326171875,
      "sbg:y": -2420.86474609375
    },
    {
      "id": "out_bfilt_idr_peak",
      "outputSource": [
        "idr_bio_replicates/out_bfilt_idr_peak"
      ],
      "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ",
      "type": "File?",
      "label": "Blacklist-filtered IDR peak",
      "doc": "Blacklist-filtered IDR peak.",
      "sbg:x": 685.3143310546875,
      "sbg:y": -2299.52294921875
    },
    {
      "id": "out_overlap_optimal_peak",
      "outputSource": [
        "reproducibility_overlap/out_optimal_peak"
      ],
      "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ",
      "type": "File?",
      "label": "Optimal peak overlap",
      "doc": "Optimal peak.",
      "sbg:x": 689.52685546875,
      "sbg:y": -2138.78125
    },
    {
      "id": "out_idr_optimal_peak",
      "outputSource": [
        "reproducibility_idr/out_optimal_peak"
      ],
      "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ",
      "type": "File?",
      "label": "Optimal peak idr",
      "doc": "Optimal peak.",
      "sbg:x": 705.0939331054688,
      "sbg:y": -1779.2344970703125
    }
  ],
  "steps": [
    {
      "id": "align_controls",
      "in": [
        {
          "id": "in_fastqs",
          "source": [
            "sbg_pair_fastqs_by_metadata_controls/tuple_list"
          ]
        },
        {
          "id": "in_reference_fasta",
          "source": "in_reference"
        },
        {
          "id": "trim_bp",
          "source": "trim_bp"
        },
        {
          "id": "crop_length",
          "source": "crop_length"
        },
        {
          "id": "crop_length_tol",
          "source": "crop_length_tol"
        },
        {
          "id": "trimmomatic_phred_score_format",
          "source": "trimmomatic_phred_score_format"
        },
        {
          "id": "aligner",
          "source": "aligner"
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        },
        {
          "id": "custom_align_py",
          "source": "custom_align_py"
        },
        {
          "id": "idx_tar",
          "source": "in_index"
        },
        {
          "id": "paired_end",
          "source": "ctl_paired_end"
        },
        {
          "id": "use_bwa_mem_for_pe",
          "source": "use_bwa_mem_for_pe"
        },
        {
          "id": "trimmomatic_java_heap",
          "source": "trimmomatic_java_heap"
        },
        {
          "id": "mem_factor",
          "source": "mem_factor"
        }
      ],
      "out": [
        {
          "id": "out_bam"
        },
        {
          "id": "out_samstat_qc"
        },
        {
          "id": "out_read_len_log"
        },
        {
          "id": "out_align_log"
        },
        {
          "id": "out_read_len"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-align-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_fastqs",
            "type": "File[]?",
            "label": "FASTQ files",
            "doc": "Input FASTQs to be merged for all provided biological replicates. Both Read1 and Read2 files should be provided to the same input.",
            "sbg:fileTypes": "FASTQ.GZ, FASTQ, FQ, FQ.GZ"
          },
          {
            "sbg:category": "Inputs",
            "id": "in_reference_fasta",
            "type": "File",
            "label": "Reference genome",
            "doc": "Reference FASTA file.",
            "sbg:fileTypes": "FA, FASTA, FA.GZ, FASTA.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "50",
            "id": "trim_bp",
            "type": "int?",
            "label": "Trim bp",
            "doc": "Trim experiment read1 FASTQ (for both SE and PE) for cross-correlation analysis. This does not affect alignment of experimental/control replicates. Pipeline additionaly aligns R1 FASTQ only for cross-correlation analysis only. This parameter is used for it.",
            "default": null
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "0",
            "id": "crop_length",
            "type": "int?",
            "label": "Crop FASTQs",
            "doc": "Crop FASTQ reads longer than this length. Also drop all reads shorter than crop_length - crop_length_tol.",
            "default": 0
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "2",
            "id": "crop_length_tol",
            "type": "int?",
            "label": "Crop FASTQs tolerance",
            "doc": "Tolerance for cropping reads in FASTQs. Drop all reads shorter than chip.crop_length - chip.crop_length_tol. Activated only when chip.crop_length is defined.",
            "default": 2
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "auto",
            "id": "trimmomatic_phred_score_format",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "auto",
                  "phred33",
                  "phred64"
                ],
                "name": "trimmomatic_phred_score_format"
              }
            ],
            "label": "Phred score encoding",
            "doc": "Base encoding format for Phred score in FASTQs. This is used for Trimmomatic only. It is auto by default, which means that Trimmomatic automatically detect it from FASTQs. Otherwise -phred33 or -phred64 will be passed to the Trimmomatic command line. Use this if you see an error like \"Error: Unable to detect quality encoding\".",
            "default": "auto"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "bowtie2",
            "id": "aligner",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "custom",
                  "bowtie2",
                  "bwa"
                ],
                "name": "aligner"
              }
            ],
            "label": "Aligner",
            "doc": "Aligner to be used in the alignment step. To use a custom aligner, define chip.custom_align_py and chip.custom_aligner_idx_tar.",
            "default": "bowtie2"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "None",
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial reads defined here will be filtered out during filtering BAMs in \"filter\" task. e.g. chrM, MT."
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "None",
            "id": "multimapping",
            "type": "int?",
            "label": "Multimapping [bowtie2 option]",
            "doc": "multimapping",
            "default": 0
          },
          {
            "sbg:category": "Inputs",
            "id": "custom_align_py",
            "type": "File?",
            "label": "Custom aligner script",
            "doc": "Python script for a custom aligner.",
            "sbg:fileTypes": "PY"
          },
          {
            "sbg:category": "Inputs",
            "id": "idx_tar",
            "type": "File",
            "label": "Index TAR",
            "doc": "Index TAR file.",
            "sbg:fileTypes": "TAR, TAR.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness. Setting this on means that all replicates are paired ended.",
            "default": null
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "use_bwa_mem_for_pe",
            "type": "boolean?",
            "label": "Use bwa mem",
            "doc": "For paired end dataset with read length >= 70bp, use bwa mem instead of bwa aln.",
            "default": false
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.9",
            "id": "trimmomatic_java_heap",
            "type": "float?",
            "label": "Trimmomatic max memory",
            "doc": "Maximum memory for Trimmomatic. If not defined, 90% of align task's memory will be used.",
            "default": 0.9
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "6",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPU cores",
            "doc": "Number of CPU cores",
            "default": 6
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.15",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory factor",
            "doc": "Multiplication factor to determine memory required for task. This factor will be multiplied to the size of FASTQs to determine required memory of instance or job.\nThe default value for Bowtie2 aligner is 0.15, and 0.3 for BWA aligner."
          }
        ],
        "outputs": [
          {
            "id": "out_bam",
            "doc": "Output BAM file.",
            "label": "Output BAM",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam",
              "outputEval": "$(inheritMetadata(self, inputs.in_fastqs))"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              }
            ],
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "out_samstat_qc",
            "doc": "Samstat QC.",
            "label": "Samstat QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.samstats.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "out_read_len_log",
            "doc": "Output read length TXT file.",
            "label": "Read length",
            "type": "File?",
            "outputBinding": {
              "glob": "*.read_length.txt"
            },
            "sbg:fileTypes": "TXT"
          },
          {
            "id": "out_align_log",
            "doc": "Align tool output log file",
            "label": "Output log",
            "type": "File?",
            "outputBinding": {
              "glob": "out.log"
            },
            "sbg:fileTypes": "LOG"
          },
          {
            "id": "out_read_len",
            "doc": "Output read length value.",
            "label": "Read length",
            "type": "int?",
            "outputBinding": {
              "loadContents": true,
              "glob": "*.read_length.txt",
              "outputEval": "${\n    if(inputs.in_fastqs){\n        var read_len = parseInt(self[0].contents)\n        return read_len\n    }\n}"
            }
          }
        ],
        "doc": "* **Align** tool is based on the \u201calign\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n* The tool first checks if the tool/pipeline dependencies can be found and if not, raises an error.\n* Then, the \u201cencode_task_merge_fastq.py\u201d script is executed, which merges all fastq files on input Read 1 to R1, and all fastq files on input Read 2 to R2.\n* After that the \"encode_task_trim_fastq.py\" is used to trim the merged fastq file by a provided number of bp, after which the fastqs are cropped using \"encode_task_trimmomatic.py\" script, which crops FASTQs reads longer than the given length.\n* The main step of this tool is the alignment step, for which the user can choose Bowtie2 or BWA aligner, or even provide a custom python script.\n* In the final step, the \u201cencode_task_post_align.py\u201d script is called, which generates the read length file, indexes the previously generated BAM file with Samtools Index v1.9, runs SAMStat v0.2.1 in order to generate sequence statistics.",
        "label": "ENCODE ChIP-Seq Align CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    if (inputs.in_fastqs) return \"( bash align_chip_seq.sh ) > out.log\";\n    else return \"echo \\'No input FASTQ files provided \\' 1>&2 \";\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    \n      // define CPU and memory requirements\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var fastq_size = Array();\n  \n    if (inputs.in_fastqs){\n        for ( var i = 0; i < inputs.in_fastqs.length; i++) fastq_size.push(inputs.in_fastqs[i].size);\n    \n    }\n    \n    \n    \n    fastq_size = arrSum(fastq_size);\n    \n    \n    var mem_factor=0.15;\n    if (inputs.mem_factor) mem_factor=inputs.mem_factor;\n    else if (inputs.aligner=='bowtie2') mem_factor=0.15;\n    else if (inputs.aligner=='bwa') mem_factor=0.3;\n    \n    var input_file_size_gb = (fastq_size)/1e+9;\n    var mem_gb = 5.0 + mem_factor * input_file_size_gb;\n   \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              {
                "entryname": "align_chip_seq.sh",
                "entry": "${\n    \n     // define CPU and memory requirements\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var fastq_size = Array();\n  \n    if(inputs.in_fastqs){\n        for ( var i = 0; i < inputs.in_fastqs.length; i++) fastq_size.push(inputs.in_fastqs[i].size);\n    \n    }\n    \n    \n    fastq_size = arrSum(fastq_size);\n    \n    \n    var mem_factor=0.15;\n    if (inputs.mem_factor) mem_factor=inputs.mem_factor;\n    else if (inputs.aligner=='bowtie2') mem_factor=0.15;\n    else if (inputs.aligner=='bwa') mem_factor=0.3;\n    \n    var input_file_size_gb = (fastq_size)/1e+9;\n    var mem_gb = 5.0 + mem_factor * input_file_size_gb;\n    var samtools_mem_gb = 0.8 * mem_gb;\n    \n    return '\\\n    #!/bin/bash\\n\\\n    #\\n\\\n    set -e\\n\\\n    # check if pipeline dependencies can be found\\n\\\n    if [[ -z \"$(which encode_task_merge_fastq.py 2> /dev/null || true)\" ]]\\n\\\n    then\\n\\\n    echo -e \"\\\\n* Error: pipeline dependencies not found.\" 1>&2\\n\\\n    echo \"Conda users: Did you activate Conda environment (conda activate encode-chip-seq-pipeline)?\" 1>&2\\n\\\n    echo \"Or did you install Conda and environment correctly (bash scripts/install_conda_env.sh)?\" 1>&2\\n\\\n    echo \"GCP/AWS/Docker users: Did you add --docker flag to Caper command line arg?\" 1>&2\\n\\\n    echo \"Singularity users: Did you add --singularity flag to Caper command line arg?\" 1>&2\\n\\\n    echo -e \"\\\\n\" 1>&2\\n\\\n    exit 3\\n\\\n    fi\\n\\\n    \\n\\\n    python3 $(which encode_task_merge_fastq.py) \\\\\\n\\\n    tmp_fastqs.tsv \\\\\\n\\\n    ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n    --nth ' + inputs.cpu + ' \\n\\\n    \\n\\\n    if [ ' + inputs.trim_bp + ' == \\'null\\' ]; then \\n\\\n        SUFFIX= \\n\\\n    else \\n\\\n        SUFFIX=_trimmed\\n\\\n        python3 $(which encode_task_trim_fastq.py) \\\\\\n\\\n            R1/*.fastq.gz \\\\\\n\\\n            --trim-bp ' + inputs.trim_bp + ' \\\\\\n\\\n            --out-dir R1$SUFFIX \\n\\\n        if [ ' + inputs.paired_end + ' == \\'true\\' ]; then \\n\\\n            python3 $(which encode_task_trim_fastq.py) \\\\\\n\\\n            R2/*.fastq.gz \\\\\\n\\\n            --trim-bp ' + inputs.trim_bp + ' \\\\\\n\\\n            --out-dir R2$SUFFIX \\n\\\n        fi\\n\\\n    fi\\n\\\n    if [ \\'' + inputs.crop_length + '\\' == \\'0\\' ]; then\\n\\\n            SUFFIX=$SUFFIX\\n\\\n    else\\n\\\n        NEW_SUFFIX=\"$SUFFIX\"_cropped\\n\\\n        python3 $(which encode_task_trimmomatic.py) \\\\\\n\\\n            --fastq1 R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"--fastq2 R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            --crop-length ' + inputs.crop_length + ' \\\\\\n\\\n            --crop-length-tol ' + inputs.crop_length_tol + ' \\\\\\n\\\n            --phred-score-format ' + inputs.trimmomatic_phred_score_format + ' \\\\\\n\\\n            --out-dir-R1 R1$NEW_SUFFIX \\\\\\n\\\n            ' + (inputs.paired_end ? \"--out-dir-R2 R2$NEW_SUFFIX\" : \"\") + ' \\\\\\n\\\n            --trimmomatic-java-heap ' + ( inputs.trimmomatic_java_heap ? inputs.trimmomatic_java_heap : Math.round(mem_gb * 0.9)) + 'G \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n        SUFFIX=$NEW_SUFFIX \\n\\\n    fi\\n\\\n    if [ ' + inputs.aligner + ' == \\'bwa\\' ]; then \\n\\\n        python3 $(which encode_task_bwa.py) \\\\\\n\\\n            ' + inputs.idx_tar.path + ' \\\\\\n\\\n            R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.use_bwa_mem_for_pe ? \"--use-bwa-mem-for-pe\" : \"\") + ' \\\\\\n\\\n            --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n    \\n\\\n    elif [ ' + inputs.aligner + ' == \\'bowtie2\\' ]; then \\n\\\n        python3 $(which encode_task_bowtie2.py) \\\\\\n\\\n            ' + inputs.idx_tar.path + ' \\\\\\n\\\n            R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            --multimapping ' + inputs.multimapping + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n    else \\n\\\n        python3 ${custom_align_py} \\\\\\n\\\n            ' + inputs.idx_tar.path + ' \\\\\\n\\\n            R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n    fi\\n\\\n    python3 $(which encode_task_post_align.py) \\\\\\n\\\n        R1$SUFFIX/*.fastq.gz $(ls *.bam) \\\\\\n\\\n        --mito-chr-name ' + inputs.mito_chr_name + ' \\\\\\n\\\n        --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n        --nth ' + inputs.cpu + ' \\n\\\n    rm -rf R1 R2 R1$SUFFIX R2$SUFFIX \\n\\\n    '\n}",
                "writable": false
              },
              {
                "entryname": "tmp_fastqs.tsv",
                "entry": "${\n    // wdl functions\n    function transpose(matrix) {\n        var rows = matrix.length, cols = matrix[0].length;\n        var grid = [];\n        for (var j = 0; j < cols; j++) {\n            grid[j] = Array(rows);\n        }\n        for (var i = 0; i < rows; i++) {\n        for (var j = 0; j < cols; j++) {\n            grid[j][i] = matrix[i][j];\n        }\n    }\n    return grid;  \n    }\n    \n    var fastq1 = Array();\n    var fastq2 = Array();\n    var ind1=0;\n    var ind2=0;\n    \n    if(inputs.in_fastqs){\n        var fq=[].concat(inputs.in_fastqs)\n    \n        for (var i=0; i < fq.length; i++){\n            if (fq[i].metadata['paired_end']=='1'){\n                ind1=fq[i].metadata['case_id'];\n                fastq1[ind1-1]=fq[i].path;\n            } \n            else if (fq[i].metadata['paired_end']=='2'){\n                ind2=fq[i].metadata['case_id']\n                fastq2[ind2-1]=fq[i].path;\n            }\n            else{\n                ind1=fq[i].metadata['case_id'];\n                fastq1[ind1-1]=fq[i].path;\n            } \n        }\n        \n    }\n    \n    \n   \n    var tmp_fastqs = inputs.paired_end ? transpose([fastq1, fastq2]) : transpose([fastq1])\n    return tmp_fastqs.map(function(d){ return d.join('\\t');\n        }).join('\\n');\n}",
                "writable": false
              }
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619210816,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619210908,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-c5d36fb2/h-e487225f/h-3c1626dc/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619210908,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619210816,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "abcbf41df2dbc3ef764a1bc4fef54a74759d6cb298de35081452033be49bb1690"
      },
      "label": "Align Controls",
      "scatter": [
        "in_fastqs"
      ],
      "sbg:x": -2593.98583984375,
      "sbg:y": -2045.309814453125
    },
    {
      "id": "sbg_pair_fastqs_by_metadata_controls",
      "in": [
        {
          "id": "fastq_list",
          "source": [
            "in_ctl_reads"
          ]
        }
      ],
      "out": [
        {
          "id": "tuple_list"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/sbg-pair-fastqs-by-metadata/1",
        "baseCommand": [
          "echo"
        ],
        "inputs": [
          {
            "id": "fastq_list",
            "type": "File[]?",
            "label": "List of FASTQ files",
            "doc": "List of the FASTQ files with properly set metadata fileds.",
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ"
          }
        ],
        "outputs": [
          {
            "id": "tuple_list",
            "doc": "List of grouped FASTQ files by metadata fields.",
            "label": "List of grouped FASTQ files",
            "type": "File[]?",
            "outputBinding": {
              "outputEval": "${\n  function get_meta_map(m, file, meta) {\n    if (meta in file.metadata) {\n      return m[file.metadata[meta]];\n    } else {\n      return m['Undefined'];\n    }\n  }\n  \n  function create_new_map(map, file, meta) {\n    if (meta in file.metadata) {\n      map[file.metadata[meta]] = {};\n      return map[file.metadata[meta]];\n    } else {\n      map['Undefined'] = {};\n      return map['Undefined'];\n    }\n  }\n  \n  if (inputs.fastq_list) {\n    \n    var arr = [].concat(inputs.fastq_list);\n    var map = {};\n    \n    for (var i in arr) {\n      \n      var sm_map = get_meta_map(map, arr[i], 'sample_id');\n      if (!sm_map) sm_map = create_new_map(map, arr[i], 'sample_id');\n      \n      var lb_map = get_meta_map(sm_map, arr[i], 'library_id');\n      if (!lb_map) lb_map = create_new_map(sm_map, arr[i], 'library_id');\n      \n      var pu_map = get_meta_map(lb_map, arr[i], 'platform_unit_id');\n      if (!pu_map) pu_map = create_new_map(lb_map, arr[i], 'platform_unit_id');\n      \n      var a = '';\n      var ar = '';\n      \n      if ('file_segment_number' in arr[i].metadata) {\n        if (pu_map[arr[i].metadata['file_segment_number']]) {\n          a = pu_map[arr[i].metadata['file_segment_number']];\n          ar = [].concat(a);\n          ar = ar.concat(arr[i]);\n          pu_map[arr[i].metadata['file_segment_number']] = ar;\n        } else {\n          pu_map[arr[i].metadata['file_segment_number']] = [].concat(arr[i]);\n        }\n      } else {\n        if (pu_map['Undefined']) {\n          a = pu_map['Undefined'];\n          ar = [].concat(a);\n          ar = ar.concat(arr[i]);\n          pu_map['Undefined'] = ar;\n        } else {\n          pu_map['Undefined'] = [].concat(arr[i]);\n        }\n      }\n    }\n    var tuple_list = [];\n    var list;\n    for (var sm in map)\n      for (var lb in map[sm])\n        for (var pu in map[sm][lb]) {\n          for (var fsm in map[sm][lb][pu]) {\n            list = map[sm][lb][pu][fsm];\n            tuple_list.push(list);\n          }\n        }\n    return tuple_list;\n  }\n}"
            },
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ"
          }
        ],
        "doc": "Tool accepts list of FASTQ files groups them into separate lists. This grouping is done using metadata values and their hierarchy (Sample ID > Library ID > Platform unit ID > File segment number) which should create unique combinations for each pair of FASTQ files. Important metadata fields are Sample ID, Library ID, Platform unit ID and File segment number. Not all of these four metadata fields are required, but the present set has to be sufficient to create unique combinations for each pair of FASTQ files. Files with no paired end metadata are grouped in the same way as the ones with paired end metadata, generally they should be alone in a separate list. Files with no metadata set will be grouped together. \n\nIf there are more than two files in a group, this might create errors further down most pipelines and the user should check if the metadata fields for those files are set properly.",
        "label": "SBG Pair FASTQs by Metadata",
        "arguments": [
          {
            "shellQuote": false,
            "position": 0,
            "valueFrom": "'Pairing"
          },
          {
            "shellQuote": false,
            "position": 1,
            "valueFrom": "FASTQs!'"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": 1024,
            "coresMin": 1
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "d41a0837ab81",
            "dockerPull": "images.sbgenomics.com/nikola_jovanovic/alpine:1"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.fastq_list)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
            ]
          }
        ],
        "sbg:image_url": null,
        "sbg:license": "Apache License 2.0",
        "sbg:toolkit": "SBGTools",
        "sbg:cmdPreview": "echo 'Pairing FASTQs!'",
        "sbg:categories": [
          "Converters",
          "Other"
        ],
        "sbg:toolAuthor": "",
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619214989,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619215010,
            "sbg:revisionNotes": "upgrade to cwl1.1"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-179ff0e9/h-fd6dea14/h-2626ef77/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "upgrade to cwl1.1",
        "sbg:modifiedOn": 1619215010,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619214989,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a95b1533cafe255545a58aa4155d9d923c9a424cff733512a580cfc3d70b44d56"
      },
      "label": "SBG Pair FASTQs by Metadata",
      "sbg:x": -2892.443603515625,
      "sbg:y": -1968.211181640625
    },
    {
      "id": "qc_report",
      "in": [
        {
          "id": "pipeline_ver",
          "source": "pipeline_ver"
        },
        {
          "id": "title",
          "source": "title"
        },
        {
          "id": "description",
          "source": "description"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        },
        {
          "id": "aligner",
          "source": "aligner"
        },
        {
          "id": "peak_caller",
          "source": "peak_caller"
        },
        {
          "id": "xcor_subsample_reads",
          "source": "subsample"
        },
        {
          "id": "in_samstat_qcs",
          "source": [
            "align_bio_replicates/out_samstat_qc"
          ]
        },
        {
          "id": "in_nodup_samstat_qcs",
          "source": [
            "filter_bio_replicates/out_samstat_qc"
          ]
        },
        {
          "id": "in_dup_qcs",
          "source": [
            "filter_bio_replicates/out_dup_qc"
          ]
        },
        {
          "id": "in_lib_complexity_qcs",
          "source": [
            "filter_bio_replicates/out_lib_complexity_qc"
          ]
        },
        {
          "id": "in_ctl_samstat_qcs",
          "source": [
            "align_controls/out_samstat_qc"
          ]
        },
        {
          "id": "in_ctl_nodup_samstat_qcs",
          "source": [
            "filter_controls/out_samstat_qc"
          ]
        },
        {
          "id": "in_ctl_dup_qcs",
          "source": [
            "filter_controls/out_dup_qc"
          ]
        },
        {
          "id": "in_ctl_lib_complexity_qcs",
          "source": [
            "filter_controls/out_lib_complexity_qc"
          ]
        },
        {
          "id": "in_xcor_plots",
          "source": [
            "xcor/plot_png"
          ]
        },
        {
          "id": "in_xcor_scores",
          "source": [
            "xcor/score"
          ]
        },
        {
          "id": "in_jsd_plot",
          "source": "jsd/out_plot"
        },
        {
          "id": "in_jsd_qcs",
          "source": [
            "jsd/out_jsd_qcs"
          ]
        },
        {
          "id": "in_idr_plots",
          "source": [
            "idr_bio_replicates/idr_plot"
          ]
        },
        {
          "id": "in_idr_plots_pr",
          "source": [
            "idr_pr/idr_plot"
          ]
        },
        {
          "id": "in_idr_plot_ppr",
          "source": "idr_ppr/idr_plot"
        },
        {
          "id": "in_frip_qcs",
          "source": [
            "call_peak_bio_replicates/out_frip_qc"
          ]
        },
        {
          "id": "in_frip_qcs_pr1",
          "source": [
            "call_peak_pr1/out_frip_qc"
          ]
        },
        {
          "id": "in_frip_qcs_pr2",
          "source": [
            "call_peak_pr2/out_frip_qc"
          ]
        },
        {
          "id": "in_frip_qc_pooled",
          "source": "call_peak_pooled_replicates/out_frip_qc"
        },
        {
          "id": "in_frip_qc_ppr1",
          "source": "call_peak_ppr1/out_frip_qc"
        },
        {
          "id": "in_frip_qc_ppr2",
          "source": "call_peak_ppr2/out_frip_qc"
        },
        {
          "id": "in_frip_idr_qcs",
          "source": [
            "idr_bio_replicates/frip_qc"
          ]
        },
        {
          "id": "in_frip_idr_qcs_pr",
          "source": [
            "idr_pr/frip_qc"
          ]
        },
        {
          "id": "in_frip_idr_qc_ppr",
          "source": "idr_ppr/frip_qc"
        },
        {
          "id": "in_frip_overlap_qcs",
          "source": [
            "overlap_bio_replicates/out_frip_qc"
          ]
        },
        {
          "id": "in_frip_overlap_qcs_pr",
          "source": [
            "overlap_pr/out_frip_qc"
          ]
        },
        {
          "id": "in_frip_overlap_qc_ppr",
          "source": "overlap_ppr/out_frip_qc"
        },
        {
          "id": "in_idr_reproducibility_qc",
          "source": "reproducibility_idr/reproducibility_qc"
        },
        {
          "id": "in_overlap_reproducibility_qc",
          "source": "reproducibility_overlap/reproducibility_qc"
        },
        {
          "id": "in_gc_plots",
          "source": [
            "gc_bias/gc_plot"
          ]
        },
        {
          "id": "in_peak_region_size_qcs",
          "source": [
            "call_peak_bio_replicates/out_peak_region_size_qc"
          ]
        },
        {
          "id": "in_peak_region_size_plots",
          "source": [
            "call_peak_bio_replicates/out_peak_region_size_plot"
          ]
        },
        {
          "id": "in_num_peak_qcs",
          "source": [
            "call_peak_bio_replicates/out_num_peak_qc"
          ]
        },
        {
          "id": "in_idr_opt_peak_region_size_qc",
          "source": "reproducibility_idr/peak_region_size_qc"
        },
        {
          "id": "in_idr_opt_peak_region_size_plot",
          "source": "reproducibility_idr/peak_region_size_plot"
        },
        {
          "id": "in_idr_opt_num_peak_qc",
          "source": "reproducibility_idr/num_peak_qc"
        },
        {
          "id": "in_overlap_opt_peak_region_size_qc",
          "source": "reproducibility_overlap/peak_region_size_qc"
        },
        {
          "id": "in_overlap_opt_peak_region_size_plot",
          "source": "reproducibility_overlap/peak_region_size_plot"
        },
        {
          "id": "in_overlap_opt_num_peak_qc",
          "source": "reproducibility_overlap/num_peak_qc"
        }
      ],
      "out": [
        {
          "id": "out_report"
        },
        {
          "id": "out_qc_json"
        },
        {
          "id": "out_qc_json_ref_match"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-qc-report-1-7-1-cwl1-1/2",
        "baseCommand": [
          "python3 $(which encode_task_qc_report.py)"
        ],
        "inputs": [
          {
            "sbg:category": "optional metadata",
            "id": "pipeline_ver",
            "type": "string?",
            "inputBinding": {
              "prefix": "--pipeline-ver",
              "shellQuote": false,
              "position": 1
            },
            "label": "Pipeline version",
            "doc": "Pipeline metadata. Current version: 1.7.1.",
            "default": "v1.7.1"
          },
          {
            "sbg:category": "optional metadata",
            "id": "title",
            "type": "string?",
            "inputBinding": {
              "prefix": "--title",
              "shellQuote": false,
              "position": 2,
              "valueFrom": "${\n    //--title\n    if(inputs.title){\n        var title = inputs.title;\n        return \"'\" + title.replace(\"'\", \"_\")  + \"'\"\n    }\n}"
            },
            "label": "Title",
            "doc": "Metadata for a pipeline (e.g. title and description). Default, 'Untitled'.",
            "default": "Untitled"
          },
          {
            "sbg:category": "optional metadata",
            "id": "description",
            "type": "string?",
            "inputBinding": {
              "prefix": "--desc",
              "shellQuote": false,
              "position": 3,
              "valueFrom": "${\n    //--desc\n    if (inputs.description){\n        return \"'\" + inputs.description.replace(\"'\", \"_\")  + \"'\"\n    }\n}"
            },
            "label": "Description",
            "doc": "Metadata for a pipeline (e.g. title and description). Default, 'No description'.",
            "default": "No description"
          },
          {
            "sbg:category": "optional metadata",
            "id": "genome",
            "type": "string?",
            "inputBinding": {
              "prefix": "--genome",
              "shellQuote": false,
              "position": 4
            },
            "label": "Genome",
            "doc": "Genome name."
          },
          {
            "sbg:category": "workflow params",
            "id": "paired_ends",
            "type": "boolean[]?",
            "inputBinding": {
              "prefix": "--paired-ends",
              "shellQuote": false,
              "position": 6
            },
            "label": "Paired ends",
            "doc": "Sequencing endedness array for mixed SE/PE datasets (whether each biological replicate is paired ended or not)."
          },
          {
            "sbg:category": "workflow params",
            "id": "ctl_paired_ends",
            "type": "boolean[]?",
            "inputBinding": {
              "prefix": "--ctl-paired-ends",
              "shellQuote": false,
              "position": 7
            },
            "label": "Control replicate paired ends",
            "doc": "Sequencing endedness array for mixed SE/PE controls (whether each control replicate is paired ended or not)"
          },
          {
            "sbg:category": "workflow params",
            "sbg:toolDefaultValue": "tf",
            "id": "pipeline_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "tf",
                  "histone",
                  "control"
                ],
                "name": "pipeline_type"
              }
            ],
            "inputBinding": {
              "prefix": "--pipeline-type",
              "shellQuote": false,
              "position": 8
            },
            "label": "Pipeline type",
            "doc": "Default peak caller is different for each type. For TF ChIP-Seq it's spp and macs2 for histone ChIP-Seq. Regardless of pipeline type, spp always requires controls but macs2 doesn't. For control mode, chip.align_only is automatically turned on and cross-correlation analysis is disabled. Do not define ctl_* for control mode., define fastqs_repX_RY instead.",
            "default": "tf"
          },
          {
            "sbg:category": "alignment params",
            "sbg:toolDefaultValue": "bowtie2",
            "id": "aligner",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "bowtie2",
                  "bwa"
                ],
                "name": "aligner"
              }
            ],
            "inputBinding": {
              "prefix": "--aligner",
              "shellQuote": false,
              "position": 9
            },
            "label": "Aligner",
            "doc": "Select bowtie2 or bwa to perform alignment. Bowtie2 is default.",
            "default": "bowtie2"
          },
          {
            "sbg:category": "peak calling params",
            "sbg:altPrefix": "macs2",
            "id": "peak_caller",
            "type": "string?",
            "inputBinding": {
              "prefix": "--peak-caller",
              "shellQuote": false,
              "position": 10
            },
            "label": "Peak caller",
            "doc": "It is spp and macs2 by default for TF ChIP-seq and histone ChIP-seq, respectively.",
            "default": "macs2"
          },
          {
            "sbg:category": "peak calling params",
            "id": "cap_num_peak",
            "type": "int?",
            "inputBinding": {
              "prefix": "--cap-num-peak",
              "shellQuote": false,
              "position": 11
            },
            "label": "Peak limit",
            "doc": "Upper limit on the number of peaks. It is 30000000 and 50000000 by default for spp and macs2, respectively."
          },
          {
            "sbg:category": "peak calling params",
            "sbg:toolDefaultValue": "0,05",
            "id": "idr_thresh",
            "type": "float?",
            "inputBinding": {
              "prefix": "--idr-thresh",
              "shellQuote": false,
              "position": 12
            },
            "label": "IDR threshold",
            "doc": "Define IDR threshold.",
            "default": 0.05
          },
          {
            "sbg:category": "peak calling params",
            "sbg:toolDefaultValue": "0,01",
            "id": "pval_thresh",
            "type": "float?",
            "inputBinding": {
              "prefix": "--pval-thresh",
              "shellQuote": false,
              "position": 13
            },
            "label": "P-value threshold",
            "doc": "P-value Threshold for MACS2 peak caller.",
            "default": 0.01
          },
          {
            "sbg:category": "alignment params",
            "sbg:toolDefaultValue": "50",
            "id": "xcor_trim_bp",
            "type": "int?",
            "inputBinding": {
              "prefix": "--xcor-trim-bp",
              "shellQuote": false,
              "position": 14
            },
            "label": "Trim experiment read1 FASTQ for cross-correlation analysis",
            "doc": "Trim experiment read1 FASTQ (for both SE and PE) for cross-correlation analysis. This does not affect alignment of experimental/control replicates. Pipeline additionally aligns R1 FASTQ only for cross-correlation analysis only. This parameter is used for it.",
            "default": 50
          },
          {
            "sbg:category": "alignment params",
            "sbg:toolDefaultValue": "15000000",
            "id": "xcor_subsample_reads",
            "type": "int?",
            "inputBinding": {
              "prefix": "--xcor-subsample-reads",
              "shellQuote": false,
              "position": 15
            },
            "label": "Subsample reads for cross-correlation analysis",
            "doc": "Subsample reads for cross-correlation analysis only. This does not affect downstream analyses after filtering BAM. It is for cross-correlation analysis only.  0 means disabled.",
            "default": 15000000
          },
          {
            "sbg:category": "qc",
            "id": "in_samstat_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--samstat-qcs",
              "shellQuote": false,
              "position": 16,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_samstat_qcs.length; i++){\n        if(inputs.in_samstat_qcs[i]) vals.push(inputs.in_samstat_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Alignment samstat QCs",
            "doc": "Alignment samstat QC files."
          },
          {
            "sbg:category": "qc",
            "id": "in_nodup_samstat_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--nodup-samstat-qcs",
              "shellQuote": false,
              "position": 17,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_nodup_samstat_qcs.length; i++){\n        if (inputs.in_nodup_samstat_qcs[i]) vals.push(inputs.in_nodup_samstat_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Filter samstat QCs",
            "doc": "Filter samstat QC files."
          },
          {
            "sbg:category": "qc",
            "id": "in_dup_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--dup-qcs",
              "shellQuote": false,
              "position": 18,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_dup_qcs.length; i++){\n        if (inputs.in_dup_qcs[i]) vals.push(inputs.in_dup_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Filter duplication QCs",
            "doc": "Filter duplication QC files."
          },
          {
            "sbg:category": "qc",
            "id": "in_lib_complexity_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--lib-complexity-qcs",
              "shellQuote": false,
              "position": 19,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_lib_complexity_qcs.length; i++){\n        if (inputs.in_lib_complexity_qcs[i]) vals.push(inputs.in_lib_complexity_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Library complexity QCs",
            "doc": "Library complexity QC files."
          },
          {
            "sbg:category": "qc",
            "id": "in_ctl_samstat_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--ctl-samstat-qcs",
              "shellQuote": false,
              "position": 24,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_ctl_samstat_qcs.length; i++){\n        if (inputs.in_ctl_samstat_qcs[i]) vals.push(inputs.in_ctl_samstat_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Control replicate alignment samstat QCs",
            "doc": "Control replicate alignment samstat QC files."
          },
          {
            "sbg:category": "qc",
            "id": "in_ctl_nodup_samstat_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--ctl-nodup-samstat-qcs",
              "shellQuote": false,
              "position": 25,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_ctl_nodup_samstat_qcs.length; i++){\n        if (inputs.in_ctl_nodup_samstat_qcs[i]) vals.push(inputs.in_ctl_nodup_samstat_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Control replicate filter samstat QCs",
            "doc": "Control replicate filter samstat QC files."
          },
          {
            "sbg:category": "qc",
            "id": "in_ctl_dup_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--ctl-dup-qcs",
              "shellQuote": false,
              "position": 26,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_ctl_dup_qcs.length; i++){\n        if (inputs.in_ctl_dup_qcs[i]) vals.push(inputs.in_ctl_dup_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Control replicate filter duplication QCs",
            "doc": "Control replicate filter duplication QC files."
          },
          {
            "sbg:category": "qc",
            "id": "in_ctl_lib_complexity_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--ctl-lib-complexity-qcs",
              "shellQuote": false,
              "position": 27,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_ctl_lib_complexity_qcs.length; i++){\n        if (inputs.in_ctl_lib_complexity_qcs[i]) vals.push(inputs.in_ctl_lib_complexity_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Control replicate library complexity QCs",
            "doc": "Control replicate library complexity QC files."
          },
          {
            "sbg:category": "qc",
            "id": "in_xcor_plots",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--xcor-plots",
              "shellQuote": false,
              "position": 20,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_xcor_plots.length; i++){\n        if (inputs.in_xcor_plots[i]) vals.push(inputs.in_xcor_plots[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "XCOR plots",
            "doc": "Plots from XCOR tool.",
            "sbg:fileTypes": "PNG"
          },
          {
            "sbg:category": "qc",
            "id": "in_xcor_scores",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--xcor-scores",
              "shellQuote": false,
              "position": 21,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_xcor_scores.length; i++){\n        if (inputs.in_xcor_scores[i]) vals.push(inputs.in_xcor_scores[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Xcor quality scores",
            "doc": "Quality scores from Xcor tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_jsd_plot",
            "type": "File?",
            "inputBinding": {
              "prefix": "--jsd-plot",
              "shellQuote": false,
              "position": 28
            },
            "label": "Jsd plots",
            "doc": "Plots from Jsd tool.",
            "sbg:fileTypes": "PNG"
          },
          {
            "sbg:category": "qc",
            "id": "in_jsd_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--jsd-qcs",
              "shellQuote": false,
              "position": 29,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_jsd_qcs.length; i++){\n        if (inputs.in_jsd_qcs[i]) vals.push(inputs.in_jsd_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Jsd QCs",
            "doc": "QC files from Jsd tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_idr_plots",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--idr-plots",
              "shellQuote": false,
              "position": 22,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_idr_plots.length; i++){\n        if (inputs.in_idr_plots[i]) vals.push(inputs.in_idr_plots[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Idr plots",
            "doc": "Plots from Idr tool.",
            "sbg:fileTypes": "PNG"
          },
          {
            "sbg:category": "qc",
            "id": "in_idr_plots_pr",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--idr-plots-pr",
              "shellQuote": false,
              "position": 23,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_idr_plots_pr.length; i++){\n        if (inputs.in_idr_plots_pr[i]) vals.push(inputs.in_idr_plots_pr[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Pseduo replicate Idr plots",
            "doc": "Pseduo replicate plots from Idr tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_idr_plot_ppr",
            "type": "File?",
            "inputBinding": {
              "prefix": "--idr-plot-ppr",
              "shellQuote": false,
              "position": 30
            },
            "label": "Pooled pseudo replicate Idr plots",
            "doc": "Pooled pseudo replicate plots from Idr tools."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--frip-qcs",
              "shellQuote": false,
              "position": 31,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_frip_qcs.length; i++){\n        if (inputs.in_frip_qcs[i]) vals.push(inputs.in_frip_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "FRiP Call Peak QCs",
            "doc": "FRiP QC files from Call Peak tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_qcs_pr1",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--frip-qcs-pr1",
              "shellQuote": false,
              "position": 32,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_frip_qcs_pr1.length; i++){\n        if (inputs.in_frip_qcs_pr1[i]) vals.push(inputs.in_frip_qcs_pr1[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "FRiP pseudo replicate 1 Call Peak QCs",
            "doc": "FRiP pseudo replicate 1 QC files from Call Peak tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_qcs_pr2",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--frip-qcs-pr2",
              "shellQuote": false,
              "position": 33,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_frip_qcs_pr2.length; i++){\n        if (inputs.in_frip_qcs_pr2[i]) vals.push(inputs.in_frip_qcs_pr2[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "FRiP pseudo replicate 2 Call Peak QCs",
            "doc": "FRiP pseudo replicate 2 QC files from Call Peak tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_qc_pooled",
            "type": "File?",
            "inputBinding": {
              "prefix": "--frip-qc-pooled",
              "shellQuote": false,
              "position": 34
            },
            "label": "FRiP pooled pseudo replicate Call Peak QCs",
            "doc": "FRiP pooled pseudo replicate QC files from Call Peak tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_qc_ppr1",
            "type": "File?",
            "inputBinding": {
              "prefix": "--frip-qc-ppr1",
              "shellQuote": false,
              "position": 35
            },
            "label": "FRiP pooled pseudo replicate 1 Call Peak QCs",
            "doc": "FRiP pooled pseudo replicate 1 QC files from Call Peak tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_qc_ppr2",
            "type": "File?",
            "inputBinding": {
              "prefix": "--frip-qc-ppr2",
              "shellQuote": false,
              "position": 36
            },
            "label": "FRiP pooled pseudo replicate 2 Call Peak QCs",
            "doc": "FRiP pooled pseudo replicate 2 QC files from Call Peak tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_idr_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--frip-idr-qcs",
              "shellQuote": false,
              "position": 37,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_frip_idr_qcs.length; i++){\n        if (inputs.in_frip_idr_qcs[i]) vals.push(inputs.in_frip_idr_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "FRiP Idr QCs",
            "doc": "FRiP QC files from Idr tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_idr_qcs_pr",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--frip-idr-qcs-pr",
              "shellQuote": false,
              "position": 38,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_frip_idr_qcs_pr.length; i++){\n        if (inputs.in_frip_idr_qcs_pr[i]) vals.push(inputs.in_frip_idr_qcs_pr[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "FRiP pseudo replicate Idr QCs",
            "doc": "FRiP pseudo replicate QC files from Idr tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_idr_qc_ppr",
            "type": "File?",
            "inputBinding": {
              "prefix": "--frip-idr-qc-ppr",
              "shellQuote": false,
              "position": 39
            },
            "label": "FRiP pooled pseudo replicate Idr QCs",
            "doc": "FRiP pooled pseudo replicate QC files from Idr tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_overlap_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--frip-overlap-qcs",
              "shellQuote": false,
              "position": 40,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_frip_overlap_qcs.length; i++){\n        if (inputs.in_frip_overlap_qcs[i]) vals.push(inputs.in_frip_overlap_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "FRiP Overlap QCs",
            "doc": "FRiP QC files from Overlap tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_overlap_qcs_pr",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--frip-overlap-qcs-pr",
              "shellQuote": false,
              "position": 41,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_frip_overlap_qcs_pr.length; i++){\n        if (inputs.in_frip_overlap_qcs_pr[i]) vals.push(inputs.in_frip_overlap_qcs_pr[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "FRiP pseudo replicate QCs",
            "doc": "FRiP pseudo replicate QC files from Overlap tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_frip_overlap_qc_ppr",
            "type": "File?",
            "inputBinding": {
              "prefix": "--frip-overlap-qc-ppr",
              "shellQuote": false,
              "position": 42
            },
            "label": "FRiP pooled pseudo replicate QCs",
            "doc": "FRiP pooled pseudo replicate QC files from Overlap tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_idr_reproducibility_qc",
            "type": "File?",
            "inputBinding": {
              "prefix": "--idr-reproducibility-qc",
              "shellQuote": false,
              "position": 43
            },
            "label": "IDR Reproducibility QC",
            "doc": "IDR QC file from Reproducibility tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_overlap_reproducibility_qc",
            "type": "File?",
            "inputBinding": {
              "prefix": "--overlap-reproducibility-qc",
              "shellQuote": false,
              "position": 44
            },
            "label": "Overlap Reproducibility QC",
            "doc": "Overlap QC file from Reproducibility tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_gc_plots",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--gc-plots",
              "shellQuote": false,
              "position": 45,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_gc_plots.length; i++){\n        if (inputs.in_gc_plots[i]) vals.push(inputs.in_gc_plots[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "GC Plot",
            "doc": "GC plot from GC Bias tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_peak_region_size_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--peak-region-size-qcs",
              "shellQuote": false,
              "position": 46,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_peak_region_size_qcs.length; i++){\n        if (inputs.in_peak_region_size_qcs[i]) vals.push(inputs.in_peak_region_size_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Peak region size Call Peak QCs",
            "doc": "Peak region size QC files from Call Peak tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_peak_region_size_plots",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--peak-region-size-plots",
              "shellQuote": false,
              "position": 47,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_peak_region_size_plots.length; i++){\n        if (inputs.in_peak_region_size_plots[i]) vals.push(inputs.in_peak_region_size_plots[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Peak region size Call Peak plots",
            "doc": "Peak region size plots from Call Peak tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_num_peak_qcs",
            "type": "File[]?",
            "inputBinding": {
              "prefix": "--num-peak-qcs",
              "shellQuote": false,
              "position": 48,
              "valueFrom": "${\n    var vals = Array();\n    \n    for( var i = 0; i < inputs.in_num_peak_qcs.length; i++){\n        if (inputs.in_num_peak_qcs[i]) vals.push(inputs.in_num_peak_qcs[i].path);\n    }\n    return vals.join(\"_:_\");\n}"
            },
            "label": "Number of peaks Call Peak QCs",
            "doc": "Number of peaks QC files from Call Peak tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_idr_opt_peak_region_size_qc",
            "type": "File?",
            "inputBinding": {
              "prefix": "--idr-opt-peak-region-size-qc",
              "shellQuote": false,
              "position": 49
            },
            "label": "IDR peak region size Reproducibility QC",
            "doc": "IDR peak region size QC file from Reproducibility tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_idr_opt_peak_region_size_plot",
            "type": "File?",
            "inputBinding": {
              "prefix": "--idr-opt-peak-region-size-plot",
              "shellQuote": false,
              "position": 50
            },
            "label": "IDR peak region size Reproducibility plot",
            "doc": "IDR peak region size plot from Reproducibility tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_idr_opt_num_peak_qc",
            "type": "File?",
            "inputBinding": {
              "prefix": "--idr-opt-num-peak-qc",
              "shellQuote": false,
              "position": 51
            },
            "label": "IDR number of peaks Reproducibility QC",
            "doc": "IDR number of peaks QC file from Reproducibility tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_overlap_opt_peak_region_size_qc",
            "type": "File?",
            "inputBinding": {
              "prefix": "--overlap-opt-peak-region-size-qc",
              "shellQuote": false,
              "position": 52
            },
            "label": "Overlap peak region size Reproducibility plot",
            "doc": "Overlap peak region size QC file from Reproducibility tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_overlap_opt_peak_region_size_plot",
            "type": "File?",
            "inputBinding": {
              "prefix": "--overlap-opt-peak-region-size-plot",
              "shellQuote": false,
              "position": 53
            },
            "label": "Overlap peak region size plot from Reproducibility tool.",
            "doc": "Overlap peak region size plot from Reproducibility tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_overlap_opt_num_peak_qc",
            "type": "File?",
            "inputBinding": {
              "prefix": "--overlap-opt-num-peak-qc",
              "shellQuote": false,
              "position": 54
            },
            "label": "Overlap number of peaks Reproducibility QC",
            "doc": "Overlap number of peaks QC file from Reproducibility tool."
          },
          {
            "sbg:category": "qc",
            "id": "in_qc_json_ref",
            "type": "File?",
            "inputBinding": {
              "prefix": "--qc-json-ref",
              "shellQuote": false,
              "position": 57
            },
            "label": "Referential QC",
            "doc": "Referential QC in JSON format."
          }
        ],
        "outputs": [
          {
            "id": "out_report",
            "doc": "Output HTML report.",
            "label": "Output report",
            "type": "File?",
            "outputBinding": {
              "glob": "*qc.html"
            }
          },
          {
            "id": "out_qc_json",
            "doc": "Output QC in JSON format.",
            "label": "Output QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*qc.json"
            }
          },
          {
            "id": "out_qc_json_ref_match",
            "doc": "Does the Output QC match the Referential QC file.",
            "label": "Match",
            "type": "string?",
            "outputBinding": {
              "loadContents": true,
              "glob": "qc_json_ref_match.txt",
              "outputEval": "${\n    var read_file = self[0].contents\n    \n    if (read_file.indexOf(\"True\") != -1 && inputs.in_qc_json_ref) {\n        return 'True'    \n    }\n    else if (read_file.indexOf(\"False\") != -1 && inputs.in_qc_json_ref) {\n        return 'False'\n    }\n    else {\n        return 'No Reference QC JSON ...'\n    }\n}"
            }
          }
        ],
        "doc": "- QC Report collects and summarizes metrics and plots from the Align, Filter, XCOR, Call Peak, Idr, Overlap, Reproducibility and GC Bias tools for control replicates, pseudo replicates and pooled pseudo replicates.\n- Final report is given in form of a HTML report and JSON file\n- Additional check is made by comparing the Output QC JSON with the Referential QC given as input, returning the match value (True/False)",
        "label": "ENCODE ChIP-Seq QC Report CWL1.1",
        "arguments": [
          {
            "prefix": "--multimapping",
            "shellQuote": false,
            "position": 5,
            "valueFrom": "0"
          },
          {
            "prefix": "--out-qc-html",
            "shellQuote": false,
            "position": 55,
            "valueFrom": "qc.html"
          },
          {
            "prefix": "--out-qc-json",
            "shellQuote": false,
            "position": 56,
            "valueFrom": "qc.json"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619215530,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619215621,
            "sbg:revisionNotes": "from dev"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619428230,
            "sbg:revisionNotes": "referential qc report"
          }
        ],
        "sbg:image_url": null,
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-78c0bbff/h-25e66da3/h-d3d3e3e1/0",
        "sbg:revision": 2,
        "sbg:revisionNotes": "referential qc report",
        "sbg:modifiedOn": 1619428230,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619215530,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 2,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "adcd5c64b607a55bf29688468fe2d8995d79126c70949f0db3ae751d67629cf83"
      },
      "label": "QC Report",
      "sbg:x": 183.44854736328125,
      "sbg:y": -1194.9239501953125
    },
    {
      "id": "filter_controls",
      "in": [
        {
          "id": "in_bam",
          "source": "align_controls/out_bam"
        },
        {
          "id": "paired_end",
          "source": "ctl_paired_end"
        },
        {
          "id": "in_reference",
          "source": "in_reference"
        },
        {
          "id": "dup_marker",
          "source": "dup_marker"
        },
        {
          "id": "filter_chrs",
          "source": [
            "filter_chrs"
          ]
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        }
      ],
      "out": [
        {
          "id": "out_nodup_bam"
        },
        {
          "id": "out_samstat_qc"
        },
        {
          "id": "out_dup_qc"
        },
        {
          "id": "out_lib_complexity_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-filter-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_bam",
            "type": "File?",
            "label": "Input BAM file",
            "doc": "Input BAM file.",
            "sbg:fileTypes": "BAM"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness. Setting this ON means that all replicates are paired ended."
          },
          {
            "sbg:category": "App Settings",
            "id": "multimapping",
            "type": "int?",
            "label": "Multimapping [bowtie2 option]",
            "doc": "Multimapping option.",
            "default": 0
          },
          {
            "sbg:category": "Inputs",
            "id": "in_reference",
            "type": "File?",
            "label": "Reference file",
            "doc": "Reference FASTA file.",
            "sbg:fileTypes": "FA, FASTA, FA.GZ, FASTA.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "redact_nodup_bam",
            "type": "boolean?",
            "label": "Redact filtered/nodup BAM",
            "doc": "Redact filtered/nodup BAM at the end of the filtering step (task filter). Raw BAM from the aligner (task align) will still remain unredacted. Quality metrics on filtered BAM will be calculated before being redacted. However, all downstream analyses (e.g. peak-calling) will be done on the redacted BAM. If you start from nodup BAM then this flag will not be active."
          },
          {
            "sbg:toolDefaultValue": "picard",
            "sbg:category": "App Settings",
            "id": "dup_marker",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "picard",
                  "sambamba"
                ],
                "name": "dup_marker"
              }
            ],
            "label": "Marker for duplicate reads",
            "doc": "Marker for duplicate reads. Choose picard for Picard MarkDuplicates or sambamba for sambamba markdup."
          },
          {
            "sbg:toolDefaultValue": "30",
            "sbg:category": "App Settings",
            "id": "mapq_thresh",
            "type": "int?",
            "label": "Threshold for low MAPQ reads removal",
            "doc": "Threshold for low MAPQ reads removal. Low MAPQ reads are filtered out while filtering BAM.",
            "default": 30
          },
          {
            "sbg:toolDefaultValue": "None (empty string)",
            "sbg:category": "App Settings",
            "id": "filter_chrs",
            "type": "string[]?",
            "label": "Chromosomes to be filtered",
            "doc": "List of chromosomes to be filtered out while filtering BAM. It is empty by default, hence no filtering out of specfic chromosomes. It is case-sensitive. Use exact word for chromosome names.",
            "default": []
          },
          {
            "sbg:category": "Inputs",
            "id": "in_chrsz",
            "type": "File",
            "label": "Chromosome sizes file",
            "doc": "A 2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "False",
            "sbg:category": "App Settings",
            "id": "no_dup_removal",
            "type": "boolean?",
            "label": "Disable removal of duplicate reads",
            "doc": "Disable removal of duplicate reads during filtering BAM. Duplicate reads are filtererd out during filtering BAMs to gerenate NODUP_BAM. This flag will keep all duplicate reads in NODUP_BAM."
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "None (empty string)",
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial chromosome name, e.g. chrM, MT. Mitochondrial reads defined here will be filtered out during filtering BAMs step."
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "4",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPU cores",
            "doc": "Number of CPU cores",
            "default": 4
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.4",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory factor",
            "doc": "Multiplication factor to determine memory required for task.",
            "default": 0.4
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.9",
            "id": "picard_java_heap",
            "type": "float?",
            "label": "Maximum Java heap",
            "doc": "Maximum memory for Picard tools MarkDuplicates. If not defined, 90% of filter task's memory will be used."
          }
        ],
        "outputs": [
          {
            "id": "out_nodup_bam",
            "doc": "Filtered BAM file.",
            "label": "Filtered BAM",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam",
              "outputEval": "$(inheritMetadata(self, inputs.in_bam))"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              }
            ],
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "out_samstat_qc",
            "doc": "SAMstats log for filtered BAM file.",
            "label": "SAMstats log",
            "type": "File?",
            "outputBinding": {
              "glob": "*.samstats.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "out_dup_qc",
            "doc": "Dup QC for filtered BAM file.",
            "label": "Dup QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.dup.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "out_lib_complexity_qc",
            "doc": "Library complexity QC for filtered BAM file.",
            "label": "Library complexity QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.lib_complexity.qc"
            },
            "sbg:fileTypes": "QC"
          }
        ],
        "doc": "- Filter ATAC-Seq tool is based on the \u201cfilter\u201d WDL task from the Chip-Seq pipeline, developed by ENCODE DCC.\n- The tool executes the \u201cencode_task_filter.py\u201d script, which first filters (removes unmapped/low-quality reads) and sorts the BAM file with Samtools View and Samtools Sort, then it checks if filtered BAM is empty, i.e., if no reads are found in filtered BAM, and if yes, raises an error.\n- Then, it locates and tags duplicate reads in a BAM file with Picard v2.20.7 or Sambamba v0.6.6 and removes them with Samtools View.\n- After this step, it checks again if the filtered/deduplicated BAM file is empty, and if yes, raises an error. If a CHRSZ file is provided Samtools View is used to remove mitochondrial alignments from BAM file.\n- The filtered/deduplicated BAM file is indexed with SAMtools Index and SAMStat is run in order to generate sequence statistics.\n- Additionally, it runs Bedtools Bamtobed, and parses the output in order to generate a PBC QC file (.lib_complexity.qc).",
        "label": "ENCODE ChIP-Seq Filter CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    if(inputs.in_bam){\n        var cmd='';\n        cmd+='python3 $(which encode_task_filter.py) ';\n        cmd+=inputs.in_bam.path;\n        if(inputs.paired_end) cmd+=' --paired-end';\n        if(inputs.multimapping) cmd+=' --multimapping '+inputs.multimapping;\n        if (inputs.dup_marker) cmd+=' --dup-marker '+inputs.dup_marker;\n        if (inputs.mapq_thresh) cmd+=' --mapq-thresh '+inputs.mapq_thresh;\n        \n        // --filter-chrs\n        if(inputs.filter_chrs){\n            var chrs = Array();\n            for (var i = 0; i < inputs.filter_chrs.length; i++){\n                chrs.push(inputs.filter_chrs[i])\n            }\n            cmd+= \" --filter-chrs \" + chrs.join(\" \")\n        } else cmd+= \" --filter-chrs \"\n        \n        if (inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if (inputs.no_dup_removal) cmd+=' --no-dup-removal';\n        if(inputs.mito_chr_name) cmd+=' --mito-chr-name '+inputs.mito_chr_name;\n        \n        \n        \n        \n        // CPU and memory requirements\n        var arrSum = function(arr){\n            return arr.reduce(function(a,b){\n                return a + b }, 0);\n        }\n    \n        var bam_size = inputs.in_bam.size;\n        var input_file_size_gb = inputs.in_bam.size/1e+9;\n        var picard_java_heap_factor = 0.9;\n        var mem_gb = 6.0 + inputs.mem_factor * input_file_size_gb;\n        var samtools_mem_gb = 0.8 * mem_gb;\n        var picard_java_heap = inputs.picard_java_heap ? ' --picard-java-heap ' + inputs.picard_java_heap : ' --picard-java-heap ' + Math.round(mem_gb * picard_java_heap_factor) + \"G\";\n    \n\n        cmd+= \" --mem-gb \" + samtools_mem_gb + \" --nth \" + inputs.cpu + picard_java_heap;\n        \n         // encode_task_bam_to_pbam.py\n        if(inputs.redact_nodup_bam && inputs.in_reference){\n            cmd+= \" && python3 $(which encode_task_bam_to_pbam.py) $(ls *.bam) --ref-fa \" + inputs.in_reference.path + \" --delete-original-bam\"\n        }\n        \n        if (inputs.dup_marker == \"sambamba\") cmd+= \" && mv {}.dup.qc \" + inputs.in_bam.nameroot + \".dup.qc\";\n        \n    }\n    else  cmd=\"echo \\'No input BAM provided\\' 1>&2\";\n    \n    return cmd;\n    \n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb=0;\n    if(inputs.in_bam) input_file_size_gb = inputs.in_bam.size/1e+9;\n        \n    \n    var mem_gb = 6.0 + inputs.mem_factor * input_file_size_gb;\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n   \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212436,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212466,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:categories": [
          "ChipSeq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-1ac67915/h-c1241028/h-3cc18750/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619212466,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619212436,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "af4b77de7929ead2def9946e2c76143a6efe9f7aa490e36bb54f63ddc723d6072"
      },
      "label": "Filter Controls",
      "scatter": [
        "in_bam"
      ],
      "sbg:x": -2317.0830078125,
      "sbg:y": -2049
    },
    {
      "id": "bam2ta_controls",
      "in": [
        {
          "id": "in_bam",
          "source": "filter_controls/out_nodup_bam"
        },
        {
          "id": "paired_end",
          "source": "ctl_paired_end"
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        },
        {
          "id": "subsample",
          "source": "ctl_subsample"
        }
      ],
      "out": [
        {
          "id": "out_ta"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-bam2ta-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_bam",
            "type": "File?",
            "label": "Input BAM file",
            "doc": "Filtered (unmapped/low-quality and duplicate reads removed) BAM file. Output of the Filter ATAC-Seq tool.",
            "sbg:fileTypes": "BAM"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness.",
            "default": false
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial chromosome name, e.g. chrM, MT. Mitochondrial reads defined here will be filtered out during filtering BAMs step."
          },
          {
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "id": "subsample",
            "type": "int?",
            "label": "Subsample reads",
            "doc": "Number of reads to subsample TAGALIGN file. Reads are shuffled and subsampled. This affects all downstream analyses after filtering BAM. (e.g. all TAG-ALIGN files, peak-calling). Reads will be shuffled only if actual number of reads in BAM exceeds this number.  0 means disabled.",
            "default": 0
          },
          {
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Options",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPUs",
            "doc": "Number of CPUs (threads) for tasks. Resource settings are used for determining an instance type on cloud backends (e.g. GCP, AWS).",
            "default": 2
          },
          {
            "sbg:toolDefaultValue": "0.35",
            "sbg:category": "Options",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory multiplication factor",
            "doc": "Multiplication factor to determine memory required for the task.",
            "default": 0.35
          },
          {
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Options",
            "id": "time_hr",
            "type": "int?",
            "label": "Time in hours",
            "doc": "Walltime (h) required for task bam2ta.",
            "default": 6
          },
          {
            "sbg:toolDefaultValue": "4.0",
            "sbg:category": "Options",
            "id": "disk_factor",
            "type": "float?",
            "label": "Disk multiplication factor",
            "doc": "Multiplication factor to determine persistent disk size. This factor will be multiplied to the size of filtered BAMs.",
            "default": 4
          }
        ],
        "outputs": [
          {
            "id": "out_ta",
            "doc": "TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM.",
            "label": "Tag-Align",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "$(inheritMetadata(self, inputs.in_bam))"
            },
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "doc": "- Encode Bam2ta tool is based on the \u201cbam2ta\u201d WDL task from the ATAC-Seq pipeline, developed by ENCODE DCC.\n- The tool converts a BAM file to a TAGALIGN file.\n- It executes the \u201cencode_task_bam2ta.py\u201d script, which runs Bedtools Bamtobed v2.29.0 and its output is further parsed in order to generate a Tag-Align file (TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM).\n- If the number of reads are provided on the \u2018subsample\u2019 input port, the Tag-Align file will be subsampled and shuffled.\n- As a final step, TN5-shifting is performed on a TAGALIGN file.",
        "label": "ENCODE ChIP-Seq bam2ta CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.in_bam){\n        cmd+='python3 $(which encode_task_bam2ta.py) ';\n        cmd+=inputs.in_bam.path;\n        cmd+=' --disable-tn5-shift';\n        if (inputs.paired_end) cmd+=' --paired-end';\n        if (inputs.mito_chr_name) cmd+=' --mito-chr-name '+inputs.mito_chr_name;\n        if (inputs.subsample) cmd+=' --subsample '+inputs.subsample;\n        \n        var input_file_size_gb = inputs.in_bam.size/1e+9;\n        var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n        var samtools_mem_gb = 0.8 * mem_gb;\n    \n        cmd+= ' --mem-gb '+samtools_mem_gb;\n        \n        cmd+=' --nth '+inputs.cpu;\n        \n    }\n    else cmd=\"echo \\'No input BAM file provided\\' 1>&2\";\n    \n    return cmd\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb=0;\n    if (inputs.in_bam) var input_file_size_gb = inputs.in_bam.size/1e+9;\n    \n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n    \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212915,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212958,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:license": "MIT",
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:wrapperAuthor": "",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:links": [],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-29d0a5ed/h-6b9acc0b/h-61cb6389/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619212958,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619212915,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ac1279246141a3e278b6cc531e26588359856e0a808748c2e8d331d990270693e"
      },
      "label": "bam2ta Controls",
      "scatter": [
        "in_bam"
      ],
      "sbg:x": -2082.94873046875,
      "sbg:y": -2051.435302734375
    },
    {
      "id": "align_bio_replicates",
      "in": [
        {
          "id": "in_fastqs",
          "source": [
            "sbg_pair_fastqs_by_metadata_bio_replicates/tuple_list"
          ]
        },
        {
          "id": "in_reference_fasta",
          "source": "in_reference"
        },
        {
          "id": "trim_bp",
          "source": "trim_bp"
        },
        {
          "id": "crop_length",
          "source": "crop_length"
        },
        {
          "id": "crop_length_tol",
          "source": "crop_length_tol"
        },
        {
          "id": "trimmomatic_phred_score_format",
          "source": "trimmomatic_phred_score_format"
        },
        {
          "id": "aligner",
          "source": "aligner"
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        },
        {
          "id": "custom_align_py",
          "source": "custom_align_py"
        },
        {
          "id": "idx_tar",
          "source": "in_index"
        },
        {
          "id": "paired_end",
          "source": "paired_end"
        },
        {
          "id": "use_bwa_mem_for_pe",
          "source": "use_bwa_mem_for_pe"
        },
        {
          "id": "trimmomatic_java_heap",
          "source": "trimmomatic_java_heap"
        },
        {
          "id": "mem_factor",
          "source": "mem_factor"
        }
      ],
      "out": [
        {
          "id": "out_bam"
        },
        {
          "id": "out_samstat_qc"
        },
        {
          "id": "out_read_len_log"
        },
        {
          "id": "out_align_log"
        },
        {
          "id": "out_read_len"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-align-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_fastqs",
            "type": "File[]?",
            "label": "FASTQ files",
            "doc": "Input FASTQs to be merged for all provided biological replicates. Both Read1 and Read2 files should be provided to the same input.",
            "sbg:fileTypes": "FASTQ.GZ, FASTQ, FQ, FQ.GZ"
          },
          {
            "sbg:category": "Inputs",
            "id": "in_reference_fasta",
            "type": "File",
            "label": "Reference genome",
            "doc": "Reference FASTA file.",
            "sbg:fileTypes": "FA, FASTA, FA.GZ, FASTA.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "50",
            "id": "trim_bp",
            "type": "int?",
            "label": "Trim bp",
            "doc": "Trim experiment read1 FASTQ (for both SE and PE) for cross-correlation analysis. This does not affect alignment of experimental/control replicates. Pipeline additionaly aligns R1 FASTQ only for cross-correlation analysis only. This parameter is used for it.",
            "default": null
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "0",
            "id": "crop_length",
            "type": "int?",
            "label": "Crop FASTQs",
            "doc": "Crop FASTQ reads longer than this length. Also drop all reads shorter than crop_length - crop_length_tol.",
            "default": 0
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "2",
            "id": "crop_length_tol",
            "type": "int?",
            "label": "Crop FASTQs tolerance",
            "doc": "Tolerance for cropping reads in FASTQs. Drop all reads shorter than chip.crop_length - chip.crop_length_tol. Activated only when chip.crop_length is defined.",
            "default": 2
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "auto",
            "id": "trimmomatic_phred_score_format",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "auto",
                  "phred33",
                  "phred64"
                ],
                "name": "trimmomatic_phred_score_format"
              }
            ],
            "label": "Phred score encoding",
            "doc": "Base encoding format for Phred score in FASTQs. This is used for Trimmomatic only. It is auto by default, which means that Trimmomatic automatically detect it from FASTQs. Otherwise -phred33 or -phred64 will be passed to the Trimmomatic command line. Use this if you see an error like \"Error: Unable to detect quality encoding\".",
            "default": "auto"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "bowtie2",
            "id": "aligner",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "custom",
                  "bowtie2",
                  "bwa"
                ],
                "name": "aligner"
              }
            ],
            "label": "Aligner",
            "doc": "Aligner to be used in the alignment step. To use a custom aligner, define chip.custom_align_py and chip.custom_aligner_idx_tar.",
            "default": "bowtie2"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "None",
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial reads defined here will be filtered out during filtering BAMs in \"filter\" task. e.g. chrM, MT."
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "None",
            "id": "multimapping",
            "type": "int?",
            "label": "Multimapping [bowtie2 option]",
            "doc": "multimapping",
            "default": 0
          },
          {
            "sbg:category": "Inputs",
            "id": "custom_align_py",
            "type": "File?",
            "label": "Custom aligner script",
            "doc": "Python script for a custom aligner.",
            "sbg:fileTypes": "PY"
          },
          {
            "sbg:category": "Inputs",
            "id": "idx_tar",
            "type": "File",
            "label": "Index TAR",
            "doc": "Index TAR file.",
            "sbg:fileTypes": "TAR, TAR.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness. Setting this on means that all replicates are paired ended.",
            "default": null
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "use_bwa_mem_for_pe",
            "type": "boolean?",
            "label": "Use bwa mem",
            "doc": "For paired end dataset with read length >= 70bp, use bwa mem instead of bwa aln.",
            "default": false
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.9",
            "id": "trimmomatic_java_heap",
            "type": "float?",
            "label": "Trimmomatic max memory",
            "doc": "Maximum memory for Trimmomatic. If not defined, 90% of align task's memory will be used.",
            "default": 0.9
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "6",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPU cores",
            "doc": "Number of CPU cores",
            "default": 6
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.15",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory factor",
            "doc": "Multiplication factor to determine memory required for task. This factor will be multiplied to the size of FASTQs to determine required memory of instance or job.\nThe default value for Bowtie2 aligner is 0.15, and 0.3 for BWA aligner."
          }
        ],
        "outputs": [
          {
            "id": "out_bam",
            "doc": "Output BAM file.",
            "label": "Output BAM",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam",
              "outputEval": "$(inheritMetadata(self, inputs.in_fastqs))"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              }
            ],
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "out_samstat_qc",
            "doc": "Samstat QC.",
            "label": "Samstat QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.samstats.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "out_read_len_log",
            "doc": "Output read length TXT file.",
            "label": "Read length",
            "type": "File?",
            "outputBinding": {
              "glob": "*.read_length.txt"
            },
            "sbg:fileTypes": "TXT"
          },
          {
            "id": "out_align_log",
            "doc": "Align tool output log file",
            "label": "Output log",
            "type": "File?",
            "outputBinding": {
              "glob": "out.log"
            },
            "sbg:fileTypes": "LOG"
          },
          {
            "id": "out_read_len",
            "doc": "Output read length value.",
            "label": "Read length",
            "type": "int?",
            "outputBinding": {
              "loadContents": true,
              "glob": "*.read_length.txt",
              "outputEval": "${\n    if(inputs.in_fastqs){\n        var read_len = parseInt(self[0].contents)\n        return read_len\n    }\n}"
            }
          }
        ],
        "doc": "* **Align** tool is based on the \u201calign\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n* The tool first checks if the tool/pipeline dependencies can be found and if not, raises an error.\n* Then, the \u201cencode_task_merge_fastq.py\u201d script is executed, which merges all fastq files on input Read 1 to R1, and all fastq files on input Read 2 to R2.\n* After that the \"encode_task_trim_fastq.py\" is used to trim the merged fastq file by a provided number of bp, after which the fastqs are cropped using \"encode_task_trimmomatic.py\" script, which crops FASTQs reads longer than the given length.\n* The main step of this tool is the alignment step, for which the user can choose Bowtie2 or BWA aligner, or even provide a custom python script.\n* In the final step, the \u201cencode_task_post_align.py\u201d script is called, which generates the read length file, indexes the previously generated BAM file with Samtools Index v1.9, runs SAMStat v0.2.1 in order to generate sequence statistics.",
        "label": "ENCODE ChIP-Seq Align CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    if (inputs.in_fastqs) return \"( bash align_chip_seq.sh ) > out.log\";\n    else return \"echo \\'No input FASTQ files provided \\' 1>&2 \";\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    \n      // define CPU and memory requirements\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var fastq_size = Array();\n  \n    if (inputs.in_fastqs){\n        for ( var i = 0; i < inputs.in_fastqs.length; i++) fastq_size.push(inputs.in_fastqs[i].size);\n    \n    }\n    \n    \n    \n    fastq_size = arrSum(fastq_size);\n    \n    \n    var mem_factor=0.15;\n    if (inputs.mem_factor) mem_factor=inputs.mem_factor;\n    else if (inputs.aligner=='bowtie2') mem_factor=0.15;\n    else if (inputs.aligner=='bwa') mem_factor=0.3;\n    \n    var input_file_size_gb = (fastq_size)/1e+9;\n    var mem_gb = 5.0 + mem_factor * input_file_size_gb;\n   \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              {
                "entryname": "align_chip_seq.sh",
                "entry": "${\n    \n     // define CPU and memory requirements\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var fastq_size = Array();\n  \n    if(inputs.in_fastqs){\n        for ( var i = 0; i < inputs.in_fastqs.length; i++) fastq_size.push(inputs.in_fastqs[i].size);\n    \n    }\n    \n    \n    fastq_size = arrSum(fastq_size);\n    \n    \n    var mem_factor=0.15;\n    if (inputs.mem_factor) mem_factor=inputs.mem_factor;\n    else if (inputs.aligner=='bowtie2') mem_factor=0.15;\n    else if (inputs.aligner=='bwa') mem_factor=0.3;\n    \n    var input_file_size_gb = (fastq_size)/1e+9;\n    var mem_gb = 5.0 + mem_factor * input_file_size_gb;\n    var samtools_mem_gb = 0.8 * mem_gb;\n    \n    return '\\\n    #!/bin/bash\\n\\\n    #\\n\\\n    set -e\\n\\\n    # check if pipeline dependencies can be found\\n\\\n    if [[ -z \"$(which encode_task_merge_fastq.py 2> /dev/null || true)\" ]]\\n\\\n    then\\n\\\n    echo -e \"\\\\n* Error: pipeline dependencies not found.\" 1>&2\\n\\\n    echo \"Conda users: Did you activate Conda environment (conda activate encode-chip-seq-pipeline)?\" 1>&2\\n\\\n    echo \"Or did you install Conda and environment correctly (bash scripts/install_conda_env.sh)?\" 1>&2\\n\\\n    echo \"GCP/AWS/Docker users: Did you add --docker flag to Caper command line arg?\" 1>&2\\n\\\n    echo \"Singularity users: Did you add --singularity flag to Caper command line arg?\" 1>&2\\n\\\n    echo -e \"\\\\n\" 1>&2\\n\\\n    exit 3\\n\\\n    fi\\n\\\n    \\n\\\n    python3 $(which encode_task_merge_fastq.py) \\\\\\n\\\n    tmp_fastqs.tsv \\\\\\n\\\n    ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n    --nth ' + inputs.cpu + ' \\n\\\n    \\n\\\n    if [ ' + inputs.trim_bp + ' == \\'null\\' ]; then \\n\\\n        SUFFIX= \\n\\\n    else \\n\\\n        SUFFIX=_trimmed\\n\\\n        python3 $(which encode_task_trim_fastq.py) \\\\\\n\\\n            R1/*.fastq.gz \\\\\\n\\\n            --trim-bp ' + inputs.trim_bp + ' \\\\\\n\\\n            --out-dir R1$SUFFIX \\n\\\n        if [ ' + inputs.paired_end + ' == \\'true\\' ]; then \\n\\\n            python3 $(which encode_task_trim_fastq.py) \\\\\\n\\\n            R2/*.fastq.gz \\\\\\n\\\n            --trim-bp ' + inputs.trim_bp + ' \\\\\\n\\\n            --out-dir R2$SUFFIX \\n\\\n        fi\\n\\\n    fi\\n\\\n    if [ \\'' + inputs.crop_length + '\\' == \\'0\\' ]; then\\n\\\n            SUFFIX=$SUFFIX\\n\\\n    else\\n\\\n        NEW_SUFFIX=\"$SUFFIX\"_cropped\\n\\\n        python3 $(which encode_task_trimmomatic.py) \\\\\\n\\\n            --fastq1 R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"--fastq2 R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            --crop-length ' + inputs.crop_length + ' \\\\\\n\\\n            --crop-length-tol ' + inputs.crop_length_tol + ' \\\\\\n\\\n            --phred-score-format ' + inputs.trimmomatic_phred_score_format + ' \\\\\\n\\\n            --out-dir-R1 R1$NEW_SUFFIX \\\\\\n\\\n            ' + (inputs.paired_end ? \"--out-dir-R2 R2$NEW_SUFFIX\" : \"\") + ' \\\\\\n\\\n            --trimmomatic-java-heap ' + ( inputs.trimmomatic_java_heap ? inputs.trimmomatic_java_heap : Math.round(mem_gb * 0.9)) + 'G \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n        SUFFIX=$NEW_SUFFIX \\n\\\n    fi\\n\\\n    if [ ' + inputs.aligner + ' == \\'bwa\\' ]; then \\n\\\n        python3 $(which encode_task_bwa.py) \\\\\\n\\\n            ' + inputs.idx_tar.path + ' \\\\\\n\\\n            R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.use_bwa_mem_for_pe ? \"--use-bwa-mem-for-pe\" : \"\") + ' \\\\\\n\\\n            --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n    \\n\\\n    elif [ ' + inputs.aligner + ' == \\'bowtie2\\' ]; then \\n\\\n        python3 $(which encode_task_bowtie2.py) \\\\\\n\\\n            ' + inputs.idx_tar.path + ' \\\\\\n\\\n            R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            --multimapping ' + inputs.multimapping + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n    else \\n\\\n        python3 ${custom_align_py} \\\\\\n\\\n            ' + inputs.idx_tar.path + ' \\\\\\n\\\n            R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n    fi\\n\\\n    python3 $(which encode_task_post_align.py) \\\\\\n\\\n        R1$SUFFIX/*.fastq.gz $(ls *.bam) \\\\\\n\\\n        --mito-chr-name ' + inputs.mito_chr_name + ' \\\\\\n\\\n        --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n        --nth ' + inputs.cpu + ' \\n\\\n    rm -rf R1 R2 R1$SUFFIX R2$SUFFIX \\n\\\n    '\n}",
                "writable": false
              },
              {
                "entryname": "tmp_fastqs.tsv",
                "entry": "${\n    // wdl functions\n    function transpose(matrix) {\n        var rows = matrix.length, cols = matrix[0].length;\n        var grid = [];\n        for (var j = 0; j < cols; j++) {\n            grid[j] = Array(rows);\n        }\n        for (var i = 0; i < rows; i++) {\n        for (var j = 0; j < cols; j++) {\n            grid[j][i] = matrix[i][j];\n        }\n    }\n    return grid;  \n    }\n    \n    var fastq1 = Array();\n    var fastq2 = Array();\n    var ind1=0;\n    var ind2=0;\n    \n    if(inputs.in_fastqs){\n        var fq=[].concat(inputs.in_fastqs)\n    \n        for (var i=0; i < fq.length; i++){\n            if (fq[i].metadata['paired_end']=='1'){\n                ind1=fq[i].metadata['case_id'];\n                fastq1[ind1-1]=fq[i].path;\n            } \n            else if (fq[i].metadata['paired_end']=='2'){\n                ind2=fq[i].metadata['case_id']\n                fastq2[ind2-1]=fq[i].path;\n            }\n            else{\n                ind1=fq[i].metadata['case_id'];\n                fastq1[ind1-1]=fq[i].path;\n            } \n        }\n        \n    }\n    \n    \n   \n    var tmp_fastqs = inputs.paired_end ? transpose([fastq1, fastq2]) : transpose([fastq1])\n    return tmp_fastqs.map(function(d){ return d.join('\\t');\n        }).join('\\n');\n}",
                "writable": false
              }
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619210816,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619210908,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-21a32c5f/h-fa305918/h-f58b9da1/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619210908,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619210816,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "abcbf41df2dbc3ef764a1bc4fef54a74759d6cb298de35081452033be49bb1690"
      },
      "label": "Align Bio-replicates",
      "scatter": [
        "in_fastqs"
      ],
      "sbg:x": -2604,
      "sbg:y": -1501
    },
    {
      "id": "sbg_pair_fastqs_by_metadata_bio_replicates",
      "in": [
        {
          "id": "fastq_list",
          "source": [
            "in_reads"
          ]
        }
      ],
      "out": [
        {
          "id": "tuple_list"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/sbg-pair-fastqs-by-metadata/1",
        "baseCommand": [
          "echo"
        ],
        "inputs": [
          {
            "id": "fastq_list",
            "type": "File[]?",
            "label": "List of FASTQ files",
            "doc": "List of the FASTQ files with properly set metadata fileds.",
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ"
          }
        ],
        "outputs": [
          {
            "id": "tuple_list",
            "doc": "List of grouped FASTQ files by metadata fields.",
            "label": "List of grouped FASTQ files",
            "type": "File[]?",
            "outputBinding": {
              "outputEval": "${\n  function get_meta_map(m, file, meta) {\n    if (meta in file.metadata) {\n      return m[file.metadata[meta]];\n    } else {\n      return m['Undefined'];\n    }\n  }\n  \n  function create_new_map(map, file, meta) {\n    if (meta in file.metadata) {\n      map[file.metadata[meta]] = {};\n      return map[file.metadata[meta]];\n    } else {\n      map['Undefined'] = {};\n      return map['Undefined'];\n    }\n  }\n  \n  if (inputs.fastq_list) {\n    \n    var arr = [].concat(inputs.fastq_list);\n    var map = {};\n    \n    for (var i in arr) {\n      \n      var sm_map = get_meta_map(map, arr[i], 'sample_id');\n      if (!sm_map) sm_map = create_new_map(map, arr[i], 'sample_id');\n      \n      var lb_map = get_meta_map(sm_map, arr[i], 'library_id');\n      if (!lb_map) lb_map = create_new_map(sm_map, arr[i], 'library_id');\n      \n      var pu_map = get_meta_map(lb_map, arr[i], 'platform_unit_id');\n      if (!pu_map) pu_map = create_new_map(lb_map, arr[i], 'platform_unit_id');\n      \n      var a = '';\n      var ar = '';\n      \n      if ('file_segment_number' in arr[i].metadata) {\n        if (pu_map[arr[i].metadata['file_segment_number']]) {\n          a = pu_map[arr[i].metadata['file_segment_number']];\n          ar = [].concat(a);\n          ar = ar.concat(arr[i]);\n          pu_map[arr[i].metadata['file_segment_number']] = ar;\n        } else {\n          pu_map[arr[i].metadata['file_segment_number']] = [].concat(arr[i]);\n        }\n      } else {\n        if (pu_map['Undefined']) {\n          a = pu_map['Undefined'];\n          ar = [].concat(a);\n          ar = ar.concat(arr[i]);\n          pu_map['Undefined'] = ar;\n        } else {\n          pu_map['Undefined'] = [].concat(arr[i]);\n        }\n      }\n    }\n    var tuple_list = [];\n    var list;\n    for (var sm in map)\n      for (var lb in map[sm])\n        for (var pu in map[sm][lb]) {\n          for (var fsm in map[sm][lb][pu]) {\n            list = map[sm][lb][pu][fsm];\n            tuple_list.push(list);\n          }\n        }\n    return tuple_list;\n  }\n}"
            },
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ"
          }
        ],
        "doc": "Tool accepts list of FASTQ files groups them into separate lists. This grouping is done using metadata values and their hierarchy (Sample ID > Library ID > Platform unit ID > File segment number) which should create unique combinations for each pair of FASTQ files. Important metadata fields are Sample ID, Library ID, Platform unit ID and File segment number. Not all of these four metadata fields are required, but the present set has to be sufficient to create unique combinations for each pair of FASTQ files. Files with no paired end metadata are grouped in the same way as the ones with paired end metadata, generally they should be alone in a separate list. Files with no metadata set will be grouped together. \n\nIf there are more than two files in a group, this might create errors further down most pipelines and the user should check if the metadata fields for those files are set properly.",
        "label": "SBG Pair FASTQs by Metadata",
        "arguments": [
          {
            "shellQuote": false,
            "position": 0,
            "valueFrom": "'Pairing"
          },
          {
            "shellQuote": false,
            "position": 1,
            "valueFrom": "FASTQs!'"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": 1024,
            "coresMin": 1
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "d41a0837ab81",
            "dockerPull": "images.sbgenomics.com/nikola_jovanovic/alpine:1"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.fastq_list)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
            ]
          }
        ],
        "sbg:image_url": null,
        "sbg:license": "Apache License 2.0",
        "sbg:toolkit": "SBGTools",
        "sbg:cmdPreview": "echo 'Pairing FASTQs!'",
        "sbg:categories": [
          "Converters",
          "Other"
        ],
        "sbg:toolAuthor": "",
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619214989,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619215010,
            "sbg:revisionNotes": "upgrade to cwl1.1"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-5e09e6e9/h-c6bf4731/h-36cf42d8/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "upgrade to cwl1.1",
        "sbg:modifiedOn": 1619215010,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619214989,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a95b1533cafe255545a58aa4155d9d923c9a424cff733512a580cfc3d70b44d56"
      },
      "label": "SBG Pair FASTQs by Metadata",
      "sbg:x": -2859.55224609375,
      "sbg:y": -1298.9403076171875
    },
    {
      "id": "filter_bio_replicates",
      "in": [
        {
          "id": "in_bam",
          "source": "align_bio_replicates/out_bam"
        },
        {
          "id": "paired_end",
          "source": "paired_end"
        },
        {
          "id": "in_reference",
          "source": "in_reference"
        },
        {
          "id": "dup_marker",
          "source": "dup_marker"
        },
        {
          "id": "filter_chrs",
          "source": [
            "filter_chrs"
          ]
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        }
      ],
      "out": [
        {
          "id": "out_nodup_bam"
        },
        {
          "id": "out_samstat_qc"
        },
        {
          "id": "out_dup_qc"
        },
        {
          "id": "out_lib_complexity_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-filter-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_bam",
            "type": "File?",
            "label": "Input BAM file",
            "doc": "Input BAM file.",
            "sbg:fileTypes": "BAM"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness. Setting this ON means that all replicates are paired ended."
          },
          {
            "sbg:category": "App Settings",
            "id": "multimapping",
            "type": "int?",
            "label": "Multimapping [bowtie2 option]",
            "doc": "Multimapping option.",
            "default": 0
          },
          {
            "sbg:category": "Inputs",
            "id": "in_reference",
            "type": "File?",
            "label": "Reference file",
            "doc": "Reference FASTA file.",
            "sbg:fileTypes": "FA, FASTA, FA.GZ, FASTA.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "redact_nodup_bam",
            "type": "boolean?",
            "label": "Redact filtered/nodup BAM",
            "doc": "Redact filtered/nodup BAM at the end of the filtering step (task filter). Raw BAM from the aligner (task align) will still remain unredacted. Quality metrics on filtered BAM will be calculated before being redacted. However, all downstream analyses (e.g. peak-calling) will be done on the redacted BAM. If you start from nodup BAM then this flag will not be active."
          },
          {
            "sbg:toolDefaultValue": "picard",
            "sbg:category": "App Settings",
            "id": "dup_marker",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "picard",
                  "sambamba"
                ],
                "name": "dup_marker"
              }
            ],
            "label": "Marker for duplicate reads",
            "doc": "Marker for duplicate reads. Choose picard for Picard MarkDuplicates or sambamba for sambamba markdup."
          },
          {
            "sbg:toolDefaultValue": "30",
            "sbg:category": "App Settings",
            "id": "mapq_thresh",
            "type": "int?",
            "label": "Threshold for low MAPQ reads removal",
            "doc": "Threshold for low MAPQ reads removal. Low MAPQ reads are filtered out while filtering BAM.",
            "default": 30
          },
          {
            "sbg:toolDefaultValue": "None (empty string)",
            "sbg:category": "App Settings",
            "id": "filter_chrs",
            "type": "string[]?",
            "label": "Chromosomes to be filtered",
            "doc": "List of chromosomes to be filtered out while filtering BAM. It is empty by default, hence no filtering out of specfic chromosomes. It is case-sensitive. Use exact word for chromosome names.",
            "default": []
          },
          {
            "sbg:category": "Inputs",
            "id": "in_chrsz",
            "type": "File",
            "label": "Chromosome sizes file",
            "doc": "A 2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "False",
            "sbg:category": "App Settings",
            "id": "no_dup_removal",
            "type": "boolean?",
            "label": "Disable removal of duplicate reads",
            "doc": "Disable removal of duplicate reads during filtering BAM. Duplicate reads are filtererd out during filtering BAMs to gerenate NODUP_BAM. This flag will keep all duplicate reads in NODUP_BAM."
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "None (empty string)",
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial chromosome name, e.g. chrM, MT. Mitochondrial reads defined here will be filtered out during filtering BAMs step."
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "4",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPU cores",
            "doc": "Number of CPU cores",
            "default": 4
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.4",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory factor",
            "doc": "Multiplication factor to determine memory required for task.",
            "default": 0.4
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.9",
            "id": "picard_java_heap",
            "type": "float?",
            "label": "Maximum Java heap",
            "doc": "Maximum memory for Picard tools MarkDuplicates. If not defined, 90% of filter task's memory will be used."
          }
        ],
        "outputs": [
          {
            "id": "out_nodup_bam",
            "doc": "Filtered BAM file.",
            "label": "Filtered BAM",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam",
              "outputEval": "$(inheritMetadata(self, inputs.in_bam))"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              }
            ],
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "out_samstat_qc",
            "doc": "SAMstats log for filtered BAM file.",
            "label": "SAMstats log",
            "type": "File?",
            "outputBinding": {
              "glob": "*.samstats.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "out_dup_qc",
            "doc": "Dup QC for filtered BAM file.",
            "label": "Dup QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.dup.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "out_lib_complexity_qc",
            "doc": "Library complexity QC for filtered BAM file.",
            "label": "Library complexity QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.lib_complexity.qc"
            },
            "sbg:fileTypes": "QC"
          }
        ],
        "doc": "- Filter ATAC-Seq tool is based on the \u201cfilter\u201d WDL task from the Chip-Seq pipeline, developed by ENCODE DCC.\n- The tool executes the \u201cencode_task_filter.py\u201d script, which first filters (removes unmapped/low-quality reads) and sorts the BAM file with Samtools View and Samtools Sort, then it checks if filtered BAM is empty, i.e., if no reads are found in filtered BAM, and if yes, raises an error.\n- Then, it locates and tags duplicate reads in a BAM file with Picard v2.20.7 or Sambamba v0.6.6 and removes them with Samtools View.\n- After this step, it checks again if the filtered/deduplicated BAM file is empty, and if yes, raises an error. If a CHRSZ file is provided Samtools View is used to remove mitochondrial alignments from BAM file.\n- The filtered/deduplicated BAM file is indexed with SAMtools Index and SAMStat is run in order to generate sequence statistics.\n- Additionally, it runs Bedtools Bamtobed, and parses the output in order to generate a PBC QC file (.lib_complexity.qc).",
        "label": "ENCODE ChIP-Seq Filter CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    if(inputs.in_bam){\n        var cmd='';\n        cmd+='python3 $(which encode_task_filter.py) ';\n        cmd+=inputs.in_bam.path;\n        if(inputs.paired_end) cmd+=' --paired-end';\n        if(inputs.multimapping) cmd+=' --multimapping '+inputs.multimapping;\n        if (inputs.dup_marker) cmd+=' --dup-marker '+inputs.dup_marker;\n        if (inputs.mapq_thresh) cmd+=' --mapq-thresh '+inputs.mapq_thresh;\n        \n        // --filter-chrs\n        if(inputs.filter_chrs){\n            var chrs = Array();\n            for (var i = 0; i < inputs.filter_chrs.length; i++){\n                chrs.push(inputs.filter_chrs[i])\n            }\n            cmd+= \" --filter-chrs \" + chrs.join(\" \")\n        } else cmd+= \" --filter-chrs \"\n        \n        if (inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if (inputs.no_dup_removal) cmd+=' --no-dup-removal';\n        if(inputs.mito_chr_name) cmd+=' --mito-chr-name '+inputs.mito_chr_name;\n        \n        \n        \n        \n        // CPU and memory requirements\n        var arrSum = function(arr){\n            return arr.reduce(function(a,b){\n                return a + b }, 0);\n        }\n    \n        var bam_size = inputs.in_bam.size;\n        var input_file_size_gb = inputs.in_bam.size/1e+9;\n        var picard_java_heap_factor = 0.9;\n        var mem_gb = 6.0 + inputs.mem_factor * input_file_size_gb;\n        var samtools_mem_gb = 0.8 * mem_gb;\n        var picard_java_heap = inputs.picard_java_heap ? ' --picard-java-heap ' + inputs.picard_java_heap : ' --picard-java-heap ' + Math.round(mem_gb * picard_java_heap_factor) + \"G\";\n    \n\n        cmd+= \" --mem-gb \" + samtools_mem_gb + \" --nth \" + inputs.cpu + picard_java_heap;\n        \n         // encode_task_bam_to_pbam.py\n        if(inputs.redact_nodup_bam && inputs.in_reference){\n            cmd+= \" && python3 $(which encode_task_bam_to_pbam.py) $(ls *.bam) --ref-fa \" + inputs.in_reference.path + \" --delete-original-bam\"\n        }\n        \n        if (inputs.dup_marker == \"sambamba\") cmd+= \" && mv {}.dup.qc \" + inputs.in_bam.nameroot + \".dup.qc\";\n        \n    }\n    else  cmd=\"echo \\'No input BAM provided\\' 1>&2\";\n    \n    return cmd;\n    \n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb=0;\n    if(inputs.in_bam) input_file_size_gb = inputs.in_bam.size/1e+9;\n        \n    \n    var mem_gb = 6.0 + inputs.mem_factor * input_file_size_gb;\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n   \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212436,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212466,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:categories": [
          "ChipSeq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-6ca72189/h-e731b567/h-a2c74d3f/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619212466,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619212436,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "af4b77de7929ead2def9946e2c76143a6efe9f7aa490e36bb54f63ddc723d6072"
      },
      "label": "Filter Bio-replicates",
      "scatter": [
        "in_bam"
      ],
      "sbg:x": -2351.9951171875,
      "sbg:y": -1518.7408447265625
    },
    {
      "id": "gc_bias",
      "in": [
        {
          "id": "in_nodup_bam",
          "source": "filter_bio_replicates/out_nodup_bam"
        },
        {
          "id": "in_reference",
          "source": "in_reference"
        },
        {
          "id": "enable_gc_bias",
          "source": "enable_gc_bias"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        }
      ],
      "out": [
        {
          "id": "gc_plot"
        },
        {
          "id": "gc_log"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-gc-bias-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_nodup_bam",
            "type": "File?",
            "label": "Deduplicated BAM",
            "doc": "Input deduplicated BAM file.",
            "sbg:fileTypes": "BAM"
          },
          {
            "sbg:category": "Inputs",
            "id": "in_reference",
            "type": "File?",
            "label": "Reference file",
            "doc": "Reference FASTA file.",
            "sbg:fileTypes": "FASTA, FA, FASTA.GZ, FA.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "90%",
            "id": "picard_java_heap",
            "type": "string?",
            "label": "Maximum Java heap",
            "doc": "Maximum memory for Picard tools CollectGcBiasMetrics. If not defined, 90% of gc_bias task's memory will be used."
          },
          {
            "id": "enable_gc_bias",
            "type": "boolean?",
            "label": "Enable GC bias",
            "doc": "Enable GC bias."
          },
          {
            "sbg:toolDefaultValue": "tf",
            "id": "pipeline_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "tf",
                  "histone",
                  "control"
                ],
                "name": "pipeline_type"
              }
            ],
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          }
        ],
        "outputs": [
          {
            "id": "gc_plot",
            "doc": "Picard CollectGcBiasMetrics output.",
            "label": "GC plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.gc_plot.png"
            },
            "sbg:fileTypes": "PNG"
          },
          {
            "id": "gc_log",
            "doc": "Picard CollectGcBiasMetrics output.",
            "label": "GC log",
            "type": "File?",
            "outputBinding": {
              "glob": "*.gc.txt"
            },
            "sbg:fileTypes": "TXT"
          }
        ],
        "doc": "- Encode GC Bias tool is based on the \u201cgc_bias\u201d WDL task from the Chip-Seq pipeline, developed by ENCODE DCC.\n- The tool runs Picard CollectGcBiasMetrics tool that collects metrics regarding GC bias. This tool collects information about the relative proportions of guanine (G) and cytosine (C) nucleotides in a sample. Regions of high and low G + C content have been shown to interfere with mapping/aligning, ultimately leading to fragmented genome assemblies and poor coverage in a phenomenon known as 'GC bias'.",
        "label": "ENCODE ChIP-Seq GC Bias CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(!inputs.enable_gc_bias || inputs.pipeline_type=='control') cmd=\"echo \\' GC bias disabled \\' 1>&2\";\n    else{\n        cmd+='python3 $(which encode_task_gc_bias.py)'\n        cmd+=' --nodup-bam '+inputs.in_nodup_bam.path;\n        if(inputs.in_reference) cmd+=' --ref-fa '+inputs.in_reference.path;\n        \n        // --picard-java-heap\n    \n        var mem_factor = 0.3;\n        var input_file_size_gb = inputs.in_nodup_bam.size/10e9;\n        var mem_gb = 4.0 + mem_factor * input_file_size_gb;\n        var picard_java_heap_factor = 0.9;\n    \n        if(inputs.picard_java_heap) cmd+=' --picard-java-heap '+inputs.picard_java_heap;\n        else cmd+=' --picard-java-heap '+ Math.round(mem_gb * picard_java_heap_factor) + \"G\";\n        }\n    \n    return cmd;\n        \n    \n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var mem_factor = 0.3;\n    var input_file_size_gb = inputs.in_nodup_bam.size/10e9;\n    var mem_gb = 4.0 + mem_factor * input_file_size_gb;\n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619213674,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619213711,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:license": "MIT",
        "sbg:toolkit": "ENCODE Chip-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:wrapperAuthor": "",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:categories": [
          "ATAC-Seq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-f1dcf00f/h-574d6881/h-f0f48f93/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619213711,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619213674,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ae497db53dfd812a467da721263a193b744c39e51c5272eeb3d6c2e150d194256"
      },
      "label": "GC Bias",
      "scatter": [
        "in_nodup_bam"
      ],
      "sbg:x": -2076.02001953125,
      "sbg:y": -1507.8251953125
    },
    {
      "id": "bam2ta_bio_replicates",
      "in": [
        {
          "id": "in_bam",
          "source": "filter_bio_replicates/out_nodup_bam"
        },
        {
          "id": "paired_end",
          "source": "paired_end"
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        },
        {
          "id": "subsample",
          "source": "subsample"
        }
      ],
      "out": [
        {
          "id": "out_ta"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-bam2ta-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_bam",
            "type": "File?",
            "label": "Input BAM file",
            "doc": "Filtered (unmapped/low-quality and duplicate reads removed) BAM file. Output of the Filter ATAC-Seq tool.",
            "sbg:fileTypes": "BAM"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness.",
            "default": false
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial chromosome name, e.g. chrM, MT. Mitochondrial reads defined here will be filtered out during filtering BAMs step."
          },
          {
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "id": "subsample",
            "type": "int?",
            "label": "Subsample reads",
            "doc": "Number of reads to subsample TAGALIGN file. Reads are shuffled and subsampled. This affects all downstream analyses after filtering BAM. (e.g. all TAG-ALIGN files, peak-calling). Reads will be shuffled only if actual number of reads in BAM exceeds this number.  0 means disabled.",
            "default": 0
          },
          {
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Options",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPUs",
            "doc": "Number of CPUs (threads) for tasks. Resource settings are used for determining an instance type on cloud backends (e.g. GCP, AWS).",
            "default": 2
          },
          {
            "sbg:toolDefaultValue": "0.35",
            "sbg:category": "Options",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory multiplication factor",
            "doc": "Multiplication factor to determine memory required for the task.",
            "default": 0.35
          },
          {
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Options",
            "id": "time_hr",
            "type": "int?",
            "label": "Time in hours",
            "doc": "Walltime (h) required for task bam2ta.",
            "default": 6
          },
          {
            "sbg:toolDefaultValue": "4.0",
            "sbg:category": "Options",
            "id": "disk_factor",
            "type": "float?",
            "label": "Disk multiplication factor",
            "doc": "Multiplication factor to determine persistent disk size. This factor will be multiplied to the size of filtered BAMs.",
            "default": 4
          }
        ],
        "outputs": [
          {
            "id": "out_ta",
            "doc": "TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM.",
            "label": "Tag-Align",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "$(inheritMetadata(self, inputs.in_bam))"
            },
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "doc": "- Encode Bam2ta tool is based on the \u201cbam2ta\u201d WDL task from the ATAC-Seq pipeline, developed by ENCODE DCC.\n- The tool converts a BAM file to a TAGALIGN file.\n- It executes the \u201cencode_task_bam2ta.py\u201d script, which runs Bedtools Bamtobed v2.29.0 and its output is further parsed in order to generate a Tag-Align file (TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM).\n- If the number of reads are provided on the \u2018subsample\u2019 input port, the Tag-Align file will be subsampled and shuffled.\n- As a final step, TN5-shifting is performed on a TAGALIGN file.",
        "label": "ENCODE ChIP-Seq bam2ta CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.in_bam){\n        cmd+='python3 $(which encode_task_bam2ta.py) ';\n        cmd+=inputs.in_bam.path;\n        cmd+=' --disable-tn5-shift';\n        if (inputs.paired_end) cmd+=' --paired-end';\n        if (inputs.mito_chr_name) cmd+=' --mito-chr-name '+inputs.mito_chr_name;\n        if (inputs.subsample) cmd+=' --subsample '+inputs.subsample;\n        \n        var input_file_size_gb = inputs.in_bam.size/1e+9;\n        var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n        var samtools_mem_gb = 0.8 * mem_gb;\n    \n        cmd+= ' --mem-gb '+samtools_mem_gb;\n        \n        cmd+=' --nth '+inputs.cpu;\n        \n    }\n    else cmd=\"echo \\'No input BAM file provided\\' 1>&2\";\n    \n    return cmd\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb=0;\n    if (inputs.in_bam) var input_file_size_gb = inputs.in_bam.size/1e+9;\n    \n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n    \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212915,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212958,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:license": "MIT",
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:wrapperAuthor": "",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:links": [],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-30a46e7d/h-5332630d/h-c284b55d/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619212958,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619212915,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ac1279246141a3e278b6cc531e26588359856e0a808748c2e8d331d990270693e"
      },
      "label": "bam2ta Bio-replicates",
      "scatter": [
        "in_bam"
      ],
      "sbg:x": -2068.6015625,
      "sbg:y": -1695.65771484375
    },
    {
      "id": "spr",
      "in": [
        {
          "id": "in_ta",
          "source": "bam2ta_bio_replicates/out_ta"
        },
        {
          "id": "paired_end",
          "source": "paired_end"
        },
        {
          "id": "true_replicates_olny",
          "source": "true_replicates_only"
        }
      ],
      "out": [
        {
          "id": "ta_pr1"
        },
        {
          "id": "ta_pr2"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-spr-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_ta",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Input TagAlign file.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness. Setting this on means that all replicates are paired ended."
          },
          {
            "sbg:toolDefaultValue": "13.5",
            "sbg:category": "Resource option",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory factor",
            "doc": "Multiplication factor to determine memory required for the task. This factor will be multiplied to the size of filtered BAMs.",
            "default": 13.5
          },
          {
            "id": "true_replicates_olny",
            "type": "boolean?",
            "label": "True replicates only",
            "doc": "Disables all analyses related to pseudo-replicates."
          }
        ],
        "outputs": [
          {
            "id": "ta_pr1",
            "doc": "Pseudoreplicate one TAG-ALIGN file.",
            "label": "Pseudoreplicate one TAG-ALIGN",
            "type": "File?",
            "outputBinding": {
              "glob": "*.pr1.tagAlign.gz"
            }
          },
          {
            "id": "ta_pr2",
            "doc": "Pseudoreplicate two TAG-ALIGN file.",
            "label": "Pseudoreplicate two TAG-ALIGN",
            "type": "File?",
            "outputBinding": {
              "glob": "*.pr2.tagAlign.gz"
            }
          }
        ],
        "doc": "- Encode Spr tool is based on the \u201cspr\u201d WDL task from the Chip-Seq pipeline, developed by ENCODE DCC.\n- The tool generates self-pseudo replicates from a TAG-ALIGN file generated by the Bam2ta tool.",
        "label": "ENCODE ChIP-Seq Spr CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.true_replicates_olny) cmd=\"echo \\' Spr is disabled in true replicates only mode\\' 1>&2\";\n    else{\n        cmd+='python3 $(which encode_task_spr.py) ';\n        cmd+=inputs.in_ta.path;\n        if (inputs.paired_end) cmd+=' --paired-end';\n    }\n    \n    return cmd;\n    \n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb = inputs.in_ta.size/1e+9;\n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb\n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619214227,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619214332,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE Chip-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:wrapperAuthor": "",
        "sbg:categories": [
          "Chip-Seq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-79491cfd/h-f9e97a91/h-37b98b0d/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619214332,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619214227,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "acd86fcbee64bf57ec53d169c91f03be33b2ea42448479aa4848e18c86d912253"
      },
      "label": "Spr",
      "scatter": [
        "in_ta"
      ],
      "sbg:x": -2079,
      "sbg:y": -1174.3094482421875
    },
    {
      "id": "count_signal_track",
      "in": [
        {
          "id": "in_ta",
          "source": "bam2ta_bio_replicates/out_ta"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        },
        {
          "id": "enable_count_signal_track",
          "source": "enable_count_signal_track"
        }
      ],
      "out": [
        {
          "id": "out_pos_bw"
        },
        {
          "id": "out_neg_bw"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-count-signal-track-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_ta",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM. Output of Encode Bam2ta tool.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "id": "pipeline_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "tf",
                  "histone",
                  "control"
                ],
                "name": "pipeline_type"
              }
            ],
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          },
          {
            "id": "enable_count_signal_track",
            "type": "boolean?",
            "label": "Enable count signal track",
            "doc": "Enable count signal track."
          }
        ],
        "outputs": [
          {
            "id": "out_pos_bw",
            "doc": "Positive bigWig.",
            "label": "Positive bigWig",
            "type": "File?",
            "outputBinding": {
              "glob": "*.positive.bigwig",
              "outputEval": "$(inheritMetadata(self, inputs.in_ta))"
            },
            "sbg:fileTypes": "BIGWIG"
          },
          {
            "id": "out_neg_bw",
            "doc": "Negative bigWig.",
            "label": "Negative bigWig",
            "type": "File?",
            "outputBinding": {
              "glob": "*.negative.bigwig",
              "outputEval": "$(inheritMetadata(self, inputs.in_ta))"
            },
            "sbg:fileTypes": "BIGWIG"
          }
        ],
        "doc": "**Count Signal Track** tool is based on the \u201ccount_signal_track\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. The tool generates count signal tracks.\n\nThe \u201cencode_task_count_signal_track.py\u201d script is executed, which first groups the input TAG-ALIGN file by chromosome with simple Sort-k1,1 -k2,2n command, and the output is piped to the Bedtools genomecov tool that computes histograms (default), per-base reports (-d) and BEDGRAPH (-bg) summaries of feature coverage (e.g., aligned sequences) for a given genome. In the final step, bedGraphToBigWig tool is executed.\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Count Signal Track CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(!inputs.enable_count_signal_track || inputs.pipeline_type=='control' || !inputs.in_ta){\n        cmd=\"echo \\' Count signal track disabled \\' 1>&2\";\n    }\n    else{\n        cmd+=' python3 $(which encode_task_count_signal_track.py) ';\n        cmd+=inputs.in_ta.path;\n        if (inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        \n    }\n    \n    \n    return cmd\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 8000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619214023,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619214060,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:wrapperAuthor": "",
        "sbg:license": "MIT",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-56e220b9/h-8ab458c4/h-e3025b2b/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619214060,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619214023,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a55a37d36e3147da91926d9e1d69eee383e870139551f2efceea508e2832327bd"
      },
      "label": "Count Signal Track",
      "scatter": [
        "in_ta"
      ],
      "sbg:x": -2078.040283203125,
      "sbg:y": -1338.7044677734375
    },
    {
      "id": "align_r1",
      "in": [
        {
          "id": "in_fastqs",
          "source": [
            "sbg_pair_fastqs_by_metadata_bio_replicates/tuple_list"
          ]
        },
        {
          "id": "in_reference_fasta",
          "source": "in_reference"
        },
        {
          "id": "trim_bp",
          "default": 50
        },
        {
          "id": "crop_length",
          "default": 0
        },
        {
          "id": "crop_length_tol",
          "default": 0
        },
        {
          "id": "aligner",
          "source": "aligner"
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        },
        {
          "id": "custom_align_py",
          "source": "custom_align_py"
        },
        {
          "id": "idx_tar",
          "source": "in_index"
        },
        {
          "id": "use_bwa_mem_for_pe",
          "source": "use_bwa_mem_for_pe"
        }
      ],
      "out": [
        {
          "id": "out_bam"
        },
        {
          "id": "out_samstat_qc"
        },
        {
          "id": "out_read_len_log"
        },
        {
          "id": "out_align_log"
        },
        {
          "id": "out_read_len"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-align-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_fastqs",
            "type": "File[]?",
            "label": "FASTQ files",
            "doc": "Input FASTQs to be merged for all provided biological replicates. Both Read1 and Read2 files should be provided to the same input.",
            "sbg:fileTypes": "FASTQ.GZ, FASTQ, FQ, FQ.GZ"
          },
          {
            "sbg:category": "Inputs",
            "id": "in_reference_fasta",
            "type": "File",
            "label": "Reference genome",
            "doc": "Reference FASTA file.",
            "sbg:fileTypes": "FA, FASTA, FA.GZ, FASTA.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "50",
            "id": "trim_bp",
            "type": "int?",
            "label": "Trim bp",
            "doc": "Trim experiment read1 FASTQ (for both SE and PE) for cross-correlation analysis. This does not affect alignment of experimental/control replicates. Pipeline additionaly aligns R1 FASTQ only for cross-correlation analysis only. This parameter is used for it.",
            "default": null
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "0",
            "id": "crop_length",
            "type": "int?",
            "label": "Crop FASTQs",
            "doc": "Crop FASTQ reads longer than this length. Also drop all reads shorter than crop_length - crop_length_tol.",
            "default": 0
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "2",
            "id": "crop_length_tol",
            "type": "int?",
            "label": "Crop FASTQs tolerance",
            "doc": "Tolerance for cropping reads in FASTQs. Drop all reads shorter than chip.crop_length - chip.crop_length_tol. Activated only when chip.crop_length is defined.",
            "default": 2
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "auto",
            "id": "trimmomatic_phred_score_format",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "auto",
                  "phred33",
                  "phred64"
                ],
                "name": "trimmomatic_phred_score_format"
              }
            ],
            "label": "Phred score encoding",
            "doc": "Base encoding format for Phred score in FASTQs. This is used for Trimmomatic only. It is auto by default, which means that Trimmomatic automatically detect it from FASTQs. Otherwise -phred33 or -phred64 will be passed to the Trimmomatic command line. Use this if you see an error like \"Error: Unable to detect quality encoding\".",
            "default": "auto"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "bowtie2",
            "id": "aligner",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "custom",
                  "bowtie2",
                  "bwa"
                ],
                "name": "aligner"
              }
            ],
            "label": "Aligner",
            "doc": "Aligner to be used in the alignment step. To use a custom aligner, define chip.custom_align_py and chip.custom_aligner_idx_tar.",
            "default": "bowtie2"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "None",
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial reads defined here will be filtered out during filtering BAMs in \"filter\" task. e.g. chrM, MT."
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "None",
            "id": "multimapping",
            "type": "int?",
            "label": "Multimapping [bowtie2 option]",
            "doc": "multimapping",
            "default": 0
          },
          {
            "sbg:category": "Inputs",
            "id": "custom_align_py",
            "type": "File?",
            "label": "Custom aligner script",
            "doc": "Python script for a custom aligner.",
            "sbg:fileTypes": "PY"
          },
          {
            "sbg:category": "Inputs",
            "id": "idx_tar",
            "type": "File",
            "label": "Index TAR",
            "doc": "Index TAR file.",
            "sbg:fileTypes": "TAR, TAR.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness. Setting this on means that all replicates are paired ended.",
            "default": null
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "use_bwa_mem_for_pe",
            "type": "boolean?",
            "label": "Use bwa mem",
            "doc": "For paired end dataset with read length >= 70bp, use bwa mem instead of bwa aln.",
            "default": false
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.9",
            "id": "trimmomatic_java_heap",
            "type": "float?",
            "label": "Trimmomatic max memory",
            "doc": "Maximum memory for Trimmomatic. If not defined, 90% of align task's memory will be used.",
            "default": 0.9
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "6",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPU cores",
            "doc": "Number of CPU cores",
            "default": 6
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.15",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory factor",
            "doc": "Multiplication factor to determine memory required for task. This factor will be multiplied to the size of FASTQs to determine required memory of instance or job.\nThe default value for Bowtie2 aligner is 0.15, and 0.3 for BWA aligner."
          }
        ],
        "outputs": [
          {
            "id": "out_bam",
            "doc": "Output BAM file.",
            "label": "Output BAM",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam",
              "outputEval": "$(inheritMetadata(self, inputs.in_fastqs))"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              }
            ],
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "out_samstat_qc",
            "doc": "Samstat QC.",
            "label": "Samstat QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.samstats.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "out_read_len_log",
            "doc": "Output read length TXT file.",
            "label": "Read length",
            "type": "File?",
            "outputBinding": {
              "glob": "*.read_length.txt"
            },
            "sbg:fileTypes": "TXT"
          },
          {
            "id": "out_align_log",
            "doc": "Align tool output log file",
            "label": "Output log",
            "type": "File?",
            "outputBinding": {
              "glob": "out.log"
            },
            "sbg:fileTypes": "LOG"
          },
          {
            "id": "out_read_len",
            "doc": "Output read length value.",
            "label": "Read length",
            "type": "int?",
            "outputBinding": {
              "loadContents": true,
              "glob": "*.read_length.txt",
              "outputEval": "${\n    if(inputs.in_fastqs){\n        var read_len = parseInt(self[0].contents)\n        return read_len\n    }\n}"
            }
          }
        ],
        "doc": "* **Align** tool is based on the \u201calign\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n* The tool first checks if the tool/pipeline dependencies can be found and if not, raises an error.\n* Then, the \u201cencode_task_merge_fastq.py\u201d script is executed, which merges all fastq files on input Read 1 to R1, and all fastq files on input Read 2 to R2.\n* After that the \"encode_task_trim_fastq.py\" is used to trim the merged fastq file by a provided number of bp, after which the fastqs are cropped using \"encode_task_trimmomatic.py\" script, which crops FASTQs reads longer than the given length.\n* The main step of this tool is the alignment step, for which the user can choose Bowtie2 or BWA aligner, or even provide a custom python script.\n* In the final step, the \u201cencode_task_post_align.py\u201d script is called, which generates the read length file, indexes the previously generated BAM file with Samtools Index v1.9, runs SAMStat v0.2.1 in order to generate sequence statistics.",
        "label": "ENCODE ChIP-Seq Align CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    if (inputs.in_fastqs) return \"( bash align_chip_seq.sh ) > out.log\";\n    else return \"echo \\'No input FASTQ files provided \\' 1>&2 \";\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    \n      // define CPU and memory requirements\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var fastq_size = Array();\n  \n    if (inputs.in_fastqs){\n        for ( var i = 0; i < inputs.in_fastqs.length; i++) fastq_size.push(inputs.in_fastqs[i].size);\n    \n    }\n    \n    \n    \n    fastq_size = arrSum(fastq_size);\n    \n    \n    var mem_factor=0.15;\n    if (inputs.mem_factor) mem_factor=inputs.mem_factor;\n    else if (inputs.aligner=='bowtie2') mem_factor=0.15;\n    else if (inputs.aligner=='bwa') mem_factor=0.3;\n    \n    var input_file_size_gb = (fastq_size)/1e+9;\n    var mem_gb = 5.0 + mem_factor * input_file_size_gb;\n   \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              {
                "entryname": "align_chip_seq.sh",
                "entry": "${\n    \n     // define CPU and memory requirements\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var fastq_size = Array();\n  \n    if(inputs.in_fastqs){\n        for ( var i = 0; i < inputs.in_fastqs.length; i++) fastq_size.push(inputs.in_fastqs[i].size);\n    \n    }\n    \n    \n    fastq_size = arrSum(fastq_size);\n    \n    \n    var mem_factor=0.15;\n    if (inputs.mem_factor) mem_factor=inputs.mem_factor;\n    else if (inputs.aligner=='bowtie2') mem_factor=0.15;\n    else if (inputs.aligner=='bwa') mem_factor=0.3;\n    \n    var input_file_size_gb = (fastq_size)/1e+9;\n    var mem_gb = 5.0 + mem_factor * input_file_size_gb;\n    var samtools_mem_gb = 0.8 * mem_gb;\n    \n    return '\\\n    #!/bin/bash\\n\\\n    #\\n\\\n    set -e\\n\\\n    # check if pipeline dependencies can be found\\n\\\n    if [[ -z \"$(which encode_task_merge_fastq.py 2> /dev/null || true)\" ]]\\n\\\n    then\\n\\\n    echo -e \"\\\\n* Error: pipeline dependencies not found.\" 1>&2\\n\\\n    echo \"Conda users: Did you activate Conda environment (conda activate encode-chip-seq-pipeline)?\" 1>&2\\n\\\n    echo \"Or did you install Conda and environment correctly (bash scripts/install_conda_env.sh)?\" 1>&2\\n\\\n    echo \"GCP/AWS/Docker users: Did you add --docker flag to Caper command line arg?\" 1>&2\\n\\\n    echo \"Singularity users: Did you add --singularity flag to Caper command line arg?\" 1>&2\\n\\\n    echo -e \"\\\\n\" 1>&2\\n\\\n    exit 3\\n\\\n    fi\\n\\\n    \\n\\\n    python3 $(which encode_task_merge_fastq.py) \\\\\\n\\\n    tmp_fastqs.tsv \\\\\\n\\\n    ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n    --nth ' + inputs.cpu + ' \\n\\\n    \\n\\\n    if [ ' + inputs.trim_bp + ' == \\'null\\' ]; then \\n\\\n        SUFFIX= \\n\\\n    else \\n\\\n        SUFFIX=_trimmed\\n\\\n        python3 $(which encode_task_trim_fastq.py) \\\\\\n\\\n            R1/*.fastq.gz \\\\\\n\\\n            --trim-bp ' + inputs.trim_bp + ' \\\\\\n\\\n            --out-dir R1$SUFFIX \\n\\\n        if [ ' + inputs.paired_end + ' == \\'true\\' ]; then \\n\\\n            python3 $(which encode_task_trim_fastq.py) \\\\\\n\\\n            R2/*.fastq.gz \\\\\\n\\\n            --trim-bp ' + inputs.trim_bp + ' \\\\\\n\\\n            --out-dir R2$SUFFIX \\n\\\n        fi\\n\\\n    fi\\n\\\n    if [ \\'' + inputs.crop_length + '\\' == \\'0\\' ]; then\\n\\\n            SUFFIX=$SUFFIX\\n\\\n    else\\n\\\n        NEW_SUFFIX=\"$SUFFIX\"_cropped\\n\\\n        python3 $(which encode_task_trimmomatic.py) \\\\\\n\\\n            --fastq1 R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"--fastq2 R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            --crop-length ' + inputs.crop_length + ' \\\\\\n\\\n            --crop-length-tol ' + inputs.crop_length_tol + ' \\\\\\n\\\n            --phred-score-format ' + inputs.trimmomatic_phred_score_format + ' \\\\\\n\\\n            --out-dir-R1 R1$NEW_SUFFIX \\\\\\n\\\n            ' + (inputs.paired_end ? \"--out-dir-R2 R2$NEW_SUFFIX\" : \"\") + ' \\\\\\n\\\n            --trimmomatic-java-heap ' + ( inputs.trimmomatic_java_heap ? inputs.trimmomatic_java_heap : Math.round(mem_gb * 0.9)) + 'G \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n        SUFFIX=$NEW_SUFFIX \\n\\\n    fi\\n\\\n    if [ ' + inputs.aligner + ' == \\'bwa\\' ]; then \\n\\\n        python3 $(which encode_task_bwa.py) \\\\\\n\\\n            ' + inputs.idx_tar.path + ' \\\\\\n\\\n            R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.use_bwa_mem_for_pe ? \"--use-bwa-mem-for-pe\" : \"\") + ' \\\\\\n\\\n            --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n    \\n\\\n    elif [ ' + inputs.aligner + ' == \\'bowtie2\\' ]; then \\n\\\n        python3 $(which encode_task_bowtie2.py) \\\\\\n\\\n            ' + inputs.idx_tar.path + ' \\\\\\n\\\n            R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            --multimapping ' + inputs.multimapping + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n    else \\n\\\n        python3 ${custom_align_py} \\\\\\n\\\n            ' + inputs.idx_tar.path + ' \\\\\\n\\\n            R1$SUFFIX/*.fastq.gz \\\\\\n\\\n            ' + (inputs.paired_end ? \"R2$SUFFIX/*.fastq.gz\" : \"\") + ' \\\\\\n\\\n            ' + (inputs.paired_end ? \"--paired-end\" : \"\") + ' \\\\\\n\\\n            --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n            --nth ' + inputs.cpu + ' \\n\\\n    fi\\n\\\n    python3 $(which encode_task_post_align.py) \\\\\\n\\\n        R1$SUFFIX/*.fastq.gz $(ls *.bam) \\\\\\n\\\n        --mito-chr-name ' + inputs.mito_chr_name + ' \\\\\\n\\\n        --mem-gb ' + samtools_mem_gb + ' \\\\\\n\\\n        --nth ' + inputs.cpu + ' \\n\\\n    rm -rf R1 R2 R1$SUFFIX R2$SUFFIX \\n\\\n    '\n}",
                "writable": false
              },
              {
                "entryname": "tmp_fastqs.tsv",
                "entry": "${\n    // wdl functions\n    function transpose(matrix) {\n        var rows = matrix.length, cols = matrix[0].length;\n        var grid = [];\n        for (var j = 0; j < cols; j++) {\n            grid[j] = Array(rows);\n        }\n        for (var i = 0; i < rows; i++) {\n        for (var j = 0; j < cols; j++) {\n            grid[j][i] = matrix[i][j];\n        }\n    }\n    return grid;  \n    }\n    \n    var fastq1 = Array();\n    var fastq2 = Array();\n    var ind1=0;\n    var ind2=0;\n    \n    if(inputs.in_fastqs){\n        var fq=[].concat(inputs.in_fastqs)\n    \n        for (var i=0; i < fq.length; i++){\n            if (fq[i].metadata['paired_end']=='1'){\n                ind1=fq[i].metadata['case_id'];\n                fastq1[ind1-1]=fq[i].path;\n            } \n            else if (fq[i].metadata['paired_end']=='2'){\n                ind2=fq[i].metadata['case_id']\n                fastq2[ind2-1]=fq[i].path;\n            }\n            else{\n                ind1=fq[i].metadata['case_id'];\n                fastq1[ind1-1]=fq[i].path;\n            } \n        }\n        \n    }\n    \n    \n   \n    var tmp_fastqs = inputs.paired_end ? transpose([fastq1, fastq2]) : transpose([fastq1])\n    return tmp_fastqs.map(function(d){ return d.join('\\t');\n        }).join('\\n');\n}",
                "writable": false
              }
            ]
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619210816,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619210908,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-ca634748/h-54bb8046/h-09d7cb60/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619210908,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619210816,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "abcbf41df2dbc3ef764a1bc4fef54a74759d6cb298de35081452033be49bb1690"
      },
      "label": "Align R1",
      "scatter": [
        "in_fastqs"
      ],
      "sbg:x": -2660.04150390625,
      "sbg:y": -964.3985595703125
    },
    {
      "id": "filter_r1",
      "in": [
        {
          "id": "in_bam",
          "source": "align_r1/out_bam"
        },
        {
          "id": "in_reference",
          "source": "in_reference"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "no_dup_removal",
          "default": true
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        }
      ],
      "out": [
        {
          "id": "out_nodup_bam"
        },
        {
          "id": "out_samstat_qc"
        },
        {
          "id": "out_dup_qc"
        },
        {
          "id": "out_lib_complexity_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-filter-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_bam",
            "type": "File?",
            "label": "Input BAM file",
            "doc": "Input BAM file.",
            "sbg:fileTypes": "BAM"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness. Setting this ON means that all replicates are paired ended."
          },
          {
            "sbg:category": "App Settings",
            "id": "multimapping",
            "type": "int?",
            "label": "Multimapping [bowtie2 option]",
            "doc": "Multimapping option.",
            "default": 0
          },
          {
            "sbg:category": "Inputs",
            "id": "in_reference",
            "type": "File?",
            "label": "Reference file",
            "doc": "Reference FASTA file.",
            "sbg:fileTypes": "FA, FASTA, FA.GZ, FASTA.GZ"
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "False",
            "id": "redact_nodup_bam",
            "type": "boolean?",
            "label": "Redact filtered/nodup BAM",
            "doc": "Redact filtered/nodup BAM at the end of the filtering step (task filter). Raw BAM from the aligner (task align) will still remain unredacted. Quality metrics on filtered BAM will be calculated before being redacted. However, all downstream analyses (e.g. peak-calling) will be done on the redacted BAM. If you start from nodup BAM then this flag will not be active."
          },
          {
            "sbg:toolDefaultValue": "picard",
            "sbg:category": "App Settings",
            "id": "dup_marker",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "picard",
                  "sambamba"
                ],
                "name": "dup_marker"
              }
            ],
            "label": "Marker for duplicate reads",
            "doc": "Marker for duplicate reads. Choose picard for Picard MarkDuplicates or sambamba for sambamba markdup."
          },
          {
            "sbg:toolDefaultValue": "30",
            "sbg:category": "App Settings",
            "id": "mapq_thresh",
            "type": "int?",
            "label": "Threshold for low MAPQ reads removal",
            "doc": "Threshold for low MAPQ reads removal. Low MAPQ reads are filtered out while filtering BAM.",
            "default": 30
          },
          {
            "sbg:toolDefaultValue": "None (empty string)",
            "sbg:category": "App Settings",
            "id": "filter_chrs",
            "type": "string[]?",
            "label": "Chromosomes to be filtered",
            "doc": "List of chromosomes to be filtered out while filtering BAM. It is empty by default, hence no filtering out of specfic chromosomes. It is case-sensitive. Use exact word for chromosome names.",
            "default": []
          },
          {
            "sbg:category": "Inputs",
            "id": "in_chrsz",
            "type": "File",
            "label": "Chromosome sizes file",
            "doc": "A 2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "False",
            "sbg:category": "App Settings",
            "id": "no_dup_removal",
            "type": "boolean?",
            "label": "Disable removal of duplicate reads",
            "doc": "Disable removal of duplicate reads during filtering BAM. Duplicate reads are filtererd out during filtering BAMs to gerenate NODUP_BAM. This flag will keep all duplicate reads in NODUP_BAM."
          },
          {
            "sbg:category": "App Settings",
            "sbg:toolDefaultValue": "None (empty string)",
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial chromosome name, e.g. chrM, MT. Mitochondrial reads defined here will be filtered out during filtering BAMs step."
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "4",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPU cores",
            "doc": "Number of CPU cores",
            "default": 4
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.4",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory factor",
            "doc": "Multiplication factor to determine memory required for task.",
            "default": 0.4
          },
          {
            "sbg:category": "Resource option",
            "sbg:toolDefaultValue": "0.9",
            "id": "picard_java_heap",
            "type": "float?",
            "label": "Maximum Java heap",
            "doc": "Maximum memory for Picard tools MarkDuplicates. If not defined, 90% of filter task's memory will be used."
          }
        ],
        "outputs": [
          {
            "id": "out_nodup_bam",
            "doc": "Filtered BAM file.",
            "label": "Filtered BAM",
            "type": "File?",
            "outputBinding": {
              "glob": "*.bam",
              "outputEval": "$(inheritMetadata(self, inputs.in_bam))"
            },
            "secondaryFiles": [
              {
                "pattern": ".bai",
                "required": false
              }
            ],
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "out_samstat_qc",
            "doc": "SAMstats log for filtered BAM file.",
            "label": "SAMstats log",
            "type": "File?",
            "outputBinding": {
              "glob": "*.samstats.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "out_dup_qc",
            "doc": "Dup QC for filtered BAM file.",
            "label": "Dup QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.dup.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "out_lib_complexity_qc",
            "doc": "Library complexity QC for filtered BAM file.",
            "label": "Library complexity QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.lib_complexity.qc"
            },
            "sbg:fileTypes": "QC"
          }
        ],
        "doc": "- Filter ATAC-Seq tool is based on the \u201cfilter\u201d WDL task from the Chip-Seq pipeline, developed by ENCODE DCC.\n- The tool executes the \u201cencode_task_filter.py\u201d script, which first filters (removes unmapped/low-quality reads) and sorts the BAM file with Samtools View and Samtools Sort, then it checks if filtered BAM is empty, i.e., if no reads are found in filtered BAM, and if yes, raises an error.\n- Then, it locates and tags duplicate reads in a BAM file with Picard v2.20.7 or Sambamba v0.6.6 and removes them with Samtools View.\n- After this step, it checks again if the filtered/deduplicated BAM file is empty, and if yes, raises an error. If a CHRSZ file is provided Samtools View is used to remove mitochondrial alignments from BAM file.\n- The filtered/deduplicated BAM file is indexed with SAMtools Index and SAMStat is run in order to generate sequence statistics.\n- Additionally, it runs Bedtools Bamtobed, and parses the output in order to generate a PBC QC file (.lib_complexity.qc).",
        "label": "ENCODE ChIP-Seq Filter CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    if(inputs.in_bam){\n        var cmd='';\n        cmd+='python3 $(which encode_task_filter.py) ';\n        cmd+=inputs.in_bam.path;\n        if(inputs.paired_end) cmd+=' --paired-end';\n        if(inputs.multimapping) cmd+=' --multimapping '+inputs.multimapping;\n        if (inputs.dup_marker) cmd+=' --dup-marker '+inputs.dup_marker;\n        if (inputs.mapq_thresh) cmd+=' --mapq-thresh '+inputs.mapq_thresh;\n        \n        // --filter-chrs\n        if(inputs.filter_chrs){\n            var chrs = Array();\n            for (var i = 0; i < inputs.filter_chrs.length; i++){\n                chrs.push(inputs.filter_chrs[i])\n            }\n            cmd+= \" --filter-chrs \" + chrs.join(\" \")\n        } else cmd+= \" --filter-chrs \"\n        \n        if (inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if (inputs.no_dup_removal) cmd+=' --no-dup-removal';\n        if(inputs.mito_chr_name) cmd+=' --mito-chr-name '+inputs.mito_chr_name;\n        \n        \n        \n        \n        // CPU and memory requirements\n        var arrSum = function(arr){\n            return arr.reduce(function(a,b){\n                return a + b }, 0);\n        }\n    \n        var bam_size = inputs.in_bam.size;\n        var input_file_size_gb = inputs.in_bam.size/1e+9;\n        var picard_java_heap_factor = 0.9;\n        var mem_gb = 6.0 + inputs.mem_factor * input_file_size_gb;\n        var samtools_mem_gb = 0.8 * mem_gb;\n        var picard_java_heap = inputs.picard_java_heap ? ' --picard-java-heap ' + inputs.picard_java_heap : ' --picard-java-heap ' + Math.round(mem_gb * picard_java_heap_factor) + \"G\";\n    \n\n        cmd+= \" --mem-gb \" + samtools_mem_gb + \" --nth \" + inputs.cpu + picard_java_heap;\n        \n         // encode_task_bam_to_pbam.py\n        if(inputs.redact_nodup_bam && inputs.in_reference){\n            cmd+= \" && python3 $(which encode_task_bam_to_pbam.py) $(ls *.bam) --ref-fa \" + inputs.in_reference.path + \" --delete-original-bam\"\n        }\n        \n        if (inputs.dup_marker == \"sambamba\") cmd+= \" && mv {}.dup.qc \" + inputs.in_bam.nameroot + \".dup.qc\";\n        \n    }\n    else  cmd=\"echo \\'No input BAM provided\\' 1>&2\";\n    \n    return cmd;\n    \n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb=0;\n    if(inputs.in_bam) input_file_size_gb = inputs.in_bam.size/1e+9;\n        \n    \n    var mem_gb = 6.0 + inputs.mem_factor * input_file_size_gb;\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n   \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212436,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212466,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:categories": [
          "ChipSeq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-2db7f98f/h-673067ba/h-562107ff/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619212466,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619212436,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "af4b77de7929ead2def9946e2c76143a6efe9f7aa490e36bb54f63ddc723d6072"
      },
      "label": "Filter R1",
      "scatter": [
        "in_bam"
      ],
      "sbg:x": -2443.9951171875,
      "sbg:y": -983.5281372070312
    },
    {
      "id": "bam2ta_r1",
      "in": [
        {
          "id": "in_bam",
          "source": "filter_r1/out_nodup_bam"
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        },
        {
          "id": "subsample",
          "source": "subsample"
        }
      ],
      "out": [
        {
          "id": "out_ta"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-bam2ta-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_bam",
            "type": "File?",
            "label": "Input BAM file",
            "doc": "Filtered (unmapped/low-quality and duplicate reads removed) BAM file. Output of the Filter ATAC-Seq tool.",
            "sbg:fileTypes": "BAM"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "False",
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness.",
            "default": false
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial chromosome name, e.g. chrM, MT. Mitochondrial reads defined here will be filtered out during filtering BAMs step."
          },
          {
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "id": "subsample",
            "type": "int?",
            "label": "Subsample reads",
            "doc": "Number of reads to subsample TAGALIGN file. Reads are shuffled and subsampled. This affects all downstream analyses after filtering BAM. (e.g. all TAG-ALIGN files, peak-calling). Reads will be shuffled only if actual number of reads in BAM exceeds this number.  0 means disabled.",
            "default": 0
          },
          {
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Options",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPUs",
            "doc": "Number of CPUs (threads) for tasks. Resource settings are used for determining an instance type on cloud backends (e.g. GCP, AWS).",
            "default": 2
          },
          {
            "sbg:toolDefaultValue": "0.35",
            "sbg:category": "Options",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory multiplication factor",
            "doc": "Multiplication factor to determine memory required for the task.",
            "default": 0.35
          },
          {
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Options",
            "id": "time_hr",
            "type": "int?",
            "label": "Time in hours",
            "doc": "Walltime (h) required for task bam2ta.",
            "default": 6
          },
          {
            "sbg:toolDefaultValue": "4.0",
            "sbg:category": "Options",
            "id": "disk_factor",
            "type": "float?",
            "label": "Disk multiplication factor",
            "doc": "Multiplication factor to determine persistent disk size. This factor will be multiplied to the size of filtered BAMs.",
            "default": 4
          }
        ],
        "outputs": [
          {
            "id": "out_ta",
            "doc": "TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM.",
            "label": "Tag-Align",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "$(inheritMetadata(self, inputs.in_bam))"
            },
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "doc": "- Encode Bam2ta tool is based on the \u201cbam2ta\u201d WDL task from the ATAC-Seq pipeline, developed by ENCODE DCC.\n- The tool converts a BAM file to a TAGALIGN file.\n- It executes the \u201cencode_task_bam2ta.py\u201d script, which runs Bedtools Bamtobed v2.29.0 and its output is further parsed in order to generate a Tag-Align file (TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM).\n- If the number of reads are provided on the \u2018subsample\u2019 input port, the Tag-Align file will be subsampled and shuffled.\n- As a final step, TN5-shifting is performed on a TAGALIGN file.",
        "label": "ENCODE ChIP-Seq bam2ta CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.in_bam){\n        cmd+='python3 $(which encode_task_bam2ta.py) ';\n        cmd+=inputs.in_bam.path;\n        cmd+=' --disable-tn5-shift';\n        if (inputs.paired_end) cmd+=' --paired-end';\n        if (inputs.mito_chr_name) cmd+=' --mito-chr-name '+inputs.mito_chr_name;\n        if (inputs.subsample) cmd+=' --subsample '+inputs.subsample;\n        \n        var input_file_size_gb = inputs.in_bam.size/1e+9;\n        var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n        var samtools_mem_gb = 0.8 * mem_gb;\n    \n        cmd+= ' --mem-gb '+samtools_mem_gb;\n        \n        cmd+=' --nth '+inputs.cpu;\n        \n    }\n    else cmd=\"echo \\'No input BAM file provided\\' 1>&2\";\n    \n    return cmd\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb=0;\n    if (inputs.in_bam) var input_file_size_gb = inputs.in_bam.size/1e+9;\n    \n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n    \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212915,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619212958,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:license": "MIT",
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:wrapperAuthor": "",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:links": [],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-e3940d04/h-79b795f5/h-e7f359a6/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619212958,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619212915,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ac1279246141a3e278b6cc531e26588359856e0a808748c2e8d331d990270693e"
      },
      "label": "bam2ta R1",
      "scatter": [
        "in_bam"
      ],
      "sbg:x": -2253.25439453125,
      "sbg:y": -977.3985595703125
    },
    {
      "id": "xcor",
      "in": [
        {
          "id": "in_ta",
          "source": "bam2ta_r1/out_ta"
        },
        {
          "id": "mito_chr_name",
          "source": "mito_chr_name"
        },
        {
          "id": "subsample",
          "source": "subsample"
        },
        {
          "id": "exclusion_range_min",
          "source": "exclusion_range_min"
        },
        {
          "id": "exclusion_range_max",
          "source": "exclusion_range_max"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        }
      ],
      "out": [
        {
          "id": "plot_pdf"
        },
        {
          "id": "plot_png"
        },
        {
          "id": "score"
        },
        {
          "id": "fraglen_log"
        },
        {
          "id": "fraglen"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-xcor-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_ta",
            "type": "File",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM.",
            "sbg:fileTypes": "TAGALIGN, TAGALIGN.GZ"
          },
          {
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Sequencing endedness."
          },
          {
            "id": "mito_chr_name",
            "type": "string?",
            "label": "Mitochondrial chromosome name",
            "doc": "Mitochondrial chromosome name."
          },
          {
            "sbg:toolDefaultValue": "15000000",
            "id": "subsample",
            "type": "int?",
            "label": "Subsample reads",
            "doc": "Subsample reads for cross-corrlelation analysis only. Number of reads to subsample TAGALIGN. This will be used for Xcor tool only. It will not affect any downstream analysis. It is for cross-correlation analysis only. 0 means disabled.",
            "default": 15000000
          },
          {
            "sbg:toolDefaultValue": "2",
            "id": "cpu",
            "type": "int?",
            "label": "Number of CPUs",
            "doc": "Number of CPUs (threads) for tasks. Resource settings are used for determining an instance type on cloud backends (e.g. GCP, AWS).",
            "default": 2
          },
          {
            "sbg:toolDefaultValue": "1.0",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory multiplication factor",
            "doc": "Multiplication factor to determine memory required for the task.",
            "default": 1
          },
          {
            "id": "exclusion_range_min",
            "type": "int?",
            "label": "Exclusion minimum for cross-correlation analysis",
            "doc": "Exclusion minimum for cross-correlation analysis.",
            "default": -500
          },
          {
            "id": "exclusion_range_max",
            "type": "int?",
            "label": "Exclusion maximum for cross-correlation analysis",
            "doc": "Exclusion maximum for cross-correlation analysis."
          },
          {
            "sbg:toolDefaultValue": "tf",
            "id": "pipeline_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "tf",
                  "histone",
                  "control"
                ],
                "name": "pipeline_type"
              }
            ],
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          }
        ],
        "outputs": [
          {
            "id": "plot_pdf",
            "doc": "Cross-correlation analysis plot in a PDF format.",
            "label": "Plot PDF",
            "type": "File?",
            "outputBinding": {
              "glob": "*.cc.plot.pdf"
            },
            "sbg:fileTypes": "PDF"
          },
          {
            "id": "plot_png",
            "doc": "Cross-correlation analysis plot in a PNG format.",
            "label": "Plot PNG",
            "type": "File?",
            "outputBinding": {
              "glob": "*.cc.plot.png"
            },
            "sbg:fileTypes": "PNG"
          },
          {
            "id": "score",
            "doc": "Cross-correlation analysis score.",
            "label": "Score",
            "type": "File?",
            "outputBinding": {
              "glob": "*.cc.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "fraglen_log",
            "doc": "TXT file containing fragment length.",
            "label": "Fraglen Log",
            "type": "File?",
            "outputBinding": {
              "glob": "*.cc.fraglen.txt"
            },
            "sbg:fileTypes": "LOG"
          },
          {
            "id": "fraglen",
            "doc": "Fragment length.",
            "label": "Fragment length",
            "type": "int?",
            "outputBinding": {
              "loadContents": true,
              "glob": "*.cc.fraglen.txt",
              "outputEval": "${\n    if(inputs.pipeline_type!='control'){\n        var int_fragment=parseInt(self[0].contents)\n        return int_fragment\n    }\n    \n}"
            }
          }
        ],
        "doc": "**Xcor** tool is based on the \u201cxcor\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n\n**Xcor** does cross-correlation analysis (including a plot) on subsampled TAG-ALIGNs. The \u201cencode_task_xcor.py\u201d script is executed, and in the first step the TAG-ALIGN file is subsampled, i.e., by default 15000000 reads are subsampled for cross-correlation analysis only (it will not affect any downstream analysis after filtering BAM, it is for cross-correlation analysis only). In the final step, the \u201crun_spp.R\u201d Rscript is executed, which performs the cross-correlation analysis.\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Xcor CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.pipeline_type!='control'){\n        cmd+='python3 $(which encode_task_xcor.py) ';\n        cmd+=inputs.in_ta.path;\n        if(inputs.paired_end) cmd+=' --paired-end';\n        if(inputs.mito_chr_name) cmd+=' --mito-chr-name '+inputs.mito_chr_name;\n        if(inputs.subsample) cmd+=' --subsample '+inputs.subsample;\n        if(inputs.pipeline_type) cmd+=' --chip-seq-type '+inputs.pipeline_type\n        if(inputs.exclusion_range_min) cmd+=' --exclusion-range-min '+inputs.exclusion_range_min;\n        if(inputs.exclusion_range_max) cmd+=' --exclusion-range-max '+inputs.exclusion_range_max;\n        if(inputs.cpu) cmd+=' --nth '+inputs.cpu;\n        \n        \n    }\n    else cmd=\"echo \\'Xcor is disabled in control mode\\' 1>&2 \";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb = inputs.in_ta.size/1e+9;\n    var mem_gb = 8.0 + inputs.mem_factor * input_file_size_gb;\n    \n    var mem_mb=Math.round(mem_gb/1e-3);\n    var limit=Math.round(384/1e-3);\n    return mem_mb<limit ? mem_mb : limit;\n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619213433,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619213460,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:license": "MIT",
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:wrapperAuthor": "",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-967dd5f5/h-26f738aa/h-3fb826d7/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619213460,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619213433,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ab00e99c4e599675ad848be233e9d9515f29b6ee0bb4bda6a0dc3a2e799b93d60"
      },
      "label": "Xcor",
      "scatter": [
        "in_ta"
      ],
      "sbg:x": -2076.207763671875,
      "sbg:y": -961.0513305664062
    },
    {
      "id": "jsd",
      "in": [
        {
          "id": "in_nodup_bams",
          "source": [
            "filter_bio_replicates/out_nodup_bam"
          ]
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ctl_bams",
          "source": [
            "filter_controls/out_nodup_bam"
          ]
        },
        {
          "id": "enable_jsd",
          "source": "enable_jsd"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        }
      ],
      "out": [
        {
          "id": "out_plot"
        },
        {
          "id": "out_jsd_qcs"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-jsd-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_nodup_bams",
            "type": "File[]",
            "label": "Nodup BAM",
            "doc": "Filtered (unmapped/low-quality and duplicate reads removed) BAM file.",
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file."
          },
          {
            "sbg:toolDefaultValue": "30",
            "id": "mapq_thresh",
            "type": "int?",
            "label": "MAPQ threshold",
            "doc": "Threshold for low MAPQ reads removal. Low MAPQ reads are filtered out while filtering BAM.",
            "default": 30
          },
          {
            "id": "cpu",
            "type": "int?",
            "label": "Number of cores for task jsd",
            "doc": "Number of cores for task jsd.",
            "default": 4
          },
          {
            "id": "mem_factor",
            "type": "float?",
            "label": "Multiplication factor to determine memory required for task jsd",
            "doc": "Multiplication factor to determine memory required for task jsd.",
            "default": 0.1
          },
          {
            "id": "in_ctl_bams",
            "type": "File[]?",
            "label": "Filtered control BAM file",
            "doc": "Filtered control BAM file.",
            "sbg:fileTypes": "BAM"
          },
          {
            "id": "enable_jsd",
            "type": "boolean?",
            "label": "Enable Jsd",
            "doc": "Enable Jsd."
          },
          {
            "sbg:toolDefaultValue": "tf",
            "id": "pipeline_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "tf",
                  "histone",
                  "control"
                ],
                "name": "pipeline_type"
              }
            ],
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          }
        ],
        "outputs": [
          {
            "id": "out_plot",
            "doc": "Jensen-Shannon distance plot.",
            "label": "Jensen-Shannon distance plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.png"
            }
          },
          {
            "id": "out_jsd_qcs",
            "doc": "QC and logs.",
            "label": "QC and logs",
            "type": "File[]?",
            "outputBinding": {
              "glob": "*.jsd.qc"
            }
          }
        ],
        "doc": "**Jsd** tool is based on the \u201cjsd\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Jsd** plots Jensen-Shannon distance and metrics related to it.\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Jsd CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(!inputs.enable_jsd || inputs.pipeline_type=='control')cmd=\"echo \\'Jsd is disabled\\' 1>&2\";\n    else{\n        var bams=Array();\n        var bam_list=[].concat(inputs.in_nodup_bams);\n        for(var i=0; i<bam_list.length; i++) bams.push(bam_list[i].path);\n        bams=bams.join(' ');\n        var ctl_list=[];\n        if(inputs.in_ctl_bams) ctl_list=[].concat(inputs.in_ctl_bams);\n        cmd+='python3 $(which encode_task_jsd.py) ';\n        cmd+=bams;\n        if(ctl_list[0]) cmd+=' --ctl-bam '+ctl_list[0].path;\n        if(inputs.mapq_thresh) cmd+=' --mapq-thresh '+inputs.mapq_thresh;\n        if(inputs.in_blacklist) cmd+=' --blacklist '+inputs.in_blacklist.path;\n        if(inputs.cpu) cmd+=' --nth '+inputs.cpu;\n    }\n   \n    \n    return cmd\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    \n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var nodup_bams_size = Array();\n    \n    for ( var i = 0; i < inputs.in_nodup_bams.length; i++){\n        nodup_bams_size.push(inputs.in_nodup_bams[i].size);\n    }\n    \n    nodup_bams_size = arrSum(nodup_bams_size);\n    \n    var input_file_size_gb = (nodup_bams_size)/1e+9;\n    var mem_gb = 5.0 + inputs.mem_factor * input_file_size_gb;\n    var mem_mb=Math.round(mem_gb/1e-3);\n    var limit=Math.round(384/1e-3);\n    return mem_mb<limit ? mem_mb : limit;\n    \n}",
            "coresMin": "${\n    return inputs.cpu;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220014,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220059,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:wrapperAuthor": "",
        "sbg:license": "MIT",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-dbcb34bc/h-f3d43e70/h-17b52fab/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619220059,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619220014,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "af28cdd2b1fd10d802cb1cf067940e9082ff19348fb249e5f47aa5a57cb0aa36f"
      },
      "label": "Jsd",
      "sbg:x": -1836.4033203125,
      "sbg:y": -2225.900146484375
    },
    {
      "id": "pool_ta_controls",
      "in": [
        {
          "id": "in_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "bam2ta_controls/out_ta"
          ]
        }
      ],
      "out": [
        {
          "id": "out_ta_pooled"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-pool-ta-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_tas",
            "type": "File[]?",
            "label": "Input Tag-Aligns",
            "doc": "Bam2ta output. TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "col",
            "type": "int?",
            "label": "Columns",
            "doc": "Number of columns in pooled Tag-Align."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "out_prefix",
            "type": "string?",
            "label": "Prefix",
            "doc": "Basename prefix for output Tag-Align."
          }
        ],
        "outputs": [
          {
            "id": "out_ta_pooled",
            "doc": "Pooled Tag-Align file.",
            "label": "Pooled Tag-Align",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "${\n    if(inputs.in_tas){\n        var tas=[].concat(inputs.in_tas);\n        if(tas[0]){\n            inheritMetadata(self, inputs.in_tas)\n            return self\n            \n        }\n        \n    }\n}"
            },
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "doc": "- Encode Pool Ta is based on the \u201cpool_ta\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n- The tool takes an array of TAG-ALIGN files and compresses them into a single .pooled.tagAlign.gz file.",
        "label": "ENCODE ChIP-Seq Pool TA CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.in_tas && inputs.in_tas[0]){\n        var tas_list=[].concat(inputs.in_tas);\n        var tas=Array();\n        if (tas_list.length>1){\n            for(var i=0; i<tas_list.length; i++){\n                if(tas_list[i]) tas.push(tas_list[i].path);\n            } \n            tas=tas.join(' ');\n            cmd+='python3 $(which encode_task_pool_ta.py) '\n            cmd+=tas;\n            if (inputs.out_prefix) cmd+=' --prefix '+inputs.out_prefix;\n            if (inputs.col) cmd+=' --col '+inputs.col;\n            \n        }\n        else cmd+=\"echo \\' Only one TA file provided, pooling disabled \\' 1>&2 \";\n    }\n    else cmd+=\"echo \\' No TA files provided, pooling disabled \\' 1>&2 \";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 8000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220127,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220157,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:wrapperAuthor": "",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-94e38b03/h-dea376b9/h-5e87ea82/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619220157,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619220127,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a056fd414d308f4b2e304c65735a3af7b9c4f30265822aa6cde58647e4564e470"
      },
      "label": "Pool TA Controls",
      "sbg:x": -1833.2012939453125,
      "sbg:y": -1797.6917724609375
    },
    {
      "id": "pool_ta_bio_replicates",
      "in": [
        {
          "id": "in_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "bam2ta_bio_replicates/out_ta"
          ]
        }
      ],
      "out": [
        {
          "id": "out_ta_pooled"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-pool-ta-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_tas",
            "type": "File[]?",
            "label": "Input Tag-Aligns",
            "doc": "Bam2ta output. TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "col",
            "type": "int?",
            "label": "Columns",
            "doc": "Number of columns in pooled Tag-Align."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "out_prefix",
            "type": "string?",
            "label": "Prefix",
            "doc": "Basename prefix for output Tag-Align."
          }
        ],
        "outputs": [
          {
            "id": "out_ta_pooled",
            "doc": "Pooled Tag-Align file.",
            "label": "Pooled Tag-Align",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "${\n    if(inputs.in_tas){\n        var tas=[].concat(inputs.in_tas);\n        if(tas[0]){\n            inheritMetadata(self, inputs.in_tas)\n            return self\n            \n        }\n        \n    }\n}"
            },
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "doc": "- Encode Pool Ta is based on the \u201cpool_ta\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n- The tool takes an array of TAG-ALIGN files and compresses them into a single .pooled.tagAlign.gz file.",
        "label": "ENCODE ChIP-Seq Pool TA CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.in_tas && inputs.in_tas[0]){\n        var tas_list=[].concat(inputs.in_tas);\n        var tas=Array();\n        if (tas_list.length>1){\n            for(var i=0; i<tas_list.length; i++){\n                if(tas_list[i]) tas.push(tas_list[i].path);\n            } \n            tas=tas.join(' ');\n            cmd+='python3 $(which encode_task_pool_ta.py) '\n            cmd+=tas;\n            if (inputs.out_prefix) cmd+=' --prefix '+inputs.out_prefix;\n            if (inputs.col) cmd+=' --col '+inputs.col;\n            \n        }\n        else cmd+=\"echo \\' Only one TA file provided, pooling disabled \\' 1>&2 \";\n    }\n    else cmd+=\"echo \\' No TA files provided, pooling disabled \\' 1>&2 \";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 8000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220127,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220157,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:wrapperAuthor": "",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-eab99f01/h-3afaf058/h-8e189526/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619220157,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619220127,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a056fd414d308f4b2e304c65735a3af7b9c4f30265822aa6cde58647e4564e470"
      },
      "label": "Pool TA Bio-replicates",
      "sbg:x": -1828.0201416015625,
      "sbg:y": -1601.3018798828125
    },
    {
      "id": "pool_ta_pr1",
      "in": [
        {
          "id": "in_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "spr/ta_pr1"
          ]
        }
      ],
      "out": [
        {
          "id": "out_ta_pooled"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-pool-ta-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_tas",
            "type": "File[]?",
            "label": "Input Tag-Aligns",
            "doc": "Bam2ta output. TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "col",
            "type": "int?",
            "label": "Columns",
            "doc": "Number of columns in pooled Tag-Align."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "out_prefix",
            "type": "string?",
            "label": "Prefix",
            "doc": "Basename prefix for output Tag-Align."
          }
        ],
        "outputs": [
          {
            "id": "out_ta_pooled",
            "doc": "Pooled Tag-Align file.",
            "label": "Pooled Tag-Align",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "${\n    if(inputs.in_tas){\n        var tas=[].concat(inputs.in_tas);\n        if(tas[0]){\n            inheritMetadata(self, inputs.in_tas)\n            return self\n            \n        }\n        \n    }\n}"
            },
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "doc": "- Encode Pool Ta is based on the \u201cpool_ta\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n- The tool takes an array of TAG-ALIGN files and compresses them into a single .pooled.tagAlign.gz file.",
        "label": "ENCODE ChIP-Seq Pool TA CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.in_tas && inputs.in_tas[0]){\n        var tas_list=[].concat(inputs.in_tas);\n        var tas=Array();\n        if (tas_list.length>1){\n            for(var i=0; i<tas_list.length; i++){\n                if(tas_list[i]) tas.push(tas_list[i].path);\n            } \n            tas=tas.join(' ');\n            cmd+='python3 $(which encode_task_pool_ta.py) '\n            cmd+=tas;\n            if (inputs.out_prefix) cmd+=' --prefix '+inputs.out_prefix;\n            if (inputs.col) cmd+=' --col '+inputs.col;\n            \n        }\n        else cmd+=\"echo \\' Only one TA file provided, pooling disabled \\' 1>&2 \";\n    }\n    else cmd+=\"echo \\' No TA files provided, pooling disabled \\' 1>&2 \";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 8000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220127,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220157,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:wrapperAuthor": "",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-102196c8/h-efa4bd3d/h-cb0f8d0b/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619220157,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619220127,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a056fd414d308f4b2e304c65735a3af7b9c4f30265822aa6cde58647e4564e470"
      },
      "label": "Pool TA PR1",
      "sbg:x": -1795.0604248046875,
      "sbg:y": -1245.9132080078125
    },
    {
      "id": "pool_ta_pr2",
      "in": [
        {
          "id": "in_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "spr/ta_pr2"
          ]
        }
      ],
      "out": [
        {
          "id": "out_ta_pooled"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-pool-ta-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_tas",
            "type": "File[]?",
            "label": "Input Tag-Aligns",
            "doc": "Bam2ta output. TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "col",
            "type": "int?",
            "label": "Columns",
            "doc": "Number of columns in pooled Tag-Align."
          },
          {
            "sbg:category": "Options",
            "sbg:toolDefaultValue": "None",
            "id": "out_prefix",
            "type": "string?",
            "label": "Prefix",
            "doc": "Basename prefix for output Tag-Align."
          }
        ],
        "outputs": [
          {
            "id": "out_ta_pooled",
            "doc": "Pooled Tag-Align file.",
            "label": "Pooled Tag-Align",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "${\n    if(inputs.in_tas){\n        var tas=[].concat(inputs.in_tas);\n        if(tas[0]){\n            inheritMetadata(self, inputs.in_tas)\n            return self\n            \n        }\n        \n    }\n}"
            },
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "doc": "- Encode Pool Ta is based on the \u201cpool_ta\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n- The tool takes an array of TAG-ALIGN files and compresses them into a single .pooled.tagAlign.gz file.",
        "label": "ENCODE ChIP-Seq Pool TA CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.in_tas && inputs.in_tas[0]){\n        var tas_list=[].concat(inputs.in_tas);\n        var tas=Array();\n        if (tas_list.length>1){\n            for(var i=0; i<tas_list.length; i++){\n                if(tas_list[i]) tas.push(tas_list[i].path);\n            } \n            tas=tas.join(' ');\n            cmd+='python3 $(which encode_task_pool_ta.py) '\n            cmd+=tas;\n            if (inputs.out_prefix) cmd+=' --prefix '+inputs.out_prefix;\n            if (inputs.col) cmd+=' --col '+inputs.col;\n            \n        }\n        else cmd+=\"echo \\' Only one TA file provided, pooling disabled \\' 1>&2 \";\n    }\n    else cmd+=\"echo \\' No TA files provided, pooling disabled \\' 1>&2 \";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 8000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220127,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619220157,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:wrapperAuthor": "",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-1fadb38b/h-af31f652/h-c28d6dc4/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619220157,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619220127,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a056fd414d308f4b2e304c65735a3af7b9c4f30265822aa6cde58647e4564e470"
      },
      "label": "Pool TA PR2",
      "sbg:x": -1788.1207275390625,
      "sbg:y": -1089.0137939453125
    },
    {
      "id": "choose_ctl",
      "in": [
        {
          "id": "in_tas",
          "source": [
            "bam2ta_bio_replicates/out_ta"
          ]
        },
        {
          "id": "in_ctl_tas",
          "source": [
            "bam2ta_controls/out_ta"
          ]
        },
        {
          "id": "in_ta_pooled",
          "source": "pool_ta_bio_replicates/out_ta_pooled"
        },
        {
          "id": "in_ctl_ta_pooled",
          "source": "pool_ta_controls/out_ta_pooled"
        }
      ],
      "out": [
        {
          "id": "chosen_ctl_id_tsv"
        },
        {
          "id": "chosen_ctl_subsample_tsv"
        },
        {
          "id": "chosen_ctl_subsample_pooled_txt"
        },
        {
          "id": "chosen_ctl_ta_ids"
        },
        {
          "id": "chosen_ctl_ta_subsample"
        },
        {
          "id": "chosen_ctl_ta_subsample_pooled"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-choose-ctl-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_tas",
            "type": "File[]?",
            "label": "Tag-Align",
            "doc": "List of experiment TAG-ALIGN per IP replicate.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Control Tag-Align",
            "doc": "List of control TAG-ALIGN per IP replicate.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_ta_pooled",
            "type": "File?",
            "label": "Pooled Tag-Align",
            "doc": "Pooled experiment TAG-ALIGN.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_ctl_ta_pooled",
            "type": "File?",
            "label": "Pooled control Tag-Align",
            "doc": "Pooled control TAG-ALIGN.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:toolDefaultValue": "1.2",
            "id": "ctl_depth_ratio",
            "type": "float?",
            "label": "Control depth ratio",
            "doc": "Control depth ratio (between any two controls).",
            "default": 1.2
          },
          {
            "id": "always_use_pooled_ctl",
            "type": "boolean?",
            "label": "Always use pooled control for all IP replicates",
            "doc": "Always use pooled control for all IP replicates."
          },
          {
            "sbg:toolDefaultValue": "200000000",
            "id": "ctl_depth_limit",
            "type": "int?",
            "label": "Control depth limit",
            "doc": "Control depth limit. If read depth of chosen control is over this limit then such control should be subsampled.",
            "default": 200000000
          },
          {
            "sbg:toolDefaultValue": "5",
            "id": "exp_ctl_depth_ratio_limit",
            "type": "float?",
            "label": "Exp vs. control depth ratio limit",
            "doc": "Exp vs. control depth ratio limit.",
            "default": 5
          }
        ],
        "outputs": [
          {
            "id": "chosen_ctl_id_tsv",
            "doc": "Control TSV.",
            "label": "Control TSV",
            "type": "File?",
            "outputBinding": {
              "glob": "chosen_ctl.tsv"
            },
            "sbg:fileTypes": "TSV"
          },
          {
            "id": "chosen_ctl_subsample_tsv",
            "doc": "Control subsample TSV.",
            "label": "Control subsample TSV",
            "type": "File?",
            "outputBinding": {
              "glob": "chosen_ctl_subsample.tsv"
            }
          },
          {
            "id": "chosen_ctl_subsample_pooled_txt",
            "doc": "Control subsample pooled TXT",
            "label": "Control subsample pooled TXT",
            "type": "File?",
            "outputBinding": {
              "glob": "chosen_ctl_subsample_pooled.txt"
            },
            "sbg:fileTypes": "TXT"
          },
          {
            "id": "chosen_ctl_ta_ids",
            "doc": "Control TA ids.",
            "label": "Control TA ids",
            "type": "int[]?",
            "outputBinding": {
              "loadContents": true,
              "glob": "chosen_ctl.tsv",
              "outputEval": "${\n    if(inputs.in_ctl_tas && inputs.in_ctl_tas[0]){\n        var ids_ta = Array();\n        var list_self=[].concat(self)\n        var cont=list_self[0].contents;\n        var cont_len=cont.split(/\\r?\\n/)\n        for ( var i = 0; i < cont_len.length-1; i++){\n            ids_ta.push(parseInt(cont_len[i]))\n        }\n \n        return ids_ta\n    }\n}"
            }
          },
          {
            "id": "chosen_ctl_ta_subsample",
            "doc": "Control TA subsample.",
            "label": "Control TA subsample",
            "type": "int[]?",
            "outputBinding": {
              "loadContents": true,
              "glob": "chosen_ctl_subsample.tsv",
              "outputEval": "${\n    if(inputs.in_ctl_tas && inputs.in_ctl_tas[0]){\n        var subsample_ta = Array();\n        var list_self=[].concat(self)\n        var cont=list_self[0].contents;\n        var cont_len=cont.split(/\\r?\\n/)\n        for ( var i = 0; i < cont_len.length-1; i++){\n            subsample_ta.push(parseInt(cont_len[i]))\n        }\n    \n        return subsample_ta\n    }\n}"
            }
          },
          {
            "id": "chosen_ctl_ta_subsample_pooled",
            "doc": "Control TA pooled.",
            "label": "Control TA pooled",
            "type": "int?",
            "outputBinding": {
              "loadContents": true,
              "glob": "chosen_ctl_subsample_pooled.txt",
              "outputEval": "${\n   if(inputs.in_ctl_tas && inputs.in_ctl_tas[0]){\n        var subsample_pooled = parseInt(self[0].contents)\n        return subsample_pooled\n   }\n}"
            }
          }
        ],
        "doc": "**Choose Ctl** tool is based on the \u201cchoose_ctl\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. \n\n**Choose Ctl** chooses appropriate control for each IP replicate. ctl_for_repN.tagAlign.gz will be generated for each IP replicate on --out-dir. This outputs a file with integers (chosen control index for each replicate per line).\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Choose Ctl CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.in_ctl_tas && inputs.in_ctl_tas[0]){\n        cmd+='python3 $(which encode_task_choose_ctl.py)';\n        var tas_list=[].concat(inputs.in_tas);\n        var tas=Array();\n        for(var i=0; i<tas_list.length; i++) tas.push(tas_list[i].path);\n        tas=tas.join(' ');\n        \n        var ctl_list=[].concat(inputs.in_ctl_tas);\n        var ctl=Array();\n        for(var i=0; i<ctl_list.length; i++) ctl.push(ctl_list[i].path);\n        ctl=ctl.join(' ');\n        \n        cmd+=' --tas '+tas;\n        cmd+=' --ctl-tas '+ctl;\n        if(inputs.in_ta_pooled) cmd+=' --ta-pooled '+inputs.in_ta_pooled.path;\n        if(inputs.in_ctl_ta_pooled) cmd+=' --ctl-ta-pooled '+inputs.in_ctl_ta_pooled.path;\n        if(inputs.ctl_depth_limit) cmd+=' --ctl-depth-ratio '+inputs.ctl_depth_ratio;\n        if(inputs.always_use_pooled_ctl) cmd+=' --always-use-pooled-ctl';\n        if(inputs.ctl_depth_limit) cmd+=' --ctl-depth-limit '+inputs.ctl_depth_limit;\n        if (inputs.exp_ctl_depth_ratio_limit) cmd+=' --exp-ctl-depth-ratio-limit '+inputs.exp_ctl_depth_ratio_limit;\n        \n    }\n    else cmd=\"echo \\' No control input provided\\' 1>&2\";\n    \n    return cmd\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221736,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221766,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-801675b3/h-b7ae0b19/h-d4f588e0/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619221766,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619221736,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "ac49e6e0f48ef49fc01c0957d1a588f542457e684d9935ec65f09ba2a155e2e2a"
      },
      "label": "Choose Ctl",
      "sbg:x": -1737.1005859375,
      "sbg:y": -1423.7320556640625
    },
    {
      "id": "subsample_ctl",
      "in": [
        {
          "id": "in_ta",
          "source": [
            "bam2ta_controls/out_ta"
          ]
        },
        {
          "id": "paired_end",
          "source": "ctl_paired_end"
        },
        {
          "id": "in_ctl_pooled",
          "source": "pool_ta_controls/out_ta_pooled"
        },
        {
          "id": "in_ctl_ta_ids",
          "source": "choose_ctl/chosen_ctl_ta_ids"
        },
        {
          "id": "in_ctl_ta_subsample",
          "source": "choose_ctl/chosen_ctl_ta_subsample"
        }
      ],
      "out": [
        {
          "id": "out_ta_control"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-subsample-ctl-1-7-1-cwl1-1/3",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_ta",
            "type": "File[]?",
            "label": "Control Tag-Aligns",
            "doc": "TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM. Output of Encode Bam2ta tool.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Paired-end."
          },
          {
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory",
            "doc": "Multiplication factor to determine memory required for task subsample_ctl.",
            "default": 14
          },
          {
            "sbg:category": "Inputs",
            "id": "in_ctl_pooled",
            "type": "File?",
            "label": "Pooled control Tag-Align",
            "doc": "Pooled control Tag-Align.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:category": "Inputs",
            "id": "in_ctl_ta_ids",
            "type": "int?",
            "label": "Control Tag-Align IDs",
            "doc": "Control Tag-Align IDs."
          },
          {
            "sbg:category": "Inputs",
            "sbg:toolDefaultValue": "None",
            "id": "in_ctl_ta_subsample",
            "type": "int?",
            "label": "Control Tag-Align subsamples",
            "doc": "Control Tag-Align subsamples."
          }
        ],
        "outputs": [
          {
            "id": "out_ta_control",
            "doc": "Subsampled Tag-Align",
            "label": "Subsampled Tag-Align",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "${\n   if((inputs.in_ctl_ta_ids || inputs.in_ctl_ta_ids==0) && inputs.in_ta && inputs.in_ta[0]){\n        var id = inputs.in_ctl_ta_ids;\n        var subsample = inputs.in_ctl_ta_subsample;\n        var ctl_ta = [].concat(inputs.in_ta); \n        var cmd = Array();\n        var base_arr = Array();\n        var ta;\n        var self_list=[].concat(self)\n        for(var i = 0; i< ctl_ta.length; i++){\n            base_arr.push(ctl_ta[i].basename);\n        }\n        var base_arr_all=base_arr;\n        if (inputs.in_ctl_pooled) base_arr_all.push(inputs.in_ctl_pooled.basename);\n   \n        if(id<=-2) return ''\n        else if (subsample>0) {\n            for(var i=0; i<self_list.length; i++){\n                if(base_arr_all.indexOf(self_list[i].basename)==-1) return self_list[i]\n            }\n        }\n        else if(id==-1) {\n            for(var i=0; i<self_list.length; i++){\n                if(self_list[i].basename==inputs.in_ctl_pooled.basename) return self_list[i]\n            }\n        } \n        else{\n            for(var i=0; i<self_list.length; i++){\n                if(self_list[i].basename==ctl_ta[id].basename) return self_list[i]\n            }\n        }\n   }\n    \n}"
            }
          }
        ],
        "doc": "**Subsample Ctl** tool is based on the \u201ctask_subsample_ctl\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. This script does not check if number of reads in TA is higher than subsampling number (--subsample). If number of reads in TA is lower than subsampling number then TA will be just shuffled.\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Subsample Ctl CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if((inputs.in_ctl_ta_ids || inputs.in_ctl_ta_ids==0) && inputs.in_ta && inputs.in_ta[0]) {\n        var chosen_ctl_ta_id = inputs.in_ctl_ta_ids;\n        var chosen_ctl_ta_subsample = inputs.in_ctl_ta_subsample;\n         \n        var ctl_ta = [].concat(inputs.in_ta); \n        var arr = Array();\n        var ta;\n    \n        for(var i = 0; i< ctl_ta.length; i++) arr.push(ctl_ta[i].path);\n    \n        if(inputs.in_ctl_pooled){\n            var ctl_ta_pooled = inputs.in_ctl_pooled.path;\n            if(chosen_ctl_ta_id == -1) ta = ctl_ta_pooled;\n        }\n        else ta = arr[chosen_ctl_ta_id];\n    \n        var pe=inputs.paired_end ? ' --paired-end':'';\n    \n        if((chosen_ctl_ta_id > -2) && (chosen_ctl_ta_subsample > 0 )){\n            cmd += \"python3 $(which encode_task_subsample_ctl.py) \" + ta+ ' --subsample '+chosen_ctl_ta_subsample+pe;\n            \n        }\n        else cmd= \"echo \\'Conditions for running subsample_ctl were not fulfilled\\' 1>&2\"   ;\n    }\n    else cmd=\"echo \\' No inputs provided\\' 1>&2\";\n   \n    return cmd;\n    \n    \n    \n    \n  \n}\n    "
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb=0\n    if (inputs.in_ta && inputs.in_ta[0]) var input_file_size_gb = inputs.in_ta[0].size/10e+9;\n    var mem_gb = 4.0 + inputs.mem_factor*input_file_size_gb\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.in_ctl_pooled)",
              "$(inputs.in_ta)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221842,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221878,
            "sbg:revisionNotes": "from dev"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619377157,
            "sbg:revisionNotes": "updated memory expression"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619421652,
            "sbg:revisionNotes": "updated memory expression"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-2038e439/h-a9d9c7ed/h-c242a5c2/0",
        "sbg:revision": 3,
        "sbg:revisionNotes": "updated memory expression",
        "sbg:modifiedOn": 1619421652,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619221842,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a12313e57a68d03cfc3fbbaddcfef111e3676139511c6d5bc6d5986151ab3e37f"
      },
      "label": "Subsample Ctl",
      "scatter": [
        "in_ctl_ta_ids",
        "in_ctl_ta_subsample"
      ],
      "scatterMethod": "dotproduct",
      "sbg:x": -1532,
      "sbg:y": -1423.752197265625
    },
    {
      "id": "sbg_scatter_prepare_bio_replicates",
      "in": [
        {
          "id": "in_tas",
          "source": [
            "bam2ta_bio_replicates/out_ta"
          ]
        },
        {
          "id": "in_ctl_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "subsample_ctl/out_ta_control"
          ]
        }
      ],
      "out": [
        {
          "id": "out_ctl_ta"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/sbg-scatter-prepare-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_tas",
            "type": "File[]?",
            "label": "Input TA files",
            "doc": "Input TA files.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Input control TA files",
            "doc": "Input control TA files.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "outputs": [
          {
            "id": "out_ctl_ta",
            "doc": "Output control dict.",
            "label": "Output control dict",
            "type": "string?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "${\n    if(inputs.in_tas && inputs.in_tas[0]){\n        var ctl_list=[].concat(inputs.in_ctl_tas);\n        var ctls=[];\n \n        var tas_list=[].concat(inputs.in_tas);\n        if(ctl_list.length!=tas_list.length){\n            var dif=tas_list.length-ctl_list.length;\n            for(var i=0; i<dif; i++){\n                if(ctl_list[0]) ctl_list.push(ctl_list[0]); \n                else ctl_list.push(null);\n            \n            } \n            ctls=ctl_list;\n        }\n        else ctls=ctl_list;\n        var dict={};\n        for(var i=0; i<tas_list.length; i++){\n            if(ctls[i]) dict[tas_list[i].basename]=ctls[i].basename;\n            else dict[tas_list[i].basename]='null';\n        }\n    \n        return JSON.stringify(dict);\n    }\n    \n    \n}"
            }
          }
        ],
        "doc": "**SBG Scatter Prepare** is added to the pipeline to pair the TAGALIGN bio-replicate files to corresponding control files forming a dictionary where the keys are bio-replicate files basenames, and values are corresponding control files basenames if there is at least one control file provided, or empty strings if no controls were included in the analysis. Dictionaries are then forwarded as an input to peak callers in order to select an appropriate control file for each bio-replicate TAGALIGN file. Since there are viable use cases where the number of biological replicates and control files do not match, scatter cannot be performed on bio-replicates and controls simultaneously.",
        "label": "SBG Scatter Prepare CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "echo 'preparing files for scatter'"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 2000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/sevenbridges/ubuntu:14.04"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221617,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221675,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-a0a5dcae/h-5d9edaf5/h-25fca023/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619221675,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619221617,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "aef57a40c18e9eba810ce4e13833a3d4fb0f1e19e386692b86e9b710af5ef4454"
      },
      "label": "SBG Scatter Prepare Bio-replicates",
      "sbg:x": -1396.3018798828125,
      "sbg:y": -1850.4427490234375
    },
    {
      "id": "sbg_scatter_prepare_cwl1_pr1",
      "in": [
        {
          "id": "in_tas",
          "source": [
            "spr/ta_pr1"
          ]
        },
        {
          "id": "in_ctl_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "subsample_ctl/out_ta_control"
          ]
        }
      ],
      "out": [
        {
          "id": "out_ctl_ta"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/sbg-scatter-prepare-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_tas",
            "type": "File[]?",
            "label": "Input TA files",
            "doc": "Input TA files.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Input control TA files",
            "doc": "Input control TA files.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "outputs": [
          {
            "id": "out_ctl_ta",
            "doc": "Output control dict.",
            "label": "Output control dict",
            "type": "string?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "${\n    if(inputs.in_tas && inputs.in_tas[0]){\n        var ctl_list=[].concat(inputs.in_ctl_tas);\n        var ctls=[];\n \n        var tas_list=[].concat(inputs.in_tas);\n        if(ctl_list.length!=tas_list.length){\n            var dif=tas_list.length-ctl_list.length;\n            for(var i=0; i<dif; i++){\n                if(ctl_list[0]) ctl_list.push(ctl_list[0]); \n                else ctl_list.push(null);\n            \n            } \n            ctls=ctl_list;\n        }\n        else ctls=ctl_list;\n        var dict={};\n        for(var i=0; i<tas_list.length; i++){\n            if(ctls[i]) dict[tas_list[i].basename]=ctls[i].basename;\n            else dict[tas_list[i].basename]='null';\n        }\n    \n        return JSON.stringify(dict);\n    }\n    \n    \n}"
            }
          }
        ],
        "doc": "**SBG Scatter Prepare** is added to the pipeline to pair the TAGALIGN bio-replicate files to corresponding control files forming a dictionary where the keys are bio-replicate files basenames, and values are corresponding control files basenames if there is at least one control file provided, or empty strings if no controls were included in the analysis. Dictionaries are then forwarded as an input to peak callers in order to select an appropriate control file for each bio-replicate TAGALIGN file. Since there are viable use cases where the number of biological replicates and control files do not match, scatter cannot be performed on bio-replicates and controls simultaneously.",
        "label": "SBG Scatter Prepare CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "echo 'preparing files for scatter'"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 2000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/sevenbridges/ubuntu:14.04"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221617,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221675,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-a9778432/h-5c4f4508/h-8670c2dc/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619221675,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619221617,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "aef57a40c18e9eba810ce4e13833a3d4fb0f1e19e386692b86e9b710af5ef4454"
      },
      "label": "SBG Scatter Prepare PR1",
      "sbg:x": -1408.2213134765625,
      "sbg:y": -1564.10693359375
    },
    {
      "id": "sbg_scatter_prepare_cwl1_pr2",
      "in": [
        {
          "id": "in_tas",
          "source": [
            "spr/ta_pr2"
          ]
        },
        {
          "id": "in_ctl_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "subsample_ctl/out_ta_control"
          ]
        }
      ],
      "out": [
        {
          "id": "out_ctl_ta"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/sbg-scatter-prepare-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_tas",
            "type": "File[]?",
            "label": "Input TA files",
            "doc": "Input TA files.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Input control TA files",
            "doc": "Input control TA files.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          }
        ],
        "outputs": [
          {
            "id": "out_ctl_ta",
            "doc": "Output control dict.",
            "label": "Output control dict",
            "type": "string?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "${\n    if(inputs.in_tas && inputs.in_tas[0]){\n        var ctl_list=[].concat(inputs.in_ctl_tas);\n        var ctls=[];\n \n        var tas_list=[].concat(inputs.in_tas);\n        if(ctl_list.length!=tas_list.length){\n            var dif=tas_list.length-ctl_list.length;\n            for(var i=0; i<dif; i++){\n                if(ctl_list[0]) ctl_list.push(ctl_list[0]); \n                else ctl_list.push(null);\n            \n            } \n            ctls=ctl_list;\n        }\n        else ctls=ctl_list;\n        var dict={};\n        for(var i=0; i<tas_list.length; i++){\n            if(ctls[i]) dict[tas_list[i].basename]=ctls[i].basename;\n            else dict[tas_list[i].basename]='null';\n        }\n    \n        return JSON.stringify(dict);\n    }\n    \n    \n}"
            }
          }
        ],
        "doc": "**SBG Scatter Prepare** is added to the pipeline to pair the TAGALIGN bio-replicate files to corresponding control files forming a dictionary where the keys are bio-replicate files basenames, and values are corresponding control files basenames if there is at least one control file provided, or empty strings if no controls were included in the analysis. Dictionaries are then forwarded as an input to peak callers in order to select an appropriate control file for each bio-replicate TAGALIGN file. Since there are viable use cases where the number of biological replicates and control files do not match, scatter cannot be performed on bio-replicates and controls simultaneously.",
        "label": "SBG Scatter Prepare CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "echo 'preparing files for scatter'"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 2000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/sevenbridges/ubuntu:14.04"
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221617,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619221675,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-86a7317e/h-542f7b36/h-8dadb447/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619221675,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619221617,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "aef57a40c18e9eba810ce4e13833a3d4fb0f1e19e386692b86e9b710af5ef4454"
      },
      "label": "SBG Scatter Prepare PR2",
      "sbg:x": -1396.5433349609375,
      "sbg:y": -1227.603759765625
    },
    {
      "id": "call_peak_bio_replicates",
      "in": [
        {
          "id": "peak_caller",
          "source": "peak_caller"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        },
        {
          "id": "in_tas",
          "source": "bam2ta_bio_replicates/out_ta"
        },
        {
          "id": "fraglen",
          "source": "xcor/fraglen"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ctl_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "subsample_ctl/out_ta_control"
          ]
        },
        {
          "id": "control_dct",
          "source": "sbg_scatter_prepare_bio_replicates/out_ctl_ta"
        }
      ],
      "out": [
        {
          "id": "out_peak"
        },
        {
          "id": "out_bfilt_peak"
        },
        {
          "id": "out_bfilt_peak_bb"
        },
        {
          "id": "out_bfilt_peak_starch"
        },
        {
          "id": "out_bfilt_peak_hammock"
        },
        {
          "id": "out_frip_qc"
        },
        {
          "id": "out_peak_region_size_qc"
        },
        {
          "id": "out_peak_region_size_plot"
        },
        {
          "id": "out_num_peak_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-call-peak-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:toolDefaultValue": "macs2",
            "id": "peak_caller",
            "type": "string?",
            "label": "Peak caller",
            "doc": "Peak caller. Default: macs2.",
            "default": "macs2"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "pipeline_type",
            "type": {
              "type": "enum",
              "symbols": [
                "tf",
                "histone",
                "control"
              ],
              "name": "pipeline_type"
            },
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          },
          {
            "id": "in_tas",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM. TAGALIGN file (first) and control TAGALIGN file (second; optional).",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length is estimated by cross-correlation analysis, which is valid only when pipeline started from FASTQs. If defined, fragment length estimated by cross-correlation analysis is ignored."
          },
          {
            "sbg:toolDefaultValue": "hs",
            "id": "gensz",
            "type": "string?",
            "label": "Genome sizes",
            "doc": "Genome sizes. \"hs\" for human, \"mm\" for mouse or sum of 2nd columnin chromosome sizes file.",
            "default": "hs"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "50000000",
            "id": "cap_num_peak",
            "type": "string?",
            "label": "Upper limit on the number of peaks",
            "doc": "Cap number of peaks called from a peak-caller (MACS2)."
          },
          {
            "sbg:toolDefaultValue": "0.01",
            "id": "pval_thresh",
            "type": "float?",
            "label": "P-value threshold",
            "doc": "P-value threshold for MACS2 (macs2 callpeak -p).",
            "default": 0.01
          },
          {
            "id": "fdr_thresh",
            "type": "float?",
            "label": "FDR threshold for SPP",
            "doc": "FDR threshold for SPP.",
            "default": 0.01
          },
          {
            "id": "regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Reg-ex for chromosomes",
            "doc": "Reg-ex for chromosomes to keep while filtering peaks. Chromosomes defined here will be kept. All other chromosomes will be filtered out in .bfilt. peak file. This is done along with blacklist filtering peak file. For example: chr[\\dXY]+.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "cpu",
            "type": "int?",
            "label": "Number of cores for task call_peak",
            "doc": "Task call_peak call peaks on TAG-ALIGNs by using SPP/MACS2 peak caller. MACS2 is single-threaded so cpu will be fixed at 2 for MACS2.",
            "default": 6
          },
          {
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory required for task with macs2 as peak_caller",
            "doc": "This factor will be multiplied to the size of TAG-ALIGNs (BEDs) to determine required memory of instance.",
            "default": 5
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Control Tag_Align",
            "doc": "Control Tag_Align files",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "control_dct",
            "type": "string?",
            "label": "Dict pairing TA files with corresponding controls",
            "doc": "Dict pairing TA files with corresponding controls."
          }
        ],
        "outputs": [
          {
            "id": "out_peak",
            "doc": "Generated by encode_task_macs2_atac.py.",
            "label": "Peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*[!.][!b][!f][!i][!l][!t].' + peak_type + '.gz'\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            }
          },
          {
            "id": "out_bfilt_peak",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.gz'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_bb",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak bb",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.bb'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_starch",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak starch",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.starch'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_hammock",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak hammock",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.hammock.gz*'\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".tbi",
                "required": false
              }
            ]
          },
          {
            "id": "out_frip_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Frip QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.frip.qc"
            }
          },
          {
            "id": "out_peak_region_size_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.qc"
            }
          },
          {
            "id": "out_peak_region_size_plot",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.png"
            }
          },
          {
            "id": "out_num_peak_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Num peak QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.num_peak.qc"
            }
          }
        ],
        "doc": "**Call Peak** tool is based on the \u201ccall_peak\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Call Peak** calls peaks on a TAG-ALIGN file.\n\n First, it executes the \u201cencode_task_macs2_chip.py\u201d script, which executes Macs2 callpeak v2.2.4 which calls peaks on a TAG-ALIGN file (output of Bam2ta tool). The output of the previous step, *_peaks.narrowPeak file, is further parsed and the final output is *.narrowPeak.gz file. In the second step, the tool calls the \u201cencode_task_post_call_peak_chip.py\u201d script, which: if blacklist file is provided - filters peaks from .narrowPeak.gz based on blacklist BED file, converts PEAK file to bigBed, converts PEAK file to STARCH file, convert PEAK file to hammock.gz file, determines the fraction of reads in peaks (FRiP) score without fragment length, calculates (blacklist-filtered) PEAK region size QC/plot, and calculates number of peaks (blacklist-filtered).\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Call Peak CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    var cmd = '';\n    if(inputs.pipeline_type=='control') cmd+=\"echo \\' Peak calling is not performed in control mode \\' 1>&2\";\n    else if(inputs.pipeline_type=='histone' && inputs.peak_caller=='spp') cmd+=\"echo \\' spp peak caller not compatible with histone op mode \\' 1>&2 \";\n    else if(inputs.in_tas){\n        var cmd1='';\n        var tas_file_paths = Array();\n        var ctls=[].concat(inputs.in_ctl_tas);\n        tas_file_paths.push(inputs.in_tas.path);\n        if(inputs.control_dct){\n            var dict=JSON.parse(inputs.control_dct)\n            if (dict[inputs.in_tas.basename]!='null'){\n                for(var i=0; i<ctls.length; i++){\n                    if(ctls[i].basename==dict[inputs.in_tas.basename]){\n                        tas_file_paths.push(ctls[i].path);\n                        break\n                        \n                    } \n                }\n                \n            } \n        }\n        else{\n            if(ctls[0]) tas_file_paths.push(ctls[0].path)\n        }\n       \n        tas_file_paths = tas_file_paths.join(' ');\n        \n        if(inputs.peak_caller == \"macs2\"){\n            cmd1+=\"python3 $(which encode_task_macs2_chip.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.gensz) cmd1+=' --gensz '+ inputs.gensz;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '50000000';\n            if (inputs.pval_thresh) cmd1+=' --pval-thresh '+ inputs.pval_thresh;\n        } \n        else if(inputs.peak_caller == \"spp\"){\n            cmd1+=\"python3 $(which encode_task_spp.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '30000000';\n            if (inputs.fdr_thresh) cmd1+=' --fdr-thresh '+ inputs.fdr_thresh;\n            if (inputs.cpu) cmd1+=' --nth '+ inputs.cpu;\n        }\n        \n        var peak_type='narrowPeak';\n        if (inputs.peak_caller=='spp') peak_type='regionPeak';\n        \n        var cmd2 = '';\n        cmd2+=\"python3 $(which encode_task_post_call_peak_chip.py)\";\n        cmd2+=\" $(ls *Peak.gz)\"\n        cmd2+=\" --ta \" + inputs.in_tas.path;\n        if (inputs.regex_bfilt_peak_chr_name) cmd2+=\" --regex-bfilt-peak-chr-name '\" + inputs.regex_bfilt_peak_chr_name + \"'\";\n        if (inputs.in_chrsz) cmd2+=' --chrsz '+ inputs.in_chrsz.path;\n        if (inputs.fraglen) cmd2+=' --fraglen '+ inputs.fraglen;\n        cmd2+=' --peak-type '+ peak_type;\n        if (inputs.in_blacklist) cmd2+=' --blacklist '+ inputs.in_blacklist.path;\n        \n        cmd=cmd1+' && '+cmd2;\n        \n    }\n    else cmd+=\"echo \\' No TAGALIGN input files provided\\' 1>&2\";\n    \n    \n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var tas_sizes = Array();\n    if (inputs.in_tas) tas_sizes.push(inputs.in_tas.size);\n    if (inputs.in_ctl_tas && inputs.in_ctl_tas[0])  tas_sizes.push(inputs.in_ctl_tas[0].size);\n    tas_sizes = arrSum(tas_sizes);\n    \n   \n    var input_file_size_gb = tas_sizes/10e9;\n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n  \n}",
            "coresMin": "${\n    if(inputs.peak_caller == \"macs2\") return 2;\n    else return inputs.cpu;\n       \n\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223192,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223235,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-96e733da/h-3193acaf/h-79ef9799/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619223235,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223192,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a3bb2422c2581b02886791a25c7b12f178f3b72e6f410d3163083f85f9c87ea7d"
      },
      "label": "Call Peak Bio-replicates",
      "scatter": [
        "in_tas",
        "fraglen"
      ],
      "scatterMethod": "dotproduct",
      "sbg:x": -1183.9266357421875,
      "sbg:y": -2011.900146484375
    },
    {
      "id": "macs2_signal_track_bio_replicates",
      "in": [
        {
          "id": "in_tas",
          "source": "bam2ta_bio_replicates/out_ta"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "fraglen",
          "source": "xcor/fraglen"
        },
        {
          "id": "in_ctl_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "subsample_ctl/out_ta_control"
          ]
        },
        {
          "id": "control_dct",
          "source": "sbg_scatter_prepare_bio_replicates/out_ctl_ta"
        }
      ],
      "out": [
        {
          "id": "out_pval_bw"
        },
        {
          "id": "out_fc_bw"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-macs2-signal-track-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_tas",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM. [ta, control_ta]. control_ta is optional",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:toolDefaultValue": "hs",
            "id": "gensz",
            "type": "string?",
            "label": "Genome size",
            "doc": "Genome size (sum of entries in 2nd column of # chr. sizes file, or hs for human, ms for mouse).",
            "default": "hs"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "0.01",
            "id": "pval_thresh",
            "type": "float?",
            "label": "Pval threshold",
            "doc": "P value threshold for MACS2.",
            "default": 0.01
          },
          {
            "sbg:toolDefaultValue": "12.0",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory factor",
            "doc": "Multiplication factor to determine memory required for the task.",
            "default": 12
          },
          {
            "sbg:toolDefaultValue": "80.0",
            "id": "disk_factor",
            "type": "float?",
            "label": "Disk factor",
            "doc": "Multiplication factor to determine persistent disk size for task macs2_signal_track.",
            "default": 80
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length from xcor."
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Control Tag-Align",
            "doc": "Control Tag-Align file."
          },
          {
            "id": "control_dct",
            "type": "string?",
            "label": "Control dict",
            "doc": "Control dict"
          }
        ],
        "outputs": [
          {
            "id": "out_pval_bw",
            "doc": "P-value bigWig file.",
            "label": "P-value bigWig",
            "type": "File?",
            "outputBinding": {
              "glob": "*.pval.signal.bigwig",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            },
            "sbg:fileTypes": "BIGWIG"
          },
          {
            "id": "out_fc_bw",
            "doc": "Fold-change bigWig file.",
            "label": "FC bigWig",
            "type": "File?",
            "outputBinding": {
              "glob": "*.fc.signal.bigwig",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            },
            "sbg:fileTypes": "BIGWIG"
          }
        ],
        "doc": "**Macs2 Signal Track** tool is based on the \u201cmacs2_signal_track\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Macs2 Signal Track** generates the count signal track.\n\nThe \u201cencode_task_macs2_signal_track_chip.py\u201d script first executes Macs2 callpeak v2.2.4 which calls peaks on a TAG-ALIGN file which is the output of Bam2ta tool, and generates two files required for the next step: treatment bedGraph file, *_treat_pileup.bdg and control bedGraph file, *_control_lambda.bdg. \nThe second step executes Macs2 bdgcmp v2.2.4, that compares two signal tracks in bedGraph format, and produces bedGraph (*_FE.bdg) output file. In the third step Bedtools slop is executed, which increases the size of each feature in a feature file (bedGraph (*_FE.bdg) output of Macs2 bdgcmp v2.2.4) by a user-defined number of bases (0 in this case) and it restricts the resizing to the size of the chromosome. Its result is piped to BedClip stdin in order to remove problematic row(s) in a BED file. Next, any overlapping regions in a bedgraph file are sorted and removed by comparing two lines in a row. In the final step, bedGraphToBigWig is executed. The procedure is repeated one more time (without calling Macs2 callpeak again), where Macs2 bdgcmp is provided with SFACTOR input (the number of tags per million in the (compressed) BED file are provided on SFACTOR input).\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Macs2 Signal Track CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if (inputs.in_tas && inputs.fraglen){\n        cmd+='python3 $(which encode_task_macs2_signal_track_chip.py) ';\n        cmd+=inputs.in_tas.path;\n        if(inputs.in_ctl_tas){\n            if(inputs.control_dct){\n                var ctls=[].concat(inputs.in_ctl_tas);\n                var dict=JSON.parse(inputs.control_dct)\n                if (dict[inputs.in_tas.basename]!='null'){\n                    for(var i=0; i<ctls.length; i++){\n                        if(ctls[i].basename==dict[inputs.in_tas.basename]){\n                            cmd+=' '+inputs.in_ctl_tas[i].path;\n                            break\n                            \n                        } \n                    }\n            \n                } \n                \n            }\n            else{\n                if(inputs.in_ctl_tas[0]) cmd+=' '+inputs.in_ctl_tas[0].path;\n            } \n        }\n        if(inputs.fraglen) cmd+=' --fraglen '+inputs.fraglen;\n        if(inputs.gensz) cmd+=' --gensz '+inputs.gensz;\n        if(inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.pval_thresh) cmd+=' --pval-thresh '+inputs.pval_thresh;\n    }\n    else cmd=\"echo \\' No input files provided\\' 1>&2\"\n    \n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var tas_sizes = Array();\n    if (inputs.in_tas) tas_sizes.push(inputs.in_tas.size);\n    if (inputs.in_ctl_tas && inputs.in_ctl_tas[0])  tas_sizes.push(inputs.in_ctl_tas[0].size);\n    tas_sizes = arrSum(tas_sizes);\n    \n   \n    var input_file_size_gb = tas_sizes/1e+9;\n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223299,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223330,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-b8efb931/h-24765d1c/h-0476fd48/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619223330,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223299,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a340a026077a0f38d8bd0afbcdf1d70d1db4e49c14af44006a042c61a6b6c291d"
      },
      "label": "Macs2 Signal Track Bio-replicates",
      "scatter": [
        "in_tas",
        "fraglen"
      ],
      "scatterMethod": "dotproduct",
      "sbg:x": -1187.96337890625,
      "sbg:y": -1786.0833740234375
    },
    {
      "id": "call_peak_pr1",
      "in": [
        {
          "id": "peak_caller",
          "source": "peak_caller"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        },
        {
          "id": "in_tas",
          "source": "spr/ta_pr1"
        },
        {
          "id": "fraglen",
          "source": "xcor/fraglen"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ctl_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "subsample_ctl/out_ta_control"
          ]
        },
        {
          "id": "control_dct",
          "source": "sbg_scatter_prepare_cwl1_pr1/out_ctl_ta"
        }
      ],
      "out": [
        {
          "id": "out_peak"
        },
        {
          "id": "out_bfilt_peak"
        },
        {
          "id": "out_bfilt_peak_bb"
        },
        {
          "id": "out_bfilt_peak_starch"
        },
        {
          "id": "out_bfilt_peak_hammock"
        },
        {
          "id": "out_frip_qc"
        },
        {
          "id": "out_peak_region_size_qc"
        },
        {
          "id": "out_peak_region_size_plot"
        },
        {
          "id": "out_num_peak_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-call-peak-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:toolDefaultValue": "macs2",
            "id": "peak_caller",
            "type": "string?",
            "label": "Peak caller",
            "doc": "Peak caller. Default: macs2.",
            "default": "macs2"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "pipeline_type",
            "type": {
              "type": "enum",
              "symbols": [
                "tf",
                "histone",
                "control"
              ],
              "name": "pipeline_type"
            },
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          },
          {
            "id": "in_tas",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM. TAGALIGN file (first) and control TAGALIGN file (second; optional).",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length is estimated by cross-correlation analysis, which is valid only when pipeline started from FASTQs. If defined, fragment length estimated by cross-correlation analysis is ignored."
          },
          {
            "sbg:toolDefaultValue": "hs",
            "id": "gensz",
            "type": "string?",
            "label": "Genome sizes",
            "doc": "Genome sizes. \"hs\" for human, \"mm\" for mouse or sum of 2nd columnin chromosome sizes file.",
            "default": "hs"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "50000000",
            "id": "cap_num_peak",
            "type": "string?",
            "label": "Upper limit on the number of peaks",
            "doc": "Cap number of peaks called from a peak-caller (MACS2)."
          },
          {
            "sbg:toolDefaultValue": "0.01",
            "id": "pval_thresh",
            "type": "float?",
            "label": "P-value threshold",
            "doc": "P-value threshold for MACS2 (macs2 callpeak -p).",
            "default": 0.01
          },
          {
            "id": "fdr_thresh",
            "type": "float?",
            "label": "FDR threshold for SPP",
            "doc": "FDR threshold for SPP.",
            "default": 0.01
          },
          {
            "id": "regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Reg-ex for chromosomes",
            "doc": "Reg-ex for chromosomes to keep while filtering peaks. Chromosomes defined here will be kept. All other chromosomes will be filtered out in .bfilt. peak file. This is done along with blacklist filtering peak file. For example: chr[\\dXY]+.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "cpu",
            "type": "int?",
            "label": "Number of cores for task call_peak",
            "doc": "Task call_peak call peaks on TAG-ALIGNs by using SPP/MACS2 peak caller. MACS2 is single-threaded so cpu will be fixed at 2 for MACS2.",
            "default": 6
          },
          {
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory required for task with macs2 as peak_caller",
            "doc": "This factor will be multiplied to the size of TAG-ALIGNs (BEDs) to determine required memory of instance.",
            "default": 5
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Control Tag_Align",
            "doc": "Control Tag_Align files",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "control_dct",
            "type": "string?",
            "label": "Dict pairing TA files with corresponding controls",
            "doc": "Dict pairing TA files with corresponding controls."
          }
        ],
        "outputs": [
          {
            "id": "out_peak",
            "doc": "Generated by encode_task_macs2_atac.py.",
            "label": "Peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*[!.][!b][!f][!i][!l][!t].' + peak_type + '.gz'\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            }
          },
          {
            "id": "out_bfilt_peak",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.gz'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_bb",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak bb",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.bb'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_starch",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak starch",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.starch'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_hammock",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak hammock",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.hammock.gz*'\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".tbi",
                "required": false
              }
            ]
          },
          {
            "id": "out_frip_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Frip QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.frip.qc"
            }
          },
          {
            "id": "out_peak_region_size_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.qc"
            }
          },
          {
            "id": "out_peak_region_size_plot",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.png"
            }
          },
          {
            "id": "out_num_peak_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Num peak QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.num_peak.qc"
            }
          }
        ],
        "doc": "**Call Peak** tool is based on the \u201ccall_peak\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Call Peak** calls peaks on a TAG-ALIGN file.\n\n First, it executes the \u201cencode_task_macs2_chip.py\u201d script, which executes Macs2 callpeak v2.2.4 which calls peaks on a TAG-ALIGN file (output of Bam2ta tool). The output of the previous step, *_peaks.narrowPeak file, is further parsed and the final output is *.narrowPeak.gz file. In the second step, the tool calls the \u201cencode_task_post_call_peak_chip.py\u201d script, which: if blacklist file is provided - filters peaks from .narrowPeak.gz based on blacklist BED file, converts PEAK file to bigBed, converts PEAK file to STARCH file, convert PEAK file to hammock.gz file, determines the fraction of reads in peaks (FRiP) score without fragment length, calculates (blacklist-filtered) PEAK region size QC/plot, and calculates number of peaks (blacklist-filtered).\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Call Peak CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    var cmd = '';\n    if(inputs.pipeline_type=='control') cmd+=\"echo \\' Peak calling is not performed in control mode \\' 1>&2\";\n    else if(inputs.pipeline_type=='histone' && inputs.peak_caller=='spp') cmd+=\"echo \\' spp peak caller not compatible with histone op mode \\' 1>&2 \";\n    else if(inputs.in_tas){\n        var cmd1='';\n        var tas_file_paths = Array();\n        var ctls=[].concat(inputs.in_ctl_tas);\n        tas_file_paths.push(inputs.in_tas.path);\n        if(inputs.control_dct){\n            var dict=JSON.parse(inputs.control_dct)\n            if (dict[inputs.in_tas.basename]!='null'){\n                for(var i=0; i<ctls.length; i++){\n                    if(ctls[i].basename==dict[inputs.in_tas.basename]){\n                        tas_file_paths.push(ctls[i].path);\n                        break\n                        \n                    } \n                }\n                \n            } \n        }\n        else{\n            if(ctls[0]) tas_file_paths.push(ctls[0].path)\n        }\n       \n        tas_file_paths = tas_file_paths.join(' ');\n        \n        if(inputs.peak_caller == \"macs2\"){\n            cmd1+=\"python3 $(which encode_task_macs2_chip.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.gensz) cmd1+=' --gensz '+ inputs.gensz;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '50000000';\n            if (inputs.pval_thresh) cmd1+=' --pval-thresh '+ inputs.pval_thresh;\n        } \n        else if(inputs.peak_caller == \"spp\"){\n            cmd1+=\"python3 $(which encode_task_spp.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '30000000';\n            if (inputs.fdr_thresh) cmd1+=' --fdr-thresh '+ inputs.fdr_thresh;\n            if (inputs.cpu) cmd1+=' --nth '+ inputs.cpu;\n        }\n        \n        var peak_type='narrowPeak';\n        if (inputs.peak_caller=='spp') peak_type='regionPeak';\n        \n        var cmd2 = '';\n        cmd2+=\"python3 $(which encode_task_post_call_peak_chip.py)\";\n        cmd2+=\" $(ls *Peak.gz)\"\n        cmd2+=\" --ta \" + inputs.in_tas.path;\n        if (inputs.regex_bfilt_peak_chr_name) cmd2+=\" --regex-bfilt-peak-chr-name '\" + inputs.regex_bfilt_peak_chr_name + \"'\";\n        if (inputs.in_chrsz) cmd2+=' --chrsz '+ inputs.in_chrsz.path;\n        if (inputs.fraglen) cmd2+=' --fraglen '+ inputs.fraglen;\n        cmd2+=' --peak-type '+ peak_type;\n        if (inputs.in_blacklist) cmd2+=' --blacklist '+ inputs.in_blacklist.path;\n        \n        cmd=cmd1+' && '+cmd2;\n        \n    }\n    else cmd+=\"echo \\' No TAGALIGN input files provided\\' 1>&2\";\n    \n    \n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var tas_sizes = Array();\n    if (inputs.in_tas) tas_sizes.push(inputs.in_tas.size);\n    if (inputs.in_ctl_tas && inputs.in_ctl_tas[0])  tas_sizes.push(inputs.in_ctl_tas[0].size);\n    tas_sizes = arrSum(tas_sizes);\n    \n   \n    var input_file_size_gb = tas_sizes/10e9;\n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n  \n}",
            "coresMin": "${\n    if(inputs.peak_caller == \"macs2\") return 2;\n    else return inputs.cpu;\n       \n\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223192,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223235,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-c789cdaf/h-67d91234/h-fd33ef89/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619223235,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223192,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a3bb2422c2581b02886791a25c7b12f178f3b72e6f410d3163083f85f9c87ea7d"
      },
      "label": "Call Peak PR1",
      "scatter": [
        "in_tas",
        "fraglen"
      ],
      "scatterMethod": "dotproduct",
      "sbg:x": -1180.0732421875,
      "sbg:y": -1443.2767333984375
    },
    {
      "id": "call_peak_pr2",
      "in": [
        {
          "id": "peak_caller",
          "source": "peak_caller"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        },
        {
          "id": "in_tas",
          "source": "spr/ta_pr2"
        },
        {
          "id": "fraglen",
          "source": "xcor/fraglen"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ctl_tas",
          "linkMerge": "merge_flattened",
          "source": [
            "subsample_ctl/out_ta_control"
          ]
        },
        {
          "id": "control_dct",
          "source": "sbg_scatter_prepare_cwl1_pr2/out_ctl_ta"
        }
      ],
      "out": [
        {
          "id": "out_peak"
        },
        {
          "id": "out_bfilt_peak"
        },
        {
          "id": "out_bfilt_peak_bb"
        },
        {
          "id": "out_bfilt_peak_starch"
        },
        {
          "id": "out_bfilt_peak_hammock"
        },
        {
          "id": "out_frip_qc"
        },
        {
          "id": "out_peak_region_size_qc"
        },
        {
          "id": "out_peak_region_size_plot"
        },
        {
          "id": "out_num_peak_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-call-peak-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:toolDefaultValue": "macs2",
            "id": "peak_caller",
            "type": "string?",
            "label": "Peak caller",
            "doc": "Peak caller. Default: macs2.",
            "default": "macs2"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "pipeline_type",
            "type": {
              "type": "enum",
              "symbols": [
                "tf",
                "histone",
                "control"
              ],
              "name": "pipeline_type"
            },
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          },
          {
            "id": "in_tas",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM. TAGALIGN file (first) and control TAGALIGN file (second; optional).",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length is estimated by cross-correlation analysis, which is valid only when pipeline started from FASTQs. If defined, fragment length estimated by cross-correlation analysis is ignored."
          },
          {
            "sbg:toolDefaultValue": "hs",
            "id": "gensz",
            "type": "string?",
            "label": "Genome sizes",
            "doc": "Genome sizes. \"hs\" for human, \"mm\" for mouse or sum of 2nd columnin chromosome sizes file.",
            "default": "hs"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "50000000",
            "id": "cap_num_peak",
            "type": "string?",
            "label": "Upper limit on the number of peaks",
            "doc": "Cap number of peaks called from a peak-caller (MACS2)."
          },
          {
            "sbg:toolDefaultValue": "0.01",
            "id": "pval_thresh",
            "type": "float?",
            "label": "P-value threshold",
            "doc": "P-value threshold for MACS2 (macs2 callpeak -p).",
            "default": 0.01
          },
          {
            "id": "fdr_thresh",
            "type": "float?",
            "label": "FDR threshold for SPP",
            "doc": "FDR threshold for SPP.",
            "default": 0.01
          },
          {
            "id": "regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Reg-ex for chromosomes",
            "doc": "Reg-ex for chromosomes to keep while filtering peaks. Chromosomes defined here will be kept. All other chromosomes will be filtered out in .bfilt. peak file. This is done along with blacklist filtering peak file. For example: chr[\\dXY]+.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "cpu",
            "type": "int?",
            "label": "Number of cores for task call_peak",
            "doc": "Task call_peak call peaks on TAG-ALIGNs by using SPP/MACS2 peak caller. MACS2 is single-threaded so cpu will be fixed at 2 for MACS2.",
            "default": 6
          },
          {
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory required for task with macs2 as peak_caller",
            "doc": "This factor will be multiplied to the size of TAG-ALIGNs (BEDs) to determine required memory of instance.",
            "default": 5
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Control Tag_Align",
            "doc": "Control Tag_Align files",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "control_dct",
            "type": "string?",
            "label": "Dict pairing TA files with corresponding controls",
            "doc": "Dict pairing TA files with corresponding controls."
          }
        ],
        "outputs": [
          {
            "id": "out_peak",
            "doc": "Generated by encode_task_macs2_atac.py.",
            "label": "Peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*[!.][!b][!f][!i][!l][!t].' + peak_type + '.gz'\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            }
          },
          {
            "id": "out_bfilt_peak",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.gz'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_bb",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak bb",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.bb'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_starch",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak starch",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.starch'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_hammock",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak hammock",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.hammock.gz*'\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".tbi",
                "required": false
              }
            ]
          },
          {
            "id": "out_frip_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Frip QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.frip.qc"
            }
          },
          {
            "id": "out_peak_region_size_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.qc"
            }
          },
          {
            "id": "out_peak_region_size_plot",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.png"
            }
          },
          {
            "id": "out_num_peak_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Num peak QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.num_peak.qc"
            }
          }
        ],
        "doc": "**Call Peak** tool is based on the \u201ccall_peak\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Call Peak** calls peaks on a TAG-ALIGN file.\n\n First, it executes the \u201cencode_task_macs2_chip.py\u201d script, which executes Macs2 callpeak v2.2.4 which calls peaks on a TAG-ALIGN file (output of Bam2ta tool). The output of the previous step, *_peaks.narrowPeak file, is further parsed and the final output is *.narrowPeak.gz file. In the second step, the tool calls the \u201cencode_task_post_call_peak_chip.py\u201d script, which: if blacklist file is provided - filters peaks from .narrowPeak.gz based on blacklist BED file, converts PEAK file to bigBed, converts PEAK file to STARCH file, convert PEAK file to hammock.gz file, determines the fraction of reads in peaks (FRiP) score without fragment length, calculates (blacklist-filtered) PEAK region size QC/plot, and calculates number of peaks (blacklist-filtered).\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Call Peak CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    var cmd = '';\n    if(inputs.pipeline_type=='control') cmd+=\"echo \\' Peak calling is not performed in control mode \\' 1>&2\";\n    else if(inputs.pipeline_type=='histone' && inputs.peak_caller=='spp') cmd+=\"echo \\' spp peak caller not compatible with histone op mode \\' 1>&2 \";\n    else if(inputs.in_tas){\n        var cmd1='';\n        var tas_file_paths = Array();\n        var ctls=[].concat(inputs.in_ctl_tas);\n        tas_file_paths.push(inputs.in_tas.path);\n        if(inputs.control_dct){\n            var dict=JSON.parse(inputs.control_dct)\n            if (dict[inputs.in_tas.basename]!='null'){\n                for(var i=0; i<ctls.length; i++){\n                    if(ctls[i].basename==dict[inputs.in_tas.basename]){\n                        tas_file_paths.push(ctls[i].path);\n                        break\n                        \n                    } \n                }\n                \n            } \n        }\n        else{\n            if(ctls[0]) tas_file_paths.push(ctls[0].path)\n        }\n       \n        tas_file_paths = tas_file_paths.join(' ');\n        \n        if(inputs.peak_caller == \"macs2\"){\n            cmd1+=\"python3 $(which encode_task_macs2_chip.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.gensz) cmd1+=' --gensz '+ inputs.gensz;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '50000000';\n            if (inputs.pval_thresh) cmd1+=' --pval-thresh '+ inputs.pval_thresh;\n        } \n        else if(inputs.peak_caller == \"spp\"){\n            cmd1+=\"python3 $(which encode_task_spp.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '30000000';\n            if (inputs.fdr_thresh) cmd1+=' --fdr-thresh '+ inputs.fdr_thresh;\n            if (inputs.cpu) cmd1+=' --nth '+ inputs.cpu;\n        }\n        \n        var peak_type='narrowPeak';\n        if (inputs.peak_caller=='spp') peak_type='regionPeak';\n        \n        var cmd2 = '';\n        cmd2+=\"python3 $(which encode_task_post_call_peak_chip.py)\";\n        cmd2+=\" $(ls *Peak.gz)\"\n        cmd2+=\" --ta \" + inputs.in_tas.path;\n        if (inputs.regex_bfilt_peak_chr_name) cmd2+=\" --regex-bfilt-peak-chr-name '\" + inputs.regex_bfilt_peak_chr_name + \"'\";\n        if (inputs.in_chrsz) cmd2+=' --chrsz '+ inputs.in_chrsz.path;\n        if (inputs.fraglen) cmd2+=' --fraglen '+ inputs.fraglen;\n        cmd2+=' --peak-type '+ peak_type;\n        if (inputs.in_blacklist) cmd2+=' --blacklist '+ inputs.in_blacklist.path;\n        \n        cmd=cmd1+' && '+cmd2;\n        \n    }\n    else cmd+=\"echo \\' No TAGALIGN input files provided\\' 1>&2\";\n    \n    \n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var tas_sizes = Array();\n    if (inputs.in_tas) tas_sizes.push(inputs.in_tas.size);\n    if (inputs.in_ctl_tas && inputs.in_ctl_tas[0])  tas_sizes.push(inputs.in_ctl_tas[0].size);\n    tas_sizes = arrSum(tas_sizes);\n    \n   \n    var input_file_size_gb = tas_sizes/10e9;\n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n  \n}",
            "coresMin": "${\n    if(inputs.peak_caller == \"macs2\") return 2;\n    else return inputs.cpu;\n       \n\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223192,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223235,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-ca03be20/h-8c76e40b/h-355befcc/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619223235,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223192,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a3bb2422c2581b02886791a25c7b12f178f3b72e6f410d3163083f85f9c87ea7d"
      },
      "label": "Call Peak PR2",
      "scatter": [
        "in_tas",
        "fraglen"
      ],
      "scatterMethod": "dotproduct",
      "sbg:x": -1171.2933349609375,
      "sbg:y": -1071.7635498046875
    },
    {
      "id": "subsample_pool_ctl",
      "in": [
        {
          "id": "in_ta",
          "source": [
            "bam2ta_controls/out_ta"
          ]
        },
        {
          "id": "paired_end",
          "source": "ctl_paired_end"
        },
        {
          "id": "in_ctl_pooled",
          "source": "pool_ta_controls/out_ta_pooled"
        },
        {
          "id": "in_ctl_ta_pool_subsample",
          "source": "choose_ctl/chosen_ctl_ta_subsample_pooled"
        }
      ],
      "out": [
        {
          "id": "out_ta_control"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-subsample-pool-ctl-1-7-1-cwl1-1/3",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:category": "Inputs",
            "id": "in_ta",
            "type": "File[]?",
            "label": "Control Tag-Aligns",
            "doc": "TAG-ALIGN file is in a 6-col BED format. It is a simplified version of BAM. Output of Encode Bam2ta tool.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "paired_end",
            "type": "boolean?",
            "label": "Paired-end",
            "doc": "Paired-end."
          },
          {
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory",
            "doc": "Multiplication factor to determine memory required for task subsample_ctl.",
            "default": 14
          },
          {
            "sbg:category": "Inputs",
            "id": "in_ctl_pooled",
            "type": "File?",
            "label": "Pooled control Tag-Align",
            "doc": "Pooled control Tag-Align.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:category": "Inputs",
            "sbg:toolDefaultValue": "None",
            "id": "in_ctl_ta_pool_subsample",
            "type": "int?",
            "label": "Control Tag-Align pool subsamples",
            "doc": "Control Tag-Align pool subsamples."
          }
        ],
        "outputs": [
          {
            "id": "out_ta_control",
            "doc": "Subsampled Tag-Align",
            "label": "Subsampled Tag-Align",
            "type": "File?",
            "outputBinding": {
              "glob": "*.tagAlign.gz",
              "outputEval": "${\n    if(inputs.in_ctl_ta_pool_subsample || inputs.in_ctl_ta_pool_subsample==0){\n        var pool_subsample = inputs.in_ctl_ta_pool_subsample;\n        var ctl_ta = [].concat(inputs.in_ta); \n        var base_arr = Array();\n        var ta;\n        var self_list=[].concat(self)\n    \n        for(var i = 0; i< ctl_ta.length; i++){\n            base_arr.push(ctl_ta[i].basename);\n        }\n        var base_arr_all=base_arr;\n        if (inputs.in_ctl_pooled) base_arr_all.push(inputs.in_ctl_pooled.basename);\n   \n  \n        if (pool_subsample>0) {\n            for(var i=0; i<self_list.length; i++){\n                if(base_arr_all.indexOf(self_list[i].basename)==-1) return self_list[i]\n            }\n        }\n        else if(ctl_ta.length<2) {\n            for(var i=0; i<self_list.length; i++){\n                if(self_list[i].basename==ctl_ta[0].basename) return self_list[i]\n            }\n        } \n        else{\n            for(var i=0; i<self_list.length; i++){\n                if(self_list[i].basename==inputs.in_ctl_pooled.basename) return self_list[i]\n            }\n        }\n        \n    }\n    \n    \n   \n    \n}"
            }
          }
        ],
        "doc": "**Subsample Ctl** tool is based on the \u201ctask_subsample_ctl\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. This script does not check if number of reads in TA is higher than subsampling number (--subsample). If number of reads in TA is lower than subsampling number then TA will be just shuffled.\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Subsample Pool Ctl CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if(inputs.in_ctl_ta_pool_subsample || inputs.in_ctl_ta_pool_subsample==0){\n        var pool_subsample = inputs.in_ctl_ta_pool_subsample;\n        var ctl_ta = [].concat(inputs.in_ta); \n        var cmd = Array();\n        var ta;\n        \n        if(inputs.in_ctl_pooled) var ctl_ta_pooled = inputs.in_ctl_pooled.path; \n            \n        if (ctl_ta.length<2) ta=ctl_ta[0].path;\n        else ta=inputs.in_ctl_pooled.path;\n    \n        var pe=inputs.paired_end ? ' --paired-end':'';\n    \n        if(pool_subsample > 0){\n            cmd += \"python3 $(which encode_task_subsample_ctl.py) \" + ta+ ' --subsample '+pool_subsample+pe;\n            \n        }\n        else cmd= \"echo \\'Conditions for running subsample_ctl were not fulfilled\\' 1>&2\"  ;\n        \n    }\n    else cmd=\"echo \\'No inputs provided\\' 1>&2\";\n    \n    \n    return cmd;\n    \n  \n}\n    "
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var input_file_size_gb=0;\n    if (inputs.in_ta && inputs.in_ta[0]) var input_file_size_gb = inputs.in_ta[0].size/10e+9;\n    var mem_gb = 4.0 + inputs.mem_factor*input_file_size_gb\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.in_ctl_pooled)",
              "$(inputs.in_ta)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223439,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223480,
            "sbg:revisionNotes": "from dev"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619377212,
            "sbg:revisionNotes": "updated memory expression"
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619421685,
            "sbg:revisionNotes": "updated memory expression"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-2e7bd6d9/h-21059de4/h-37c5678c/0",
        "sbg:revision": 3,
        "sbg:revisionNotes": "updated memory expression",
        "sbg:modifiedOn": 1619421685,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223439,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 3,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a3cf455a4c32aaf33d0d64ba66561739429ceaa2e9d5bb178cc77bc93434dd2c8"
      },
      "label": "Subsample Pool Ctl",
      "sbg:x": -1022,
      "sbg:y": -1629.973388671875
    },
    {
      "id": "rounded_mean",
      "in": [
        {
          "id": "ints",
          "source": [
            "xcor/fraglen"
          ]
        }
      ],
      "out": [
        {
          "id": "out_rounded_mean"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-rounded-mean-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "ints",
            "type": "int[]?",
            "label": "Input integer array",
            "doc": "Input integer values."
          }
        ],
        "outputs": [
          {
            "id": "out_rounded_mean",
            "doc": "Rounded arithmetic mean of a set of input integers.",
            "label": "Rounded mean value",
            "type": "int?",
            "outputBinding": {
              "loadContents": true,
              "glob": "tmp.txt",
              "outputEval": "${\n    if(inputs.ints && inputs.ints[0]) return parseInt(self[0].contents);\n}"
            }
          }
        ],
        "doc": "**Rounded Mean** tool calculates the rounded arithmetic mean of a set of numbers.\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Rounded Mean CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if (inputs.ints && inputs.ints[0]){\n        cmd+='python rounded_mean.py ';\n        cmd+=\"[\" + inputs.ints + \"]\";\n    }\n    else cmd=\"echo \\'No inputs provided \\' 1>&2 \";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 2000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              {
                "entryname": "rounded_mean.py",
                "entry": "import sys\n\nn = len(sys.argv[1])\narr = sys.argv[1][1:n-1]\narr = arr.split(',')\narr = [int(i) for i in arr]\nwith open('tmp.txt', 'w') as fp:\n    if len(arr):\n        sum_ = sum(arr)\n        mean_ = sum(arr) / float(len(arr))\n        fp.write('{}'.format(int(round(mean_))))\n    else:\n        fp.write('0')",
                "writable": false
              }
            ]
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223522,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223574,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-3397c340/h-b64cab09/h-86ef4b24/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619223574,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223522,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a240487cb38df30eedf6c1b587f9f37a1401bca31af6e3503908f357ee8b6a702"
      },
      "label": "Rounded mean",
      "sbg:x": -1008.1832885742188,
      "sbg:y": -1298.6434326171875
    },
    {
      "id": "call_peak_pooled_replicates",
      "in": [
        {
          "id": "peak_caller",
          "source": "peak_caller"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        },
        {
          "id": "in_tas",
          "source": "pool_ta_bio_replicates/out_ta_pooled"
        },
        {
          "id": "fraglen",
          "source": "rounded_mean/out_rounded_mean"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ctl_tas",
          "source": [
            "subsample_pool_ctl/out_ta_control"
          ]
        }
      ],
      "out": [
        {
          "id": "out_peak"
        },
        {
          "id": "out_bfilt_peak"
        },
        {
          "id": "out_bfilt_peak_bb"
        },
        {
          "id": "out_bfilt_peak_starch"
        },
        {
          "id": "out_bfilt_peak_hammock"
        },
        {
          "id": "out_frip_qc"
        },
        {
          "id": "out_peak_region_size_qc"
        },
        {
          "id": "out_peak_region_size_plot"
        },
        {
          "id": "out_num_peak_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-call-peak-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:toolDefaultValue": "macs2",
            "id": "peak_caller",
            "type": "string?",
            "label": "Peak caller",
            "doc": "Peak caller. Default: macs2.",
            "default": "macs2"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "pipeline_type",
            "type": {
              "type": "enum",
              "symbols": [
                "tf",
                "histone",
                "control"
              ],
              "name": "pipeline_type"
            },
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          },
          {
            "id": "in_tas",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM. TAGALIGN file (first) and control TAGALIGN file (second; optional).",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length is estimated by cross-correlation analysis, which is valid only when pipeline started from FASTQs. If defined, fragment length estimated by cross-correlation analysis is ignored."
          },
          {
            "sbg:toolDefaultValue": "hs",
            "id": "gensz",
            "type": "string?",
            "label": "Genome sizes",
            "doc": "Genome sizes. \"hs\" for human, \"mm\" for mouse or sum of 2nd columnin chromosome sizes file.",
            "default": "hs"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "50000000",
            "id": "cap_num_peak",
            "type": "string?",
            "label": "Upper limit on the number of peaks",
            "doc": "Cap number of peaks called from a peak-caller (MACS2)."
          },
          {
            "sbg:toolDefaultValue": "0.01",
            "id": "pval_thresh",
            "type": "float?",
            "label": "P-value threshold",
            "doc": "P-value threshold for MACS2 (macs2 callpeak -p).",
            "default": 0.01
          },
          {
            "id": "fdr_thresh",
            "type": "float?",
            "label": "FDR threshold for SPP",
            "doc": "FDR threshold for SPP.",
            "default": 0.01
          },
          {
            "id": "regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Reg-ex for chromosomes",
            "doc": "Reg-ex for chromosomes to keep while filtering peaks. Chromosomes defined here will be kept. All other chromosomes will be filtered out in .bfilt. peak file. This is done along with blacklist filtering peak file. For example: chr[\\dXY]+.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "cpu",
            "type": "int?",
            "label": "Number of cores for task call_peak",
            "doc": "Task call_peak call peaks on TAG-ALIGNs by using SPP/MACS2 peak caller. MACS2 is single-threaded so cpu will be fixed at 2 for MACS2.",
            "default": 6
          },
          {
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory required for task with macs2 as peak_caller",
            "doc": "This factor will be multiplied to the size of TAG-ALIGNs (BEDs) to determine required memory of instance.",
            "default": 5
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Control Tag_Align",
            "doc": "Control Tag_Align files",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "control_dct",
            "type": "string?",
            "label": "Dict pairing TA files with corresponding controls",
            "doc": "Dict pairing TA files with corresponding controls."
          }
        ],
        "outputs": [
          {
            "id": "out_peak",
            "doc": "Generated by encode_task_macs2_atac.py.",
            "label": "Peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*[!.][!b][!f][!i][!l][!t].' + peak_type + '.gz'\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            }
          },
          {
            "id": "out_bfilt_peak",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.gz'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_bb",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak bb",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.bb'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_starch",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak starch",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.starch'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_hammock",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak hammock",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.hammock.gz*'\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".tbi",
                "required": false
              }
            ]
          },
          {
            "id": "out_frip_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Frip QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.frip.qc"
            }
          },
          {
            "id": "out_peak_region_size_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.qc"
            }
          },
          {
            "id": "out_peak_region_size_plot",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.png"
            }
          },
          {
            "id": "out_num_peak_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Num peak QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.num_peak.qc"
            }
          }
        ],
        "doc": "**Call Peak** tool is based on the \u201ccall_peak\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Call Peak** calls peaks on a TAG-ALIGN file.\n\n First, it executes the \u201cencode_task_macs2_chip.py\u201d script, which executes Macs2 callpeak v2.2.4 which calls peaks on a TAG-ALIGN file (output of Bam2ta tool). The output of the previous step, *_peaks.narrowPeak file, is further parsed and the final output is *.narrowPeak.gz file. In the second step, the tool calls the \u201cencode_task_post_call_peak_chip.py\u201d script, which: if blacklist file is provided - filters peaks from .narrowPeak.gz based on blacklist BED file, converts PEAK file to bigBed, converts PEAK file to STARCH file, convert PEAK file to hammock.gz file, determines the fraction of reads in peaks (FRiP) score without fragment length, calculates (blacklist-filtered) PEAK region size QC/plot, and calculates number of peaks (blacklist-filtered).\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Call Peak CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    var cmd = '';\n    if(inputs.pipeline_type=='control') cmd+=\"echo \\' Peak calling is not performed in control mode \\' 1>&2\";\n    else if(inputs.pipeline_type=='histone' && inputs.peak_caller=='spp') cmd+=\"echo \\' spp peak caller not compatible with histone op mode \\' 1>&2 \";\n    else if(inputs.in_tas){\n        var cmd1='';\n        var tas_file_paths = Array();\n        var ctls=[].concat(inputs.in_ctl_tas);\n        tas_file_paths.push(inputs.in_tas.path);\n        if(inputs.control_dct){\n            var dict=JSON.parse(inputs.control_dct)\n            if (dict[inputs.in_tas.basename]!='null'){\n                for(var i=0; i<ctls.length; i++){\n                    if(ctls[i].basename==dict[inputs.in_tas.basename]){\n                        tas_file_paths.push(ctls[i].path);\n                        break\n                        \n                    } \n                }\n                \n            } \n        }\n        else{\n            if(ctls[0]) tas_file_paths.push(ctls[0].path)\n        }\n       \n        tas_file_paths = tas_file_paths.join(' ');\n        \n        if(inputs.peak_caller == \"macs2\"){\n            cmd1+=\"python3 $(which encode_task_macs2_chip.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.gensz) cmd1+=' --gensz '+ inputs.gensz;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '50000000';\n            if (inputs.pval_thresh) cmd1+=' --pval-thresh '+ inputs.pval_thresh;\n        } \n        else if(inputs.peak_caller == \"spp\"){\n            cmd1+=\"python3 $(which encode_task_spp.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '30000000';\n            if (inputs.fdr_thresh) cmd1+=' --fdr-thresh '+ inputs.fdr_thresh;\n            if (inputs.cpu) cmd1+=' --nth '+ inputs.cpu;\n        }\n        \n        var peak_type='narrowPeak';\n        if (inputs.peak_caller=='spp') peak_type='regionPeak';\n        \n        var cmd2 = '';\n        cmd2+=\"python3 $(which encode_task_post_call_peak_chip.py)\";\n        cmd2+=\" $(ls *Peak.gz)\"\n        cmd2+=\" --ta \" + inputs.in_tas.path;\n        if (inputs.regex_bfilt_peak_chr_name) cmd2+=\" --regex-bfilt-peak-chr-name '\" + inputs.regex_bfilt_peak_chr_name + \"'\";\n        if (inputs.in_chrsz) cmd2+=' --chrsz '+ inputs.in_chrsz.path;\n        if (inputs.fraglen) cmd2+=' --fraglen '+ inputs.fraglen;\n        cmd2+=' --peak-type '+ peak_type;\n        if (inputs.in_blacklist) cmd2+=' --blacklist '+ inputs.in_blacklist.path;\n        \n        cmd=cmd1+' && '+cmd2;\n        \n    }\n    else cmd+=\"echo \\' No TAGALIGN input files provided\\' 1>&2\";\n    \n    \n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var tas_sizes = Array();\n    if (inputs.in_tas) tas_sizes.push(inputs.in_tas.size);\n    if (inputs.in_ctl_tas && inputs.in_ctl_tas[0])  tas_sizes.push(inputs.in_ctl_tas[0].size);\n    tas_sizes = arrSum(tas_sizes);\n    \n   \n    var input_file_size_gb = tas_sizes/10e9;\n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n  \n}",
            "coresMin": "${\n    if(inputs.peak_caller == \"macs2\") return 2;\n    else return inputs.cpu;\n       \n\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223192,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223235,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-eb6fd108/h-2952add1/h-bd9a8e5b/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619223235,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223192,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a3bb2422c2581b02886791a25c7b12f178f3b72e6f410d3163083f85f9c87ea7d"
      },
      "label": "Call Peak Pooled-replicates",
      "sbg:x": -845.7230224609375,
      "sbg:y": -2032.8330078125
    },
    {
      "id": "macs2_signal_track_pooled_replicates",
      "in": [
        {
          "id": "in_tas",
          "source": "pool_ta_bio_replicates/out_ta_pooled"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "fraglen",
          "source": "rounded_mean/out_rounded_mean"
        },
        {
          "id": "in_ctl_tas",
          "source": [
            "subsample_pool_ctl/out_ta_control"
          ]
        }
      ],
      "out": [
        {
          "id": "out_pval_bw"
        },
        {
          "id": "out_fc_bw"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-macs2-signal-track-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_tas",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM. [ta, control_ta]. control_ta is optional",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "sbg:toolDefaultValue": "hs",
            "id": "gensz",
            "type": "string?",
            "label": "Genome size",
            "doc": "Genome size (sum of entries in 2nd column of # chr. sizes file, or hs for human, ms for mouse).",
            "default": "hs"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "0.01",
            "id": "pval_thresh",
            "type": "float?",
            "label": "Pval threshold",
            "doc": "P value threshold for MACS2.",
            "default": 0.01
          },
          {
            "sbg:toolDefaultValue": "12.0",
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory factor",
            "doc": "Multiplication factor to determine memory required for the task.",
            "default": 12
          },
          {
            "sbg:toolDefaultValue": "80.0",
            "id": "disk_factor",
            "type": "float?",
            "label": "Disk factor",
            "doc": "Multiplication factor to determine persistent disk size for task macs2_signal_track.",
            "default": 80
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length from xcor."
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Control Tag-Align",
            "doc": "Control Tag-Align file."
          },
          {
            "id": "control_dct",
            "type": "string?",
            "label": "Control dict",
            "doc": "Control dict"
          }
        ],
        "outputs": [
          {
            "id": "out_pval_bw",
            "doc": "P-value bigWig file.",
            "label": "P-value bigWig",
            "type": "File?",
            "outputBinding": {
              "glob": "*.pval.signal.bigwig",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            },
            "sbg:fileTypes": "BIGWIG"
          },
          {
            "id": "out_fc_bw",
            "doc": "Fold-change bigWig file.",
            "label": "FC bigWig",
            "type": "File?",
            "outputBinding": {
              "glob": "*.fc.signal.bigwig",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            },
            "sbg:fileTypes": "BIGWIG"
          }
        ],
        "doc": "**Macs2 Signal Track** tool is based on the \u201cmacs2_signal_track\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Macs2 Signal Track** generates the count signal track.\n\nThe \u201cencode_task_macs2_signal_track_chip.py\u201d script first executes Macs2 callpeak v2.2.4 which calls peaks on a TAG-ALIGN file which is the output of Bam2ta tool, and generates two files required for the next step: treatment bedGraph file, *_treat_pileup.bdg and control bedGraph file, *_control_lambda.bdg. \nThe second step executes Macs2 bdgcmp v2.2.4, that compares two signal tracks in bedGraph format, and produces bedGraph (*_FE.bdg) output file. In the third step Bedtools slop is executed, which increases the size of each feature in a feature file (bedGraph (*_FE.bdg) output of Macs2 bdgcmp v2.2.4) by a user-defined number of bases (0 in this case) and it restricts the resizing to the size of the chromosome. Its result is piped to BedClip stdin in order to remove problematic row(s) in a BED file. Next, any overlapping regions in a bedgraph file are sorted and removed by comparing two lines in a row. In the final step, bedGraphToBigWig is executed. The procedure is repeated one more time (without calling Macs2 callpeak again), where Macs2 bdgcmp is provided with SFACTOR input (the number of tags per million in the (compressed) BED file are provided on SFACTOR input).\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Macs2 Signal Track CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    if (inputs.in_tas && inputs.fraglen){\n        cmd+='python3 $(which encode_task_macs2_signal_track_chip.py) ';\n        cmd+=inputs.in_tas.path;\n        if(inputs.in_ctl_tas){\n            if(inputs.control_dct){\n                var ctls=[].concat(inputs.in_ctl_tas);\n                var dict=JSON.parse(inputs.control_dct)\n                if (dict[inputs.in_tas.basename]!='null'){\n                    for(var i=0; i<ctls.length; i++){\n                        if(ctls[i].basename==dict[inputs.in_tas.basename]){\n                            cmd+=' '+inputs.in_ctl_tas[i].path;\n                            break\n                            \n                        } \n                    }\n            \n                } \n                \n            }\n            else{\n                if(inputs.in_ctl_tas[0]) cmd+=' '+inputs.in_ctl_tas[0].path;\n            } \n        }\n        if(inputs.fraglen) cmd+=' --fraglen '+inputs.fraglen;\n        if(inputs.gensz) cmd+=' --gensz '+inputs.gensz;\n        if(inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.pval_thresh) cmd+=' --pval-thresh '+inputs.pval_thresh;\n    }\n    else cmd=\"echo \\' No input files provided\\' 1>&2\"\n    \n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var tas_sizes = Array();\n    if (inputs.in_tas) tas_sizes.push(inputs.in_tas.size);\n    if (inputs.in_ctl_tas && inputs.in_ctl_tas[0])  tas_sizes.push(inputs.in_ctl_tas[0].size);\n    tas_sizes = arrSum(tas_sizes);\n    \n   \n    var input_file_size_gb = tas_sizes/1e+9;\n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    \n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223299,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223330,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-bb43ab81/h-854e8611/h-a21a8af6/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619223330,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223299,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a340a026077a0f38d8bd0afbcdf1d70d1db4e49c14af44006a042c61a6b6c291d"
      },
      "label": "Macs2 Signal Track Pooled-replicates",
      "sbg:x": -845.4766235351562,
      "sbg:y": -1784.8634033203125
    },
    {
      "id": "call_peak_ppr1",
      "in": [
        {
          "id": "peak_caller",
          "source": "peak_caller"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        },
        {
          "id": "in_tas",
          "source": "pool_ta_pr1/out_ta_pooled"
        },
        {
          "id": "fraglen",
          "source": "rounded_mean/out_rounded_mean"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ctl_tas",
          "source": [
            "subsample_pool_ctl/out_ta_control"
          ]
        }
      ],
      "out": [
        {
          "id": "out_peak"
        },
        {
          "id": "out_bfilt_peak"
        },
        {
          "id": "out_bfilt_peak_bb"
        },
        {
          "id": "out_bfilt_peak_starch"
        },
        {
          "id": "out_bfilt_peak_hammock"
        },
        {
          "id": "out_frip_qc"
        },
        {
          "id": "out_peak_region_size_qc"
        },
        {
          "id": "out_peak_region_size_plot"
        },
        {
          "id": "out_num_peak_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-call-peak-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:toolDefaultValue": "macs2",
            "id": "peak_caller",
            "type": "string?",
            "label": "Peak caller",
            "doc": "Peak caller. Default: macs2.",
            "default": "macs2"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "pipeline_type",
            "type": {
              "type": "enum",
              "symbols": [
                "tf",
                "histone",
                "control"
              ],
              "name": "pipeline_type"
            },
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          },
          {
            "id": "in_tas",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM. TAGALIGN file (first) and control TAGALIGN file (second; optional).",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length is estimated by cross-correlation analysis, which is valid only when pipeline started from FASTQs. If defined, fragment length estimated by cross-correlation analysis is ignored."
          },
          {
            "sbg:toolDefaultValue": "hs",
            "id": "gensz",
            "type": "string?",
            "label": "Genome sizes",
            "doc": "Genome sizes. \"hs\" for human, \"mm\" for mouse or sum of 2nd columnin chromosome sizes file.",
            "default": "hs"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "50000000",
            "id": "cap_num_peak",
            "type": "string?",
            "label": "Upper limit on the number of peaks",
            "doc": "Cap number of peaks called from a peak-caller (MACS2)."
          },
          {
            "sbg:toolDefaultValue": "0.01",
            "id": "pval_thresh",
            "type": "float?",
            "label": "P-value threshold",
            "doc": "P-value threshold for MACS2 (macs2 callpeak -p).",
            "default": 0.01
          },
          {
            "id": "fdr_thresh",
            "type": "float?",
            "label": "FDR threshold for SPP",
            "doc": "FDR threshold for SPP.",
            "default": 0.01
          },
          {
            "id": "regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Reg-ex for chromosomes",
            "doc": "Reg-ex for chromosomes to keep while filtering peaks. Chromosomes defined here will be kept. All other chromosomes will be filtered out in .bfilt. peak file. This is done along with blacklist filtering peak file. For example: chr[\\dXY]+.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "cpu",
            "type": "int?",
            "label": "Number of cores for task call_peak",
            "doc": "Task call_peak call peaks on TAG-ALIGNs by using SPP/MACS2 peak caller. MACS2 is single-threaded so cpu will be fixed at 2 for MACS2.",
            "default": 6
          },
          {
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory required for task with macs2 as peak_caller",
            "doc": "This factor will be multiplied to the size of TAG-ALIGNs (BEDs) to determine required memory of instance.",
            "default": 5
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Control Tag_Align",
            "doc": "Control Tag_Align files",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "control_dct",
            "type": "string?",
            "label": "Dict pairing TA files with corresponding controls",
            "doc": "Dict pairing TA files with corresponding controls."
          }
        ],
        "outputs": [
          {
            "id": "out_peak",
            "doc": "Generated by encode_task_macs2_atac.py.",
            "label": "Peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*[!.][!b][!f][!i][!l][!t].' + peak_type + '.gz'\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            }
          },
          {
            "id": "out_bfilt_peak",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.gz'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_bb",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak bb",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.bb'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_starch",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak starch",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.starch'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_hammock",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak hammock",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.hammock.gz*'\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".tbi",
                "required": false
              }
            ]
          },
          {
            "id": "out_frip_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Frip QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.frip.qc"
            }
          },
          {
            "id": "out_peak_region_size_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.qc"
            }
          },
          {
            "id": "out_peak_region_size_plot",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.png"
            }
          },
          {
            "id": "out_num_peak_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Num peak QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.num_peak.qc"
            }
          }
        ],
        "doc": "**Call Peak** tool is based on the \u201ccall_peak\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Call Peak** calls peaks on a TAG-ALIGN file.\n\n First, it executes the \u201cencode_task_macs2_chip.py\u201d script, which executes Macs2 callpeak v2.2.4 which calls peaks on a TAG-ALIGN file (output of Bam2ta tool). The output of the previous step, *_peaks.narrowPeak file, is further parsed and the final output is *.narrowPeak.gz file. In the second step, the tool calls the \u201cencode_task_post_call_peak_chip.py\u201d script, which: if blacklist file is provided - filters peaks from .narrowPeak.gz based on blacklist BED file, converts PEAK file to bigBed, converts PEAK file to STARCH file, convert PEAK file to hammock.gz file, determines the fraction of reads in peaks (FRiP) score without fragment length, calculates (blacklist-filtered) PEAK region size QC/plot, and calculates number of peaks (blacklist-filtered).\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Call Peak CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    var cmd = '';\n    if(inputs.pipeline_type=='control') cmd+=\"echo \\' Peak calling is not performed in control mode \\' 1>&2\";\n    else if(inputs.pipeline_type=='histone' && inputs.peak_caller=='spp') cmd+=\"echo \\' spp peak caller not compatible with histone op mode \\' 1>&2 \";\n    else if(inputs.in_tas){\n        var cmd1='';\n        var tas_file_paths = Array();\n        var ctls=[].concat(inputs.in_ctl_tas);\n        tas_file_paths.push(inputs.in_tas.path);\n        if(inputs.control_dct){\n            var dict=JSON.parse(inputs.control_dct)\n            if (dict[inputs.in_tas.basename]!='null'){\n                for(var i=0; i<ctls.length; i++){\n                    if(ctls[i].basename==dict[inputs.in_tas.basename]){\n                        tas_file_paths.push(ctls[i].path);\n                        break\n                        \n                    } \n                }\n                \n            } \n        }\n        else{\n            if(ctls[0]) tas_file_paths.push(ctls[0].path)\n        }\n       \n        tas_file_paths = tas_file_paths.join(' ');\n        \n        if(inputs.peak_caller == \"macs2\"){\n            cmd1+=\"python3 $(which encode_task_macs2_chip.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.gensz) cmd1+=' --gensz '+ inputs.gensz;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '50000000';\n            if (inputs.pval_thresh) cmd1+=' --pval-thresh '+ inputs.pval_thresh;\n        } \n        else if(inputs.peak_caller == \"spp\"){\n            cmd1+=\"python3 $(which encode_task_spp.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '30000000';\n            if (inputs.fdr_thresh) cmd1+=' --fdr-thresh '+ inputs.fdr_thresh;\n            if (inputs.cpu) cmd1+=' --nth '+ inputs.cpu;\n        }\n        \n        var peak_type='narrowPeak';\n        if (inputs.peak_caller=='spp') peak_type='regionPeak';\n        \n        var cmd2 = '';\n        cmd2+=\"python3 $(which encode_task_post_call_peak_chip.py)\";\n        cmd2+=\" $(ls *Peak.gz)\"\n        cmd2+=\" --ta \" + inputs.in_tas.path;\n        if (inputs.regex_bfilt_peak_chr_name) cmd2+=\" --regex-bfilt-peak-chr-name '\" + inputs.regex_bfilt_peak_chr_name + \"'\";\n        if (inputs.in_chrsz) cmd2+=' --chrsz '+ inputs.in_chrsz.path;\n        if (inputs.fraglen) cmd2+=' --fraglen '+ inputs.fraglen;\n        cmd2+=' --peak-type '+ peak_type;\n        if (inputs.in_blacklist) cmd2+=' --blacklist '+ inputs.in_blacklist.path;\n        \n        cmd=cmd1+' && '+cmd2;\n        \n    }\n    else cmd+=\"echo \\' No TAGALIGN input files provided\\' 1>&2\";\n    \n    \n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var tas_sizes = Array();\n    if (inputs.in_tas) tas_sizes.push(inputs.in_tas.size);\n    if (inputs.in_ctl_tas && inputs.in_ctl_tas[0])  tas_sizes.push(inputs.in_ctl_tas[0].size);\n    tas_sizes = arrSum(tas_sizes);\n    \n   \n    var input_file_size_gb = tas_sizes/10e9;\n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n  \n}",
            "coresMin": "${\n    if(inputs.peak_caller == \"macs2\") return 2;\n    else return inputs.cpu;\n       \n\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223192,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223235,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-7c6f0458/h-442b2fcd/h-c0f2382a/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619223235,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223192,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a3bb2422c2581b02886791a25c7b12f178f3b72e6f410d3163083f85f9c87ea7d"
      },
      "label": "Call Peak PPR1",
      "sbg:x": -833.3299560546875,
      "sbg:y": -1462.9468994140625
    },
    {
      "id": "call_peak_ppr2",
      "in": [
        {
          "id": "peak_caller",
          "source": "peak_caller"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        },
        {
          "id": "in_tas",
          "source": "pool_ta_pr2/out_ta_pooled"
        },
        {
          "id": "fraglen",
          "source": "rounded_mean/out_rounded_mean"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ctl_tas",
          "source": [
            "subsample_pool_ctl/out_ta_control"
          ]
        }
      ],
      "out": [
        {
          "id": "out_peak"
        },
        {
          "id": "out_bfilt_peak"
        },
        {
          "id": "out_bfilt_peak_bb"
        },
        {
          "id": "out_bfilt_peak_starch"
        },
        {
          "id": "out_bfilt_peak_hammock"
        },
        {
          "id": "out_frip_qc"
        },
        {
          "id": "out_peak_region_size_qc"
        },
        {
          "id": "out_peak_region_size_plot"
        },
        {
          "id": "out_num_peak_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-call-peak-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "sbg:toolDefaultValue": "macs2",
            "id": "peak_caller",
            "type": "string?",
            "label": "Peak caller",
            "doc": "Peak caller. Default: macs2.",
            "default": "macs2"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "pipeline_type",
            "type": {
              "type": "enum",
              "symbols": [
                "tf",
                "histone",
                "control"
              ],
              "name": "pipeline_type"
            },
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf.",
            "default": "tf"
          },
          {
            "id": "in_tas",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM. TAGALIGN file (first) and control TAGALIGN file (second; optional).",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length is estimated by cross-correlation analysis, which is valid only when pipeline started from FASTQs. If defined, fragment length estimated by cross-correlation analysis is ignored."
          },
          {
            "sbg:toolDefaultValue": "hs",
            "id": "gensz",
            "type": "string?",
            "label": "Genome sizes",
            "doc": "Genome sizes. \"hs\" for human, \"mm\" for mouse or sum of 2nd columnin chromosome sizes file.",
            "default": "hs"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "50000000",
            "id": "cap_num_peak",
            "type": "string?",
            "label": "Upper limit on the number of peaks",
            "doc": "Cap number of peaks called from a peak-caller (MACS2)."
          },
          {
            "sbg:toolDefaultValue": "0.01",
            "id": "pval_thresh",
            "type": "float?",
            "label": "P-value threshold",
            "doc": "P-value threshold for MACS2 (macs2 callpeak -p).",
            "default": 0.01
          },
          {
            "id": "fdr_thresh",
            "type": "float?",
            "label": "FDR threshold for SPP",
            "doc": "FDR threshold for SPP.",
            "default": 0.01
          },
          {
            "id": "regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Reg-ex for chromosomes",
            "doc": "Reg-ex for chromosomes to keep while filtering peaks. Chromosomes defined here will be kept. All other chromosomes will be filtered out in .bfilt. peak file. This is done along with blacklist filtering peak file. For example: chr[\\dXY]+.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "cpu",
            "type": "int?",
            "label": "Number of cores for task call_peak",
            "doc": "Task call_peak call peaks on TAG-ALIGNs by using SPP/MACS2 peak caller. MACS2 is single-threaded so cpu will be fixed at 2 for MACS2.",
            "default": 6
          },
          {
            "id": "mem_factor",
            "type": "float?",
            "label": "Memory required for task with macs2 as peak_caller",
            "doc": "This factor will be multiplied to the size of TAG-ALIGNs (BEDs) to determine required memory of instance.",
            "default": 5
          },
          {
            "id": "in_ctl_tas",
            "type": "File[]?",
            "label": "Control Tag_Align",
            "doc": "Control Tag_Align files",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "control_dct",
            "type": "string?",
            "label": "Dict pairing TA files with corresponding controls",
            "doc": "Dict pairing TA files with corresponding controls."
          }
        ],
        "outputs": [
          {
            "id": "out_peak",
            "doc": "Generated by encode_task_macs2_atac.py.",
            "label": "Peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*[!.][!b][!f][!i][!l][!t].' + peak_type + '.gz'\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_tas))"
            }
          },
          {
            "id": "out_bfilt_peak",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.gz'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_bb",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak bb",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.bb'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_starch",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak starch",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.starch'\n}"
            }
          },
          {
            "id": "out_bfilt_peak_hammock",
            "doc": "Generated by post_call_peak.py.",
            "label": "Bfilt peak hammock",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    var peak_type='narrowPeak';\n    if (inputs.peak_caller=='spp') peak_type='regionPeak'\n    return '*.bfilt.' + peak_type + '.hammock.gz*'\n}"
            },
            "secondaryFiles": [
              {
                "pattern": ".tbi",
                "required": false
              }
            ]
          },
          {
            "id": "out_frip_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Frip QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.frip.qc"
            }
          },
          {
            "id": "out_peak_region_size_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.qc"
            }
          },
          {
            "id": "out_peak_region_size_plot",
            "doc": "Generated by post_call_peak.py.",
            "label": "Peak region size plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.png"
            }
          },
          {
            "id": "out_num_peak_qc",
            "doc": "Generated by post_call_peak.py.",
            "label": "Num peak QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.num_peak.qc"
            }
          }
        ],
        "doc": "**Call Peak** tool is based on the \u201ccall_peak\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Call Peak** calls peaks on a TAG-ALIGN file.\n\n First, it executes the \u201cencode_task_macs2_chip.py\u201d script, which executes Macs2 callpeak v2.2.4 which calls peaks on a TAG-ALIGN file (output of Bam2ta tool). The output of the previous step, *_peaks.narrowPeak file, is further parsed and the final output is *.narrowPeak.gz file. In the second step, the tool calls the \u201cencode_task_post_call_peak_chip.py\u201d script, which: if blacklist file is provided - filters peaks from .narrowPeak.gz based on blacklist BED file, converts PEAK file to bigBed, converts PEAK file to STARCH file, convert PEAK file to hammock.gz file, determines the fraction of reads in peaks (FRiP) score without fragment length, calculates (blacklist-filtered) PEAK region size QC/plot, and calculates number of peaks (blacklist-filtered).\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Call Peak CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    var cmd = '';\n    if(inputs.pipeline_type=='control') cmd+=\"echo \\' Peak calling is not performed in control mode \\' 1>&2\";\n    else if(inputs.pipeline_type=='histone' && inputs.peak_caller=='spp') cmd+=\"echo \\' spp peak caller not compatible with histone op mode \\' 1>&2 \";\n    else if(inputs.in_tas){\n        var cmd1='';\n        var tas_file_paths = Array();\n        var ctls=[].concat(inputs.in_ctl_tas);\n        tas_file_paths.push(inputs.in_tas.path);\n        if(inputs.control_dct){\n            var dict=JSON.parse(inputs.control_dct)\n            if (dict[inputs.in_tas.basename]!='null'){\n                for(var i=0; i<ctls.length; i++){\n                    if(ctls[i].basename==dict[inputs.in_tas.basename]){\n                        tas_file_paths.push(ctls[i].path);\n                        break\n                        \n                    } \n                }\n                \n            } \n        }\n        else{\n            if(ctls[0]) tas_file_paths.push(ctls[0].path)\n        }\n       \n        tas_file_paths = tas_file_paths.join(' ');\n        \n        if(inputs.peak_caller == \"macs2\"){\n            cmd1+=\"python3 $(which encode_task_macs2_chip.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.gensz) cmd1+=' --gensz '+ inputs.gensz;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '50000000';\n            if (inputs.pval_thresh) cmd1+=' --pval-thresh '+ inputs.pval_thresh;\n        } \n        else if(inputs.peak_caller == \"spp\"){\n            cmd1+=\"python3 $(which encode_task_spp.py) \";\n            cmd1+=tas_file_paths;\n            if (inputs.in_chrsz) cmd1+=' --chrsz '+ inputs.in_chrsz.path;\n            if (inputs.fraglen) cmd1+=' --fraglen '+ inputs.fraglen;\n            if (inputs.cap_num_peak) cmd1+=' --cap-num-peak '+ inputs.cap_num_peak;\n            else cmd1+=' --cap-num-peak '+ '30000000';\n            if (inputs.fdr_thresh) cmd1+=' --fdr-thresh '+ inputs.fdr_thresh;\n            if (inputs.cpu) cmd1+=' --nth '+ inputs.cpu;\n        }\n        \n        var peak_type='narrowPeak';\n        if (inputs.peak_caller=='spp') peak_type='regionPeak';\n        \n        var cmd2 = '';\n        cmd2+=\"python3 $(which encode_task_post_call_peak_chip.py)\";\n        cmd2+=\" $(ls *Peak.gz)\"\n        cmd2+=\" --ta \" + inputs.in_tas.path;\n        if (inputs.regex_bfilt_peak_chr_name) cmd2+=\" --regex-bfilt-peak-chr-name '\" + inputs.regex_bfilt_peak_chr_name + \"'\";\n        if (inputs.in_chrsz) cmd2+=' --chrsz '+ inputs.in_chrsz.path;\n        if (inputs.fraglen) cmd2+=' --fraglen '+ inputs.fraglen;\n        cmd2+=' --peak-type '+ peak_type;\n        if (inputs.in_blacklist) cmd2+=' --blacklist '+ inputs.in_blacklist.path;\n        \n        cmd=cmd1+' && '+cmd2;\n        \n    }\n    else cmd+=\"echo \\' No TAGALIGN input files provided\\' 1>&2\";\n    \n    \n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    var arrSum = function(arr){\n        return arr.reduce(function(a,b){\n            return a + b }, 0);\n    }\n    \n    var tas_sizes = Array();\n    if (inputs.in_tas) tas_sizes.push(inputs.in_tas.size);\n    if (inputs.in_ctl_tas && inputs.in_ctl_tas[0])  tas_sizes.push(inputs.in_ctl_tas[0].size);\n    tas_sizes = arrSum(tas_sizes);\n    \n   \n    var input_file_size_gb = tas_sizes/10e9;\n    var mem_gb = 4.0 + inputs.mem_factor * input_file_size_gb;\n    var mem_mb=Math.round(mem_gb/1e-3)\n    var limit=Math.round(384/1e-3)\n    return mem_mb<limit ? mem_mb : limit;\n    \n  \n}",
            "coresMin": "${\n    if(inputs.peak_caller == \"macs2\") return 2;\n    else return inputs.cpu;\n       \n\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223192,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619223235,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-f47fd8c5/h-2dcf7faf/h-b5c86797/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619223235,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619223192,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a3bb2422c2581b02886791a25c7b12f178f3b72e6f410d3163083f85f9c87ea7d"
      },
      "label": "Call Peak PPR2",
      "sbg:x": -795.0733642578125,
      "sbg:y": -1090.8367919921875
    },
    {
      "id": "sbg_cross_files_cwl1_1",
      "in": [
        {
          "id": "in_peaks",
          "source": [
            "call_peak_bio_replicates/out_peak"
          ]
        }
      ],
      "out": [
        {
          "id": "out_first"
        },
        {
          "id": "out_second"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/sbg-cross-files-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "in_peaks",
            "type": "File[]?",
            "label": "Input peak files",
            "doc": "Input peak files."
          }
        ],
        "outputs": [
          {
            "id": "out_first",
            "type": "File[]?",
            "outputBinding": {
              "glob": "*Peak.gz",
              "outputEval": "${\n    var inp=[].concat(inputs.in_peaks);\n    var first=Array();\n    \n    for (var i=0;i<inp.length;i++){\n        for(var j=0;j<inp.length;j++){\n            if (i<j){\n                first.push(inp[i]);\n                if(inp[i]) first[i].metadata=inp[i].metadata;\n                \n            }\n        }\n        \n    }\n    \n    return first;\n}"
            }
          },
          {
            "id": "out_second",
            "type": "File[]?",
            "outputBinding": {
              "glob": "*Peak.gz",
              "outputEval": "${\n    var inp=[].concat(inputs.in_peaks);\n    var second=Array();\n    \n    for (var i=0;i<inp.length;i++){\n        for(var j=0;j<inp.length;j++){\n            if (i<j){ \n                second.push(inp[j]);\n                if(inp[j]) second[i].metadata=inp[j].metadata;\n            }\n        }\n        \n    }\n    \n    return second;\n}"
            }
          }
        ],
        "doc": "**SBG Cross Files CWL1.1** tool is added after the peak calling step in order to ensure all the combinations of pairs of replicates are provided to cross-validation analyses (IDR/overlap).",
        "label": "SBG Cross Files CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    var cmd='';\n    var check=0;\n    if(inputs.in_peaks){\n        var list=[].concat(inputs.in_peaks);\n        for(var i=0; i<list.length; i++){\n            if (!list[i]) check=1;\n        }\n        if (check) cmd=\"echo \\' Some files are missing\\' 1>&2\";\n        else cmd=\"echo \\'cross combining files\\' 1>&2\";\n        \n    }\n    else cmd=\"echo \\'No input files provided\\' 1>&2\";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 2000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/sevenbridges/ubuntu:14.04"
          },
          {
            "class": "InitialWorkDirRequirement",
            "listing": [
              "$(inputs.in_peaks)"
            ]
          },
          {
            "class": "InlineJavascriptRequirement"
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258340,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258614,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-a0c7b2f3/h-11cdabd2/h-9d0151ae/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619258614,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619258340,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a17001b3b4c8c446bf5c085c15ea5be316fd3083037f1d2846324d588a6764a35"
      },
      "label": "SBG Cross Files CWL1.1",
      "sbg:x": -670.5899658203125,
      "sbg:y": -1902.205078125
    },
    {
      "id": "overlap_bio_replicates",
      "in": [
        {
          "id": "in_peak1",
          "source": "sbg_cross_files_cwl1_1/out_first"
        },
        {
          "id": "in_peak2",
          "source": "sbg_cross_files_cwl1_1/out_second"
        },
        {
          "id": "in_peak_pooled",
          "source": "call_peak_pooled_replicates/out_peak"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ta",
          "source": "pool_ta_bio_replicates/out_ta_pooled"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "fraglen",
          "source": "rounded_mean/out_rounded_mean"
        }
      ],
      "out": [
        {
          "id": "out_overlap_peak"
        },
        {
          "id": "out_bfilt_overlap_peak"
        },
        {
          "id": "out_bfilt_overlap_peak_bb"
        },
        {
          "id": "out_bfilt_overlap_peak_starch"
        },
        {
          "id": "out_bfilt_overlap_peak_hammock"
        },
        {
          "id": "out_frip_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-overlap-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "prefix",
            "type": "string?",
            "label": "Prefix",
            "doc": "Prefix basename for output overlap peak."
          },
          {
            "id": "in_peak1",
            "type": "File?",
            "label": "Peak",
            "doc": "Peak 1."
          },
          {
            "id": "in_peak2",
            "type": "File?",
            "label": "Peak 2",
            "doc": "Peak 2."
          },
          {
            "id": "in_peak_pooled",
            "type": "File?",
            "label": "Pooled peak",
            "doc": "Pooled peak."
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist BED",
            "doc": "Blacklist BED file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "in_regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Keep chromosomes matching the pattern",
            "doc": "Keep chromosomes matching this pattern only in BFILT peak files.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_ta",
            "type": "File?",
            "label": "TAGALIGN file",
            "doc": "TAGALIGN file for FRiP."
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chromosome sizes",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "peak_type",
            "type": "string?",
            "label": "Peak type",
            "doc": "Peak file type."
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length",
            "doc": "Fragment length for TAGALIGN file. If given, do shifted FRiP."
          }
        ],
        "outputs": [
          {
            "id": "out_overlap_peak",
            "doc": "Non filtered overlap peak.",
            "label": "Overlap peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*[!.][!b][!f][!i][!l][!t].'+ peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n    }\n    \n}"
            }
          },
          {
            "id": "out_bfilt_overlap_peak",
            "doc": "Blacklist-filtered overlap peak (BigBed).",
            "label": "Filtered overlap peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n    }\n    \n}"
            }
          },
          {
            "id": "out_bfilt_overlap_peak_bb",
            "doc": "Blacklist-filtered overlap peak (BigBed).",
            "label": "Filtered overlap peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.bb'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n    }\n    \n}"
            }
          },
          {
            "id": "out_bfilt_overlap_peak_starch",
            "doc": "Blacklist-filtered overlap peak (starch)",
            "label": "Filtered overlap peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.starch'\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_peak1))"
            }
          },
          {
            "id": "out_bfilt_overlap_peak_hammock",
            "doc": "Blacklist-filtered overlap peak (hammock).",
            "label": "Filtered overlap peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.hammock.gz*'\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_peak1))"
            },
            "secondaryFiles": [
              {
                "pattern": ".tbi",
                "required": false
              }
            ]
          },
          {
            "id": "out_frip_qc",
            "doc": "Fraction of overlap peaks in reads.",
            "label": "Overlap fraction",
            "type": "File?",
            "outputBinding": {
              "glob": "*.frip.qc"
            }
          }
        ],
        "doc": "- Overlap tools finds pooled peaks that overlap peak1 and peak2, where overlap is defined as the fractional overlap and where the any one of the overlapping peak pairs >= 0.5.\n- It performs filtering of the Blacklisted peaks, and converting peaks to BIGBED, STARCH, and HAMMOCK.\n- If TAG-ALIGN is given it calculates the shifted FRiP with fragment length.",
        "label": "ENCODE ChIP-Seq Overlap CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    var cmd='';\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled){\n        if(inputs.in_ta) cmd+='touch null &&';\n        else cmd+='touch null.frip.qc && touch null &&';\n        cmd+=' python3 $(which encode_task_overlap.py) ';\n        cmd+=inputs.in_peak1.path;\n        cmd+=' '+inputs.in_peak2.path;\n        cmd+=' '+inputs.in_peak_pooled.path;\n        if (inputs.prefix) cmd+=' --prefix '+inputs.prefix;\n        \n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        cmd+=' --peak-type '+peak_type;\n        if(inputs.fraglen) cmd+=' --fraglen '+inputs.fraglen;\n        if(inputs.in_chrsz)cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.in_blacklist)cmd+=' --blacklist '+inputs.in_blacklist.path;\n        cmd+=' --nonamecheck ';\n        if(inputs.in_regex_bfilt_peak_chr_name) cmd+=\" --regex-bfilt-peak-chr-name '\" + inputs.in_regex_bfilt_peak_chr_name + \"'\";\n        if(inputs.in_ta) cmd+=' --ta '+inputs.in_ta.path;\n        \n    }\n    else cmd=\"echo \\'No inputs provided\\' 1>&2\";\n    \n    return cmd;\n \n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258857,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258924,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE Chip-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "Chip-Seq"
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:wrapperAuthor": "",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-8533a8d4/h-e7fd8c49/h-e41df564/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619258924,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619258857,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a83b37ab0753ff3ba3b727077535ec3629155c87f852034c02c0f4146dfcc0067"
      },
      "label": "Overlap Bio-replicates",
      "scatter": [
        "in_peak1",
        "in_peak2"
      ],
      "scatterMethod": "dotproduct",
      "sbg:x": -456.05596923828125,
      "sbg:y": -2182.107666015625
    },
    {
      "id": "idr_bio_replicates",
      "in": [
        {
          "id": "in_peak1",
          "source": "sbg_cross_files_cwl1_1/out_first"
        },
        {
          "id": "in_peak2",
          "source": "sbg_cross_files_cwl1_1/out_second"
        },
        {
          "id": "in_peak_pooled",
          "source": "call_peak_pooled_replicates/out_peak"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ta",
          "source": "pool_ta_bio_replicates/out_ta_pooled"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "fraglen",
          "source": "rounded_mean/out_rounded_mean"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        }
      ],
      "out": [
        {
          "id": "out_idr_peak"
        },
        {
          "id": "out_bfilt_idr_peak"
        },
        {
          "id": "out_bfilt_idr_peak_bb"
        },
        {
          "id": "out_bfilt_idr_peak_starch"
        },
        {
          "id": "out_bfilt_idr_peak_hammock"
        },
        {
          "id": "idr_plot"
        },
        {
          "id": "idr_unthresholded_peak"
        },
        {
          "id": "idr_log"
        },
        {
          "id": "frip_qc"
        },
        {
          "id": "bfilt_idr_peak_hammock_tbi"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-idr-1-7-1-cwl1-1/2",
        "baseCommand": [],
        "inputs": [
          {
            "id": "prefix",
            "type": "string?",
            "label": "Prefix for IDR output file",
            "doc": "Prefix for IDR output file."
          },
          {
            "id": "in_peak1",
            "type": "File?",
            "label": "Peak file 1",
            "doc": "Peak file 1.",
            "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ"
          },
          {
            "id": "in_peak2",
            "type": "File?",
            "label": "Peak file 2",
            "doc": "Peak file 2.",
            "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ"
          },
          {
            "id": "in_peak_pooled",
            "type": "File?",
            "label": "NARROWPEAK file for pooled true replicate",
            "doc": "NARROWPEAK file for pooled true replicate. Define if you want to start pipeline from PEAK files. Define if you have multiple biological replicates. Pooled true replicate means analysis on pooled biological replicates.",
            "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ"
          },
          {
            "sbg:toolDefaultValue": "0.05",
            "id": "idr_thresh",
            "type": "float?",
            "label": "IDR threshold",
            "doc": "IDR threshold.",
            "default": 0.05
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Reg-ex for chromosomes",
            "doc": "Reg-ex for chromosomes to keep while filtering peaks. Chromosomes defined here will be kept. All other chromosomes will be filtered out in .bfilt. peak file. This is done along with blacklist filtering peak file. For example: chr[\\dXY]+.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_ta",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "peak_type",
            "type": "string?",
            "label": "Peak type",
            "doc": "Peak type {narrowPeak,regionPeak}. Default: narrowPeak."
          },
          {
            "sbg:toolDefaultValue": "p.value",
            "id": "rank",
            "type": "string?",
            "label": "IDR ranking method",
            "doc": "if peak_caller_=='spp' then 'signal.value' else if peak_caller_=='macs2' then 'p.value' else 'p.value'"
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length from xcor."
          },
          {
            "sbg:toolDefaultValue": "tf",
            "id": "pipeline_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "tf",
                  "histone",
                  "control"
                ],
                "name": "pipeline_type"
              }
            ],
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf."
          }
        ],
        "outputs": [
          {
            "id": "out_idr_peak",
            "doc": "IDR peak.",
            "label": "IDR peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*[!.][!b][!f][!i][!l][!t].' + peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n   if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n   }\n    \n}"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_bfilt_idr_peak",
            "doc": "Blacklist-filtered IDR peak.",
            "label": "Blacklist-filtered IDR peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n   }\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_bfilt_idr_peak_bb",
            "doc": "Blacklist-filtered IDR peak (BigBed).",
            "label": "Blacklist-filtered IDR peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.bb'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n   }\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.BB"
          },
          {
            "id": "out_bfilt_idr_peak_starch",
            "doc": "Blacklist-filtered IDR peak (starch).",
            "label": "Blacklist-filtered IDR peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n   if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.starch'\n   }\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.STARCH"
          },
          {
            "id": "out_bfilt_idr_peak_hammock",
            "doc": "Blacklist-filtered IDR peak (hammock).",
            "label": "Blacklist-filtered IDR peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.hammock.gz*'\n    }\n}",
              "outputEval": "${\n    return self[0];\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ"
          },
          {
            "id": "idr_plot",
            "doc": "IDR plot.",
            "label": "IDR plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.txt.png"
            },
            "sbg:fileTypes": "PNG"
          },
          {
            "id": "idr_unthresholded_peak",
            "doc": "Unthresholded raw IDR peak.",
            "label": "Unthresholded raw IDR peak",
            "type": "File?",
            "outputBinding": {
              "glob": "*.txt.gz"
            },
            "sbg:fileTypes": "TXT.GZ"
          },
          {
            "id": "idr_log",
            "doc": "IDR log.",
            "label": "IDR log",
            "type": "File?",
            "outputBinding": {
              "glob": "*.idr*.log"
            },
            "sbg:fileTypes": "LOG"
          },
          {
            "id": "frip_qc",
            "doc": "Fraction of IDR peaks in reads.",
            "label": "Fraction of IDR peaks in reads",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_ta) return '*.frip.qc';\n    else return '';\n\n}"
            },
            "sbg:fileTypes": "FRIP.QC"
          },
          {
            "id": "bfilt_idr_peak_hammock_tbi",
            "doc": "Blacklist-filtered IDR peak (hammock tbi).",
            "label": "Blacklist-filtered IDR peak (hammock tbi)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.hammock.gz*'\n    }\n}",
              "outputEval": "${\n    return self[1]\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ.TBI"
          }
        ],
        "doc": "**Idr** tool is based on the \u201cidr\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Idr** compares a pair of ranked lists of regions/peaks and assigns values that reflect its reproducibility.\n\nThe basic idea is that if two replicates measure the same underlying biology, the most significant peaks, which are likely to be genuine signals, are expected to have high consistency between replicates, whereas peaks with low significance, which are more likely to be noise, are expected to have low consistency. If the consistency between a pair of rank lists (peaks) that contains both significant and insignificant findings is plotted, a transition in consistency is expected. This consistency transition provides an internal indicator of the change from signal to noise and suggests how many peaks have been reliably detected.\n\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Idr CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    \n    var cmd='';\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        if (inputs.in_ta) cmd+='touch null &&';\n        else cmd+='touch null.frip.qc && touch null &&';\n        cmd+=' python3 $(which encode_task_idr.py) ';\n        cmd+=inputs.in_peak1.path;\n        cmd+=' '+inputs.in_peak2.path;\n        cmd+=' '+inputs.in_peak_pooled.path;\n        if (inputs.prefix) cmd+=' --prefix '+inputs.prefix;\n        if (inputs.idr_thresh) cmd+=' --idr-thresh '+inputs.idr_thresh;\n        \n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.');\n        var peak_type=peak[peak.length-1];\n        cmd+=' --peak-type '+peak_type;\n        \n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.');\n        var peak_type=peak[peak.length-1];\n        var rank='';\n        if(peak_type=='narrowPeak') rank='p.value';\n        else if (peak_type=='regionPeak') rank='signal.value'\n        cmd+=' --idr-rank '+rank;\n        if(inputs.fraglen) cmd+=' --fraglen '+inputs.fraglen;\n        if(inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.in_blacklist) cmd+=' --blacklist '+inputs.in_blacklist.path;\n        if(inputs.regex_bfilt_peak_chr_name) cmd+=\" --regex-bfilt-peak-chr-name '\" + inputs.regex_bfilt_peak_chr_name + \"'\";\n        \n        if(inputs.in_ta) cmd+=' --ta '+inputs.in_ta.path;\n        \n        \n    }\n    else cmd=\"echo \\' Idr disabled\\' 1>&2 \";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258985,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259043,
            "sbg:revisionNotes": "from dev"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259251,
            "sbg:revisionNotes": "name updated"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-6008462e/h-05b09350/h-32b79a70/0",
        "sbg:revision": 2,
        "sbg:revisionNotes": "name updated",
        "sbg:modifiedOn": 1619259251,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619258985,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 2,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "abb309e151e61cc2ec19ec3d6628763e6f65b098fbd4fe4f50a1a0cbc9e2aaa93"
      },
      "label": "Idr Bio-replicates",
      "scatter": [
        "in_peak1",
        "in_peak2"
      ],
      "scatterMethod": "dotproduct",
      "sbg:x": -459.0369873046875,
      "sbg:y": -1952.0390625
    },
    {
      "id": "overlap_pr",
      "in": [
        {
          "id": "in_peak1",
          "source": "call_peak_pr1/out_peak"
        },
        {
          "id": "in_peak2",
          "source": "call_peak_pr2/out_peak"
        },
        {
          "id": "in_peak_pooled",
          "source": "call_peak_bio_replicates/out_peak"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ta",
          "source": "bam2ta_bio_replicates/out_ta"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "fraglen",
          "source": "xcor/fraglen"
        }
      ],
      "out": [
        {
          "id": "out_overlap_peak"
        },
        {
          "id": "out_bfilt_overlap_peak"
        },
        {
          "id": "out_bfilt_overlap_peak_bb"
        },
        {
          "id": "out_bfilt_overlap_peak_starch"
        },
        {
          "id": "out_bfilt_overlap_peak_hammock"
        },
        {
          "id": "out_frip_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-overlap-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "prefix",
            "type": "string?",
            "label": "Prefix",
            "doc": "Prefix basename for output overlap peak."
          },
          {
            "id": "in_peak1",
            "type": "File?",
            "label": "Peak",
            "doc": "Peak 1."
          },
          {
            "id": "in_peak2",
            "type": "File?",
            "label": "Peak 2",
            "doc": "Peak 2."
          },
          {
            "id": "in_peak_pooled",
            "type": "File?",
            "label": "Pooled peak",
            "doc": "Pooled peak."
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist BED",
            "doc": "Blacklist BED file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "in_regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Keep chromosomes matching the pattern",
            "doc": "Keep chromosomes matching this pattern only in BFILT peak files.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_ta",
            "type": "File?",
            "label": "TAGALIGN file",
            "doc": "TAGALIGN file for FRiP."
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chromosome sizes",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "peak_type",
            "type": "string?",
            "label": "Peak type",
            "doc": "Peak file type."
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length",
            "doc": "Fragment length for TAGALIGN file. If given, do shifted FRiP."
          }
        ],
        "outputs": [
          {
            "id": "out_overlap_peak",
            "doc": "Non filtered overlap peak.",
            "label": "Overlap peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*[!.][!b][!f][!i][!l][!t].'+ peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n    }\n    \n}"
            }
          },
          {
            "id": "out_bfilt_overlap_peak",
            "doc": "Blacklist-filtered overlap peak (BigBed).",
            "label": "Filtered overlap peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n    }\n    \n}"
            }
          },
          {
            "id": "out_bfilt_overlap_peak_bb",
            "doc": "Blacklist-filtered overlap peak (BigBed).",
            "label": "Filtered overlap peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.bb'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n    }\n    \n}"
            }
          },
          {
            "id": "out_bfilt_overlap_peak_starch",
            "doc": "Blacklist-filtered overlap peak (starch)",
            "label": "Filtered overlap peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.starch'\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_peak1))"
            }
          },
          {
            "id": "out_bfilt_overlap_peak_hammock",
            "doc": "Blacklist-filtered overlap peak (hammock).",
            "label": "Filtered overlap peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.hammock.gz*'\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_peak1))"
            },
            "secondaryFiles": [
              {
                "pattern": ".tbi",
                "required": false
              }
            ]
          },
          {
            "id": "out_frip_qc",
            "doc": "Fraction of overlap peaks in reads.",
            "label": "Overlap fraction",
            "type": "File?",
            "outputBinding": {
              "glob": "*.frip.qc"
            }
          }
        ],
        "doc": "- Overlap tools finds pooled peaks that overlap peak1 and peak2, where overlap is defined as the fractional overlap and where the any one of the overlapping peak pairs >= 0.5.\n- It performs filtering of the Blacklisted peaks, and converting peaks to BIGBED, STARCH, and HAMMOCK.\n- If TAG-ALIGN is given it calculates the shifted FRiP with fragment length.",
        "label": "ENCODE ChIP-Seq Overlap CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    var cmd='';\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled){\n        if(inputs.in_ta) cmd+='touch null &&';\n        else cmd+='touch null.frip.qc && touch null &&';\n        cmd+=' python3 $(which encode_task_overlap.py) ';\n        cmd+=inputs.in_peak1.path;\n        cmd+=' '+inputs.in_peak2.path;\n        cmd+=' '+inputs.in_peak_pooled.path;\n        if (inputs.prefix) cmd+=' --prefix '+inputs.prefix;\n        \n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        cmd+=' --peak-type '+peak_type;\n        if(inputs.fraglen) cmd+=' --fraglen '+inputs.fraglen;\n        if(inputs.in_chrsz)cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.in_blacklist)cmd+=' --blacklist '+inputs.in_blacklist.path;\n        cmd+=' --nonamecheck ';\n        if(inputs.in_regex_bfilt_peak_chr_name) cmd+=\" --regex-bfilt-peak-chr-name '\" + inputs.in_regex_bfilt_peak_chr_name + \"'\";\n        if(inputs.in_ta) cmd+=' --ta '+inputs.in_ta.path;\n        \n    }\n    else cmd=\"echo \\'No inputs provided\\' 1>&2\";\n    \n    return cmd;\n \n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258857,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258924,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE Chip-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "Chip-Seq"
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:wrapperAuthor": "",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-b20a4ce9/h-d94ee521/h-942465e3/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619258924,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619258857,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a83b37ab0753ff3ba3b727077535ec3629155c87f852034c02c0f4146dfcc0067"
      },
      "label": "Overlap PR",
      "scatter": [
        "in_peak1",
        "in_peak2",
        "in_peak_pooled",
        "in_ta",
        "fraglen"
      ],
      "scatterMethod": "dotproduct",
      "sbg:x": -430.61199951171875,
      "sbg:y": -1692.3060302734375
    },
    {
      "id": "idr_pr",
      "in": [
        {
          "id": "in_peak1",
          "source": "call_peak_pr1/out_peak"
        },
        {
          "id": "in_peak2",
          "source": "call_peak_pr2/out_peak"
        },
        {
          "id": "in_peak_pooled",
          "source": "call_peak_bio_replicates/out_peak"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ta",
          "source": "bam2ta_bio_replicates/out_ta"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "fraglen",
          "source": "xcor/fraglen"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        }
      ],
      "out": [
        {
          "id": "out_idr_peak"
        },
        {
          "id": "out_bfilt_idr_peak"
        },
        {
          "id": "out_bfilt_idr_peak_bb"
        },
        {
          "id": "out_bfilt_idr_peak_starch"
        },
        {
          "id": "out_bfilt_idr_peak_hammock"
        },
        {
          "id": "idr_plot"
        },
        {
          "id": "idr_unthresholded_peak"
        },
        {
          "id": "idr_log"
        },
        {
          "id": "frip_qc"
        },
        {
          "id": "bfilt_idr_peak_hammock_tbi"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-idr-1-7-1-cwl1-1/2",
        "baseCommand": [],
        "inputs": [
          {
            "id": "prefix",
            "type": "string?",
            "label": "Prefix for IDR output file",
            "doc": "Prefix for IDR output file."
          },
          {
            "id": "in_peak1",
            "type": "File?",
            "label": "Peak file 1",
            "doc": "Peak file 1.",
            "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ"
          },
          {
            "id": "in_peak2",
            "type": "File?",
            "label": "Peak file 2",
            "doc": "Peak file 2.",
            "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ"
          },
          {
            "id": "in_peak_pooled",
            "type": "File?",
            "label": "NARROWPEAK file for pooled true replicate",
            "doc": "NARROWPEAK file for pooled true replicate. Define if you want to start pipeline from PEAK files. Define if you have multiple biological replicates. Pooled true replicate means analysis on pooled biological replicates.",
            "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ"
          },
          {
            "sbg:toolDefaultValue": "0.05",
            "id": "idr_thresh",
            "type": "float?",
            "label": "IDR threshold",
            "doc": "IDR threshold.",
            "default": 0.05
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Reg-ex for chromosomes",
            "doc": "Reg-ex for chromosomes to keep while filtering peaks. Chromosomes defined here will be kept. All other chromosomes will be filtered out in .bfilt. peak file. This is done along with blacklist filtering peak file. For example: chr[\\dXY]+.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_ta",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "peak_type",
            "type": "string?",
            "label": "Peak type",
            "doc": "Peak type {narrowPeak,regionPeak}. Default: narrowPeak."
          },
          {
            "sbg:toolDefaultValue": "p.value",
            "id": "rank",
            "type": "string?",
            "label": "IDR ranking method",
            "doc": "if peak_caller_=='spp' then 'signal.value' else if peak_caller_=='macs2' then 'p.value' else 'p.value'"
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length from xcor."
          },
          {
            "sbg:toolDefaultValue": "tf",
            "id": "pipeline_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "tf",
                  "histone",
                  "control"
                ],
                "name": "pipeline_type"
              }
            ],
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf."
          }
        ],
        "outputs": [
          {
            "id": "out_idr_peak",
            "doc": "IDR peak.",
            "label": "IDR peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*[!.][!b][!f][!i][!l][!t].' + peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n   if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n   }\n    \n}"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_bfilt_idr_peak",
            "doc": "Blacklist-filtered IDR peak.",
            "label": "Blacklist-filtered IDR peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n   }\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_bfilt_idr_peak_bb",
            "doc": "Blacklist-filtered IDR peak (BigBed).",
            "label": "Blacklist-filtered IDR peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.bb'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n   }\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.BB"
          },
          {
            "id": "out_bfilt_idr_peak_starch",
            "doc": "Blacklist-filtered IDR peak (starch).",
            "label": "Blacklist-filtered IDR peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n   if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.starch'\n   }\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.STARCH"
          },
          {
            "id": "out_bfilt_idr_peak_hammock",
            "doc": "Blacklist-filtered IDR peak (hammock).",
            "label": "Blacklist-filtered IDR peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.hammock.gz*'\n    }\n}",
              "outputEval": "${\n    return self[0];\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ"
          },
          {
            "id": "idr_plot",
            "doc": "IDR plot.",
            "label": "IDR plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.txt.png"
            },
            "sbg:fileTypes": "PNG"
          },
          {
            "id": "idr_unthresholded_peak",
            "doc": "Unthresholded raw IDR peak.",
            "label": "Unthresholded raw IDR peak",
            "type": "File?",
            "outputBinding": {
              "glob": "*.txt.gz"
            },
            "sbg:fileTypes": "TXT.GZ"
          },
          {
            "id": "idr_log",
            "doc": "IDR log.",
            "label": "IDR log",
            "type": "File?",
            "outputBinding": {
              "glob": "*.idr*.log"
            },
            "sbg:fileTypes": "LOG"
          },
          {
            "id": "frip_qc",
            "doc": "Fraction of IDR peaks in reads.",
            "label": "Fraction of IDR peaks in reads",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_ta) return '*.frip.qc';\n    else return '';\n\n}"
            },
            "sbg:fileTypes": "FRIP.QC"
          },
          {
            "id": "bfilt_idr_peak_hammock_tbi",
            "doc": "Blacklist-filtered IDR peak (hammock tbi).",
            "label": "Blacklist-filtered IDR peak (hammock tbi)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.hammock.gz*'\n    }\n}",
              "outputEval": "${\n    return self[1]\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ.TBI"
          }
        ],
        "doc": "**Idr** tool is based on the \u201cidr\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Idr** compares a pair of ranked lists of regions/peaks and assigns values that reflect its reproducibility.\n\nThe basic idea is that if two replicates measure the same underlying biology, the most significant peaks, which are likely to be genuine signals, are expected to have high consistency between replicates, whereas peaks with low significance, which are more likely to be noise, are expected to have low consistency. If the consistency between a pair of rank lists (peaks) that contains both significant and insignificant findings is plotted, a transition in consistency is expected. This consistency transition provides an internal indicator of the change from signal to noise and suggests how many peaks have been reliably detected.\n\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Idr CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    \n    var cmd='';\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        if (inputs.in_ta) cmd+='touch null &&';\n        else cmd+='touch null.frip.qc && touch null &&';\n        cmd+=' python3 $(which encode_task_idr.py) ';\n        cmd+=inputs.in_peak1.path;\n        cmd+=' '+inputs.in_peak2.path;\n        cmd+=' '+inputs.in_peak_pooled.path;\n        if (inputs.prefix) cmd+=' --prefix '+inputs.prefix;\n        if (inputs.idr_thresh) cmd+=' --idr-thresh '+inputs.idr_thresh;\n        \n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.');\n        var peak_type=peak[peak.length-1];\n        cmd+=' --peak-type '+peak_type;\n        \n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.');\n        var peak_type=peak[peak.length-1];\n        var rank='';\n        if(peak_type=='narrowPeak') rank='p.value';\n        else if (peak_type=='regionPeak') rank='signal.value'\n        cmd+=' --idr-rank '+rank;\n        if(inputs.fraglen) cmd+=' --fraglen '+inputs.fraglen;\n        if(inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.in_blacklist) cmd+=' --blacklist '+inputs.in_blacklist.path;\n        if(inputs.regex_bfilt_peak_chr_name) cmd+=\" --regex-bfilt-peak-chr-name '\" + inputs.regex_bfilt_peak_chr_name + \"'\";\n        \n        if(inputs.in_ta) cmd+=' --ta '+inputs.in_ta.path;\n        \n        \n    }\n    else cmd=\"echo \\' Idr disabled\\' 1>&2 \";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258985,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259043,
            "sbg:revisionNotes": "from dev"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259251,
            "sbg:revisionNotes": "name updated"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-6254fae6/h-7946dcf4/h-233f7241/0",
        "sbg:revision": 2,
        "sbg:revisionNotes": "name updated",
        "sbg:modifiedOn": 1619259251,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619258985,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 2,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "abb309e151e61cc2ec19ec3d6628763e6f65b098fbd4fe4f50a1a0cbc9e2aaa93"
      },
      "label": "Idr PR",
      "scatter": [
        "in_peak1",
        "in_peak2",
        "in_peak_pooled",
        "in_ta",
        "fraglen"
      ],
      "scatterMethod": "dotproduct",
      "sbg:x": -447.91650390625,
      "sbg:y": -1456.5560302734375
    },
    {
      "id": "overlap_ppr",
      "in": [
        {
          "id": "in_peak1",
          "source": "call_peak_ppr1/out_peak"
        },
        {
          "id": "in_peak2",
          "source": "call_peak_ppr2/out_peak"
        },
        {
          "id": "in_peak_pooled",
          "source": "call_peak_pooled_replicates/out_peak"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ta",
          "source": "pool_ta_bio_replicates/out_ta_pooled"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "fraglen",
          "source": "rounded_mean/out_rounded_mean"
        }
      ],
      "out": [
        {
          "id": "out_overlap_peak"
        },
        {
          "id": "out_bfilt_overlap_peak"
        },
        {
          "id": "out_bfilt_overlap_peak_bb"
        },
        {
          "id": "out_bfilt_overlap_peak_starch"
        },
        {
          "id": "out_bfilt_overlap_peak_hammock"
        },
        {
          "id": "out_frip_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-overlap-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "prefix",
            "type": "string?",
            "label": "Prefix",
            "doc": "Prefix basename for output overlap peak."
          },
          {
            "id": "in_peak1",
            "type": "File?",
            "label": "Peak",
            "doc": "Peak 1."
          },
          {
            "id": "in_peak2",
            "type": "File?",
            "label": "Peak 2",
            "doc": "Peak 2."
          },
          {
            "id": "in_peak_pooled",
            "type": "File?",
            "label": "Pooled peak",
            "doc": "Pooled peak."
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist BED",
            "doc": "Blacklist BED file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "in_regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Keep chromosomes matching the pattern",
            "doc": "Keep chromosomes matching this pattern only in BFILT peak files.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_ta",
            "type": "File?",
            "label": "TAGALIGN file",
            "doc": "TAGALIGN file for FRiP."
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chromosome sizes",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "peak_type",
            "type": "string?",
            "label": "Peak type",
            "doc": "Peak file type."
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length",
            "doc": "Fragment length for TAGALIGN file. If given, do shifted FRiP."
          }
        ],
        "outputs": [
          {
            "id": "out_overlap_peak",
            "doc": "Non filtered overlap peak.",
            "label": "Overlap peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*[!.][!b][!f][!i][!l][!t].'+ peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n    }\n    \n}"
            }
          },
          {
            "id": "out_bfilt_overlap_peak",
            "doc": "Blacklist-filtered overlap peak (BigBed).",
            "label": "Filtered overlap peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n    }\n    \n}"
            }
          },
          {
            "id": "out_bfilt_overlap_peak_bb",
            "doc": "Blacklist-filtered overlap peak (BigBed).",
            "label": "Filtered overlap peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.bb'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n    }\n    \n}"
            }
          },
          {
            "id": "out_bfilt_overlap_peak_starch",
            "doc": "Blacklist-filtered overlap peak (starch)",
            "label": "Filtered overlap peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.starch'\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_peak1))"
            }
          },
          {
            "id": "out_bfilt_overlap_peak_hammock",
            "doc": "Blacklist-filtered overlap peak (hammock).",
            "label": "Filtered overlap peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.hammock.gz*'\n    }\n}",
              "outputEval": "$(inheritMetadata(self, inputs.in_peak1))"
            },
            "secondaryFiles": [
              {
                "pattern": ".tbi",
                "required": false
              }
            ]
          },
          {
            "id": "out_frip_qc",
            "doc": "Fraction of overlap peaks in reads.",
            "label": "Overlap fraction",
            "type": "File?",
            "outputBinding": {
              "glob": "*.frip.qc"
            }
          }
        ],
        "doc": "- Overlap tools finds pooled peaks that overlap peak1 and peak2, where overlap is defined as the fractional overlap and where the any one of the overlapping peak pairs >= 0.5.\n- It performs filtering of the Blacklisted peaks, and converting peaks to BIGBED, STARCH, and HAMMOCK.\n- If TAG-ALIGN is given it calculates the shifted FRiP with fragment length.",
        "label": "ENCODE ChIP-Seq Overlap CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 1,
            "valueFrom": "${\n    var cmd='';\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled){\n        if(inputs.in_ta) cmd+='touch null &&';\n        else cmd+='touch null.frip.qc && touch null &&';\n        cmd+=' python3 $(which encode_task_overlap.py) ';\n        cmd+=inputs.in_peak1.path;\n        cmd+=' '+inputs.in_peak2.path;\n        cmd+=' '+inputs.in_peak_pooled.path;\n        if (inputs.prefix) cmd+=' --prefix '+inputs.prefix;\n        \n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        cmd+=' --peak-type '+peak_type;\n        if(inputs.fraglen) cmd+=' --fraglen '+inputs.fraglen;\n        if(inputs.in_chrsz)cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.in_blacklist)cmd+=' --blacklist '+inputs.in_blacklist.path;\n        cmd+=' --nonamecheck ';\n        if(inputs.in_regex_bfilt_peak_chr_name) cmd+=\" --regex-bfilt-peak-chr-name '\" + inputs.in_regex_bfilt_peak_chr_name + \"'\";\n        if(inputs.in_ta) cmd+=' --ta '+inputs.in_ta.path;\n        \n    }\n    else cmd=\"echo \\'No inputs provided\\' 1>&2\";\n    \n    return cmd;\n \n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258857,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258924,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE Chip-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "Chip-Seq"
        ],
        "sbg:license": "MIT",
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:wrapperAuthor": "",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-26bd8a0a/h-2db8b3bd/h-d3079e0d/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619258924,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619258857,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a83b37ab0753ff3ba3b727077535ec3629155c87f852034c02c0f4146dfcc0067"
      },
      "label": "Overlap PPR",
      "sbg:x": -435.02850341796875,
      "sbg:y": -1225.8614501953125
    },
    {
      "id": "idr_ppr",
      "in": [
        {
          "id": "in_peak1",
          "source": "call_peak_ppr1/out_peak"
        },
        {
          "id": "in_peak2",
          "source": "call_peak_ppr2/out_peak"
        },
        {
          "id": "in_peak_pooled",
          "source": "call_peak_pooled_replicates/out_peak"
        },
        {
          "id": "in_blacklist",
          "source": "in_intervals"
        },
        {
          "id": "in_ta",
          "source": "pool_ta_bio_replicates/out_ta_pooled"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        },
        {
          "id": "fraglen",
          "source": "rounded_mean/out_rounded_mean"
        },
        {
          "id": "pipeline_type",
          "source": "pipeline_type"
        }
      ],
      "out": [
        {
          "id": "out_idr_peak"
        },
        {
          "id": "out_bfilt_idr_peak"
        },
        {
          "id": "out_bfilt_idr_peak_bb"
        },
        {
          "id": "out_bfilt_idr_peak_starch"
        },
        {
          "id": "out_bfilt_idr_peak_hammock"
        },
        {
          "id": "idr_plot"
        },
        {
          "id": "idr_unthresholded_peak"
        },
        {
          "id": "idr_log"
        },
        {
          "id": "frip_qc"
        },
        {
          "id": "bfilt_idr_peak_hammock_tbi"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-idr-1-7-1-cwl1-1/2",
        "baseCommand": [],
        "inputs": [
          {
            "id": "prefix",
            "type": "string?",
            "label": "Prefix for IDR output file",
            "doc": "Prefix for IDR output file."
          },
          {
            "id": "in_peak1",
            "type": "File?",
            "label": "Peak file 1",
            "doc": "Peak file 1.",
            "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ"
          },
          {
            "id": "in_peak2",
            "type": "File?",
            "label": "Peak file 2",
            "doc": "Peak file 2.",
            "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ"
          },
          {
            "id": "in_peak_pooled",
            "type": "File?",
            "label": "NARROWPEAK file for pooled true replicate",
            "doc": "NARROWPEAK file for pooled true replicate. Define if you want to start pipeline from PEAK files. Define if you have multiple biological replicates. Pooled true replicate means analysis on pooled biological replicates.",
            "sbg:fileTypes": "NARROWPEAK.GZ, REGIONPEAK.GZ"
          },
          {
            "sbg:toolDefaultValue": "0.05",
            "id": "idr_thresh",
            "type": "float?",
            "label": "IDR threshold",
            "doc": "IDR threshold.",
            "default": 0.05
          },
          {
            "id": "in_blacklist",
            "type": "File?",
            "label": "Blacklist",
            "doc": "Blacklist file in BED format. Peaks will be filtered with this file.",
            "sbg:fileTypes": "BED"
          },
          {
            "id": "regex_bfilt_peak_chr_name",
            "type": "string?",
            "label": "Reg-ex for chromosomes",
            "doc": "Reg-ex for chromosomes to keep while filtering peaks. Chromosomes defined here will be kept. All other chromosomes will be filtered out in .bfilt. peak file. This is done along with blacklist filtering peak file. For example: chr[\\dXY]+.",
            "default": "chr[\\dXY]+"
          },
          {
            "id": "in_ta",
            "type": "File?",
            "label": "Tag-Align",
            "doc": "Output of Encode Bam2ta tool. TAG-ALIGN is in a 6-col BED format. It is a simplified version of BAM.",
            "sbg:fileTypes": "TAGALIGN.GZ"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          },
          {
            "sbg:toolDefaultValue": "narrowPeak",
            "id": "peak_type",
            "type": "string?",
            "label": "Peak type",
            "doc": "Peak type {narrowPeak,regionPeak}. Default: narrowPeak."
          },
          {
            "sbg:toolDefaultValue": "p.value",
            "id": "rank",
            "type": "string?",
            "label": "IDR ranking method",
            "doc": "if peak_caller_=='spp' then 'signal.value' else if peak_caller_=='macs2' then 'p.value' else 'p.value'"
          },
          {
            "id": "fraglen",
            "type": "int?",
            "label": "Fragment length from xcor",
            "doc": "Fragment length from xcor."
          },
          {
            "sbg:toolDefaultValue": "tf",
            "id": "pipeline_type",
            "type": [
              "null",
              {
                "type": "enum",
                "symbols": [
                  "tf",
                  "histone",
                  "control"
                ],
                "name": "pipeline_type"
              }
            ],
            "label": "Pipeline type",
            "doc": "Pipeline {tf, histone, control}. Default: tf."
          }
        ],
        "outputs": [
          {
            "id": "out_idr_peak",
            "doc": "IDR peak.",
            "label": "IDR peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*[!.][!b][!f][!i][!l][!t].' + peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n   if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n   }\n    \n}"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_bfilt_idr_peak",
            "doc": "Blacklist-filtered IDR peak.",
            "label": "Blacklist-filtered IDR peak",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.gz'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n   }\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_bfilt_idr_peak_bb",
            "doc": "Blacklist-filtered IDR peak (BigBed).",
            "label": "Blacklist-filtered IDR peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.bb'\n    }\n}",
              "outputEval": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        (inheritMetadata(self, inputs.in_peak1))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']='';\n        return self_list[0];\n   }\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.BB"
          },
          {
            "id": "out_bfilt_idr_peak_starch",
            "doc": "Blacklist-filtered IDR peak (starch).",
            "label": "Blacklist-filtered IDR peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n   if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.starch'\n   }\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.STARCH"
          },
          {
            "id": "out_bfilt_idr_peak_hammock",
            "doc": "Blacklist-filtered IDR peak (hammock).",
            "label": "Blacklist-filtered IDR peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if(inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.hammock.gz*'\n    }\n}",
              "outputEval": "${\n    return self[0];\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ"
          },
          {
            "id": "idr_plot",
            "doc": "IDR plot.",
            "label": "IDR plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.txt.png"
            },
            "sbg:fileTypes": "PNG"
          },
          {
            "id": "idr_unthresholded_peak",
            "doc": "Unthresholded raw IDR peak.",
            "label": "Unthresholded raw IDR peak",
            "type": "File?",
            "outputBinding": {
              "glob": "*.txt.gz"
            },
            "sbg:fileTypes": "TXT.GZ"
          },
          {
            "id": "idr_log",
            "doc": "IDR log.",
            "label": "IDR log",
            "type": "File?",
            "outputBinding": {
              "glob": "*.idr*.log"
            },
            "sbg:fileTypes": "LOG"
          },
          {
            "id": "frip_qc",
            "doc": "Fraction of IDR peaks in reads.",
            "label": "Fraction of IDR peaks in reads",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_ta) return '*.frip.qc';\n    else return '';\n\n}"
            },
            "sbg:fileTypes": "FRIP.QC"
          },
          {
            "id": "bfilt_idr_peak_hammock_tbi",
            "doc": "Blacklist-filtered IDR peak (hammock tbi).",
            "label": "Blacklist-filtered IDR peak (hammock tbi)",
            "type": "File?",
            "outputBinding": {
              "glob": "${\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        return '*.bfilt.' + peak_type + '.hammock.gz*'\n    }\n}",
              "outputEval": "${\n    return self[1]\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ.TBI"
          }
        ],
        "doc": "**Idr** tool is based on the \u201cidr\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC. **Idr** compares a pair of ranked lists of regions/peaks and assigns values that reflect its reproducibility.\n\nThe basic idea is that if two replicates measure the same underlying biology, the most significant peaks, which are likely to be genuine signals, are expected to have high consistency between replicates, whereas peaks with low significance, which are more likely to be noise, are expected to have low consistency. If the consistency between a pair of rank lists (peaks) that contains both significant and insignificant findings is plotted, a transition in consistency is expected. This consistency transition provides an internal indicator of the change from signal to noise and suggests how many peaks have been reliably detected.\n\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Idr CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    \n    var cmd='';\n    if (inputs.in_peak1 && inputs.in_peak2 && inputs.in_peak_pooled && inputs.pipeline_type=='tf'){\n        if (inputs.in_ta) cmd+='touch null &&';\n        else cmd+='touch null.frip.qc && touch null &&';\n        cmd+=' python3 $(which encode_task_idr.py) ';\n        cmd+=inputs.in_peak1.path;\n        cmd+=' '+inputs.in_peak2.path;\n        cmd+=' '+inputs.in_peak_pooled.path;\n        if (inputs.prefix) cmd+=' --prefix '+inputs.prefix;\n        if (inputs.idr_thresh) cmd+=' --idr-thresh '+inputs.idr_thresh;\n        \n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.');\n        var peak_type=peak[peak.length-1];\n        cmd+=' --peak-type '+peak_type;\n        \n        var peak=inputs.in_peak1.basename.replace('.gz','').split('.');\n        var peak_type=peak[peak.length-1];\n        var rank='';\n        if(peak_type=='narrowPeak') rank='p.value';\n        else if (peak_type=='regionPeak') rank='signal.value'\n        cmd+=' --idr-rank '+rank;\n        if(inputs.fraglen) cmd+=' --fraglen '+inputs.fraglen;\n        if(inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.in_blacklist) cmd+=' --blacklist '+inputs.in_blacklist.path;\n        if(inputs.regex_bfilt_peak_chr_name) cmd+=\" --regex-bfilt-peak-chr-name '\" + inputs.regex_bfilt_peak_chr_name + \"'\";\n        \n        if(inputs.in_ta) cmd+=' --ta '+inputs.in_ta.path;\n        \n        \n    }\n    else cmd=\"echo \\' Idr disabled\\' 1>&2 \";\n    \n    return cmd;\n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619258985,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259043,
            "sbg:revisionNotes": "from dev"
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259251,
            "sbg:revisionNotes": "name updated"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:license": "MIT",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-ee19ee29/h-2ee10f19/h-92f7e1d5/0",
        "sbg:revision": 2,
        "sbg:revisionNotes": "name updated",
        "sbg:modifiedOn": 1619259251,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619258985,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 2,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "abb309e151e61cc2ec19ec3d6628763e6f65b098fbd4fe4f50a1a0cbc9e2aaa93"
      },
      "label": "Idr PPR",
      "sbg:x": -447.1009826660156,
      "sbg:y": -998.201904296875
    },
    {
      "id": "reproducibility_overlap",
      "in": [
        {
          "id": "prefix",
          "default": "overlap"
        },
        {
          "id": "in_peaks",
          "source": [
            "overlap_bio_replicates/out_bfilt_overlap_peak"
          ]
        },
        {
          "id": "in_peaks_pr",
          "source": [
            "overlap_pr/out_bfilt_overlap_peak"
          ]
        },
        {
          "id": "in_peak_ppr",
          "source": "overlap_ppr/out_bfilt_overlap_peak"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        }
      ],
      "out": [
        {
          "id": "out_optimal_peak"
        },
        {
          "id": "out_optimal_peak_bb"
        },
        {
          "id": "out_optimal_peak_starch"
        },
        {
          "id": "out_optimal_peak_hammock"
        },
        {
          "id": "out_optimal_peak_hammock_tbi"
        },
        {
          "id": "out_conservative_peak"
        },
        {
          "id": "out_conservative_peak_bb"
        },
        {
          "id": "out_conservative_peak_starch"
        },
        {
          "id": "out_conservative_peak_hammock"
        },
        {
          "id": "out_conservative_peak_hammock_tbi"
        },
        {
          "id": "reproducibility_qc"
        },
        {
          "id": "peak_region_size_qc"
        },
        {
          "id": "peak_region_size_plot"
        },
        {
          "id": "num_peak_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-reproducibility-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "prefix",
            "type": "string?",
            "label": "Prefix",
            "doc": "Basename prefix for reproducibility QC file."
          },
          {
            "id": "in_peaks",
            "type": "File[]?",
            "label": "Peaks",
            "doc": "List of peak files from true replicates in a sorted order. For example of 4 true replicates, 0,1 0,2 0,3 1,2 1,3 2,3. x,y means peak file from rep-x vs rep-y.",
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "in_peaks_pr",
            "type": "File[]?",
            "label": "Peak files from pseudo replicates",
            "doc": "Peak files from pseudo replicates.",
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "in_peak_ppr",
            "type": "File?",
            "label": "Peak file from pooled pseudo replicate",
            "doc": "Peak file from pooled pseudo replicate.",
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          }
        ],
        "outputs": [
          {
            "id": "out_optimal_peak",
            "doc": "Optimal peak.",
            "label": "Optimal peak",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.gz",
              "outputEval": "${\n   if(inputs.in_peaks && inputs.in_peaks[0] &&inputs.in_peaks_pr && inputs.in_peaks_pr[0] && inputs.in_peak_ppr){\n        (inheritMetadata(self, inputs.in_peaks))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']=''\n        return self_list[0]\n   }\n    \n}"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_optimal_peak_bb",
            "doc": "Optimal peak (BigBed).",
            "label": "Optimal peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.bb"
            },
            "sbg:fileTypes": "NARROWPEAK.BB"
          },
          {
            "id": "out_optimal_peak_starch",
            "doc": "Optimal peak (starch).",
            "label": "Optimal peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.starch"
            },
            "sbg:fileTypes": "NARROWPEAK.STARCH"
          },
          {
            "id": "out_optimal_peak_hammock",
            "doc": "Optimal peak (hammock).",
            "label": "Optimal peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.hammock.gz*",
              "outputEval": "${\n    return self[0]\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ"
          },
          {
            "id": "out_optimal_peak_hammock_tbi",
            "doc": "Optimal peak (hammock tbi).",
            "label": "Optimal peak (hammock tbi)",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.hammock.gz*",
              "outputEval": "${\n    return self[1]\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ.TBI"
          },
          {
            "id": "out_conservative_peak",
            "doc": "Conservative peak.",
            "label": "Conservative peak",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.gz"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_conservative_peak_bb",
            "doc": "Conservative peak (BigBed).",
            "label": "Conservative peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.bb"
            },
            "sbg:fileTypes": "NARROWPEAK.BB"
          },
          {
            "id": "out_conservative_peak_starch",
            "doc": "Conservative peak (starch).",
            "label": "Conservative peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.starch"
            },
            "sbg:fileTypes": "NARROWPEAK.STARCH"
          },
          {
            "id": "out_conservative_peak_hammock",
            "doc": "Conservative peak (hammock).",
            "label": "Conservative peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.hammock.gz*",
              "outputEval": "${\n    return self[0]\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ"
          },
          {
            "id": "out_conservative_peak_hammock_tbi",
            "doc": "Conservative peak (hammock tbi).",
            "label": "Conservative peak (hammock tbi)",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.hammock.gz*",
              "outputEval": "${\n    return self[1];\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ.TBI"
          },
          {
            "id": "reproducibility_qc",
            "doc": "Reproducibility QC for overlap peaks.",
            "label": "Reproducibility QC for overlap peaks",
            "type": "File?",
            "outputBinding": {
              "glob": "*reproducibility.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "peak_region_size_qc",
            "doc": "Peak region size QC.",
            "label": "Peak region size QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "peak_region_size_plot",
            "doc": "Peak region size plot.",
            "label": "Peak region size plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.png"
            },
            "sbg:fileTypes": "PNG"
          },
          {
            "id": "num_peak_qc",
            "doc": "Num peak QC.",
            "label": "Num peak QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.num_peak.qc"
            },
            "sbg:fileTypes": "QC"
          }
        ],
        "doc": "**Reproducibility** tool is based on the \u201creproducibility\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n\nAs with any high-throughput experiment, a single assay is often subject to a substantial amount of variability. Thus, it is highly recommended to setup experimental design with a minimum of 2-3 biological replicates. Presumably, two replicates measuring the same underlying biology should have high consistency but that is not always the case. In order to evaluate consistency between replicates we require metrics that objectively assess the reproducibility of high-throughput assays.\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Reproducibility CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    \n    var cmd='';\n    if (inputs.in_peaks && inputs.in_peaks[0] &&inputs.in_peaks_pr && inputs.in_peaks_pr[0] && inputs.in_peak_ppr){\n        cmd+='python3 $(which encode_task_reproducibility.py) ';\n        var peaks_list=[].concat(inputs.in_peaks);\n        var peaks=Array();\n        for(var i=0; i<peaks_list.length; i++){\n            if(peaks_list[i]) peaks.push(peaks_list[i].path);\n        }\n        peaks=peaks.join(' ');\n        cmd+=peaks;\n        \n        var pr_list=[].concat(inputs.in_peaks_pr);\n        var pr=Array();\n        for(var i=0; i<pr_list.length; i++){\n            if(pr_list[i]) pr.push(pr_list[i].path);\n        }\n        pr=pr.join(' ');\n        cmd+=' --peaks-pr '+pr;\n        \n        cmd+=' --peak-ppr '+inputs.in_peak_ppr.path;\n        \n        var in_peak1=[].concat(inputs.in_peaks)\n        var peak=in_peak1[0].basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        cmd+=' --peak-type '+peak_type;\n        if (inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.prefix)cmd+=' --prefix '+inputs.prefix;\n        \n        \n        \n    }\n    else cmd=\"echo \\' No inputs provided\\' 1>&2\";\n    \n    \n    return cmd\n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259099,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259205,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-f7c96f2c/h-6df0bc12/h-c2ce9f5e/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619259205,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619259099,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a14bff9868599cec0e0f37cbdb1039d7ff4d31a485d26bea10393cd182842ec23"
      },
      "label": "Reproducibility Overlap",
      "sbg:x": 95.28926849365234,
      "sbg:y": -2146.867431640625
    },
    {
      "id": "reproducibility_idr",
      "in": [
        {
          "id": "prefix",
          "default": "idr"
        },
        {
          "id": "in_peaks",
          "source": [
            "idr_bio_replicates/out_bfilt_idr_peak"
          ]
        },
        {
          "id": "in_peaks_pr",
          "source": [
            "idr_pr/out_bfilt_idr_peak"
          ]
        },
        {
          "id": "in_peak_ppr",
          "source": "idr_ppr/out_bfilt_idr_peak"
        },
        {
          "id": "in_chrsz",
          "source": "in_chrsz"
        }
      ],
      "out": [
        {
          "id": "out_optimal_peak"
        },
        {
          "id": "out_optimal_peak_bb"
        },
        {
          "id": "out_optimal_peak_starch"
        },
        {
          "id": "out_optimal_peak_hammock"
        },
        {
          "id": "out_optimal_peak_hammock_tbi"
        },
        {
          "id": "out_conservative_peak"
        },
        {
          "id": "out_conservative_peak_bb"
        },
        {
          "id": "out_conservative_peak_starch"
        },
        {
          "id": "out_conservative_peak_hammock"
        },
        {
          "id": "out_conservative_peak_hammock_tbi"
        },
        {
          "id": "reproducibility_qc"
        },
        {
          "id": "peak_region_size_qc"
        },
        {
          "id": "peak_region_size_plot"
        },
        {
          "id": "num_peak_qc"
        }
      ],
      "run": {
        "class": "CommandLineTool",
        "cwlVersion": "v1.1",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "id": "jovana_babic/encode-chip-seq-2-demo/encode-chip-seq-reproducibility-1-7-1-cwl1-1/1",
        "baseCommand": [],
        "inputs": [
          {
            "id": "prefix",
            "type": "string?",
            "label": "Prefix",
            "doc": "Basename prefix for reproducibility QC file."
          },
          {
            "id": "in_peaks",
            "type": "File[]?",
            "label": "Peaks",
            "doc": "List of peak files from true replicates in a sorted order. For example of 4 true replicates, 0,1 0,2 0,3 1,2 1,3 2,3. x,y means peak file from rep-x vs rep-y.",
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "in_peaks_pr",
            "type": "File[]?",
            "label": "Peak files from pseudo replicates",
            "doc": "Peak files from pseudo replicates.",
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "in_peak_ppr",
            "type": "File?",
            "label": "Peak file from pooled pseudo replicate",
            "doc": "Peak file from pooled pseudo replicate.",
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "in_chrsz",
            "type": "File?",
            "label": "Chrsz",
            "doc": "2-col chromosome sizes file.",
            "sbg:fileTypes": "TSV"
          }
        ],
        "outputs": [
          {
            "id": "out_optimal_peak",
            "doc": "Optimal peak.",
            "label": "Optimal peak",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.gz",
              "outputEval": "${\n   if(inputs.in_peaks && inputs.in_peaks[0] &&inputs.in_peaks_pr && inputs.in_peaks_pr[0] && inputs.in_peak_ppr){\n        (inheritMetadata(self, inputs.in_peaks))\n        var self_list=[].concat(self)\n        self_list[0].metadata['sample_id']=''\n        return self_list[0]\n   }\n    \n}"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_optimal_peak_bb",
            "doc": "Optimal peak (BigBed).",
            "label": "Optimal peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.bb"
            },
            "sbg:fileTypes": "NARROWPEAK.BB"
          },
          {
            "id": "out_optimal_peak_starch",
            "doc": "Optimal peak (starch).",
            "label": "Optimal peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.starch"
            },
            "sbg:fileTypes": "NARROWPEAK.STARCH"
          },
          {
            "id": "out_optimal_peak_hammock",
            "doc": "Optimal peak (hammock).",
            "label": "Optimal peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.hammock.gz*",
              "outputEval": "${\n    return self[0]\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ"
          },
          {
            "id": "out_optimal_peak_hammock_tbi",
            "doc": "Optimal peak (hammock tbi).",
            "label": "Optimal peak (hammock tbi)",
            "type": "File?",
            "outputBinding": {
              "glob": "*optimal_peak.*.hammock.gz*",
              "outputEval": "${\n    return self[1]\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ.TBI"
          },
          {
            "id": "out_conservative_peak",
            "doc": "Conservative peak.",
            "label": "Conservative peak",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.gz"
            },
            "sbg:fileTypes": "NARROWPEAK.GZ"
          },
          {
            "id": "out_conservative_peak_bb",
            "doc": "Conservative peak (BigBed).",
            "label": "Conservative peak (BigBed)",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.bb"
            },
            "sbg:fileTypes": "NARROWPEAK.BB"
          },
          {
            "id": "out_conservative_peak_starch",
            "doc": "Conservative peak (starch).",
            "label": "Conservative peak (starch)",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.starch"
            },
            "sbg:fileTypes": "NARROWPEAK.STARCH"
          },
          {
            "id": "out_conservative_peak_hammock",
            "doc": "Conservative peak (hammock).",
            "label": "Conservative peak (hammock)",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.hammock.gz*",
              "outputEval": "${\n    return self[0]\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ"
          },
          {
            "id": "out_conservative_peak_hammock_tbi",
            "doc": "Conservative peak (hammock tbi).",
            "label": "Conservative peak (hammock tbi)",
            "type": "File?",
            "outputBinding": {
              "glob": "*conservative_peak.*.hammock.gz*",
              "outputEval": "${\n    return self[1];\n}"
            },
            "sbg:fileTypes": "NARROWPEAK.HAMMOCK.GZ.TBI"
          },
          {
            "id": "reproducibility_qc",
            "doc": "Reproducibility QC for overlap peaks.",
            "label": "Reproducibility QC for overlap peaks",
            "type": "File?",
            "outputBinding": {
              "glob": "*reproducibility.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "peak_region_size_qc",
            "doc": "Peak region size QC.",
            "label": "Peak region size QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.qc"
            },
            "sbg:fileTypes": "QC"
          },
          {
            "id": "peak_region_size_plot",
            "doc": "Peak region size plot.",
            "label": "Peak region size plot",
            "type": "File?",
            "outputBinding": {
              "glob": "*.peak_region_size.png"
            },
            "sbg:fileTypes": "PNG"
          },
          {
            "id": "num_peak_qc",
            "doc": "Num peak QC.",
            "label": "Num peak QC",
            "type": "File?",
            "outputBinding": {
              "glob": "*.num_peak.qc"
            },
            "sbg:fileTypes": "QC"
          }
        ],
        "doc": "**Reproducibility** tool is based on the \u201creproducibility\u201d WDL task from the ChIP-Seq pipeline, developed by ENCODE DCC.\n\nAs with any high-throughput experiment, a single assay is often subject to a substantial amount of variability. Thus, it is highly recommended to setup experimental design with a minimum of 2-3 biological replicates. Presumably, two replicates measuring the same underlying biology should have high consistency but that is not always the case. In order to evaluate consistency between replicates we require metrics that objectively assess the reproducibility of high-throughput assays.\n\n\n***A list of all inputs and parameters with corresponding descriptions can be found at the bottom of this page.***",
        "label": "ENCODE ChIP-Seq Reproducibility CWL1.1",
        "arguments": [
          {
            "prefix": "",
            "shellQuote": false,
            "position": 0,
            "valueFrom": "${\n    \n    var cmd='';\n    if (inputs.in_peaks && inputs.in_peaks[0] &&inputs.in_peaks_pr && inputs.in_peaks_pr[0] && inputs.in_peak_ppr){\n        cmd+='python3 $(which encode_task_reproducibility.py) ';\n        var peaks_list=[].concat(inputs.in_peaks);\n        var peaks=Array();\n        for(var i=0; i<peaks_list.length; i++){\n            if(peaks_list[i]) peaks.push(peaks_list[i].path);\n        }\n        peaks=peaks.join(' ');\n        cmd+=peaks;\n        \n        var pr_list=[].concat(inputs.in_peaks_pr);\n        var pr=Array();\n        for(var i=0; i<pr_list.length; i++){\n            if(pr_list[i]) pr.push(pr_list[i].path);\n        }\n        pr=pr.join(' ');\n        cmd+=' --peaks-pr '+pr;\n        \n        cmd+=' --peak-ppr '+inputs.in_peak_ppr.path;\n        \n        var in_peak1=[].concat(inputs.in_peaks)\n        var peak=in_peak1[0].basename.replace('.gz','').split('.')\n        var peak_type=peak[peak.length-1]\n        cmd+=' --peak-type '+peak_type;\n        if (inputs.in_chrsz) cmd+=' --chrsz '+inputs.in_chrsz.path;\n        if(inputs.prefix)cmd+=' --prefix '+inputs.prefix;\n        \n        \n        \n    }\n    else cmd=\"echo \\' No inputs provided\\' 1>&2\";\n    \n    \n    return cmd\n    \n}"
          }
        ],
        "requirements": [
          {
            "class": "ShellCommandRequirement"
          },
          {
            "class": "ResourceRequirement",
            "ramMin": "${\n    return 4000;\n}",
            "coresMin": "${\n    return 1;\n}"
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ana_stankovic/chip-seq-pipeline-1-7-1:0"
          },
          {
            "class": "InlineJavascriptRequirement",
            "expressionLib": [
              "\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file)) {\n        file['metadata'] = {}\n    }\n    for (var key in metadata) {\n        file['metadata'][key] = metadata[key];\n    }\n    return file\n};\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!o2) {\n        return o1;\n    };\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n        for (var key in commonMetadata) {\n            if (!(key in example)) {\n                delete commonMetadata[key]\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n        if (o1.secondaryFiles) {\n            o1.secondaryFiles = inheritMetadata(o1.secondaryFiles, o2)\n        }\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n            if (o1[i].secondaryFiles) {\n                o1[i].secondaryFiles = inheritMetadata(o1[i].secondaryFiles, o2)\n            }\n        }\n    }\n    return o1;\n};"
            ]
          }
        ],
        "sbg:projectName": "ENCODE ChIP-Seq 2 - Demo",
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259099,
            "sbg:revisionNotes": null
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "jovana_babic",
            "sbg:modifiedOn": 1619259205,
            "sbg:revisionNotes": "from dev"
          }
        ],
        "sbg:image_url": null,
        "sbg:toolkit": "ENCODE ChIP-Seq",
        "sbg:toolkitVersion": "v1.7.1",
        "sbg:categories": [
          "ChIP-Seq"
        ],
        "sbg:license": "MIT",
        "sbg:links": [
          {
            "id": "https://www.encodeproject.org/chip-seq/histone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
            "label": "Documentation"
          }
        ],
        "sbg:toolAuthor": "ENCODE-DCC",
        "sbg:appVersion": [
          "v1.1"
        ],
        "sbg:id": "h-5d5a9604/h-73892913/h-1535aa45/0",
        "sbg:revision": 1,
        "sbg:revisionNotes": "from dev",
        "sbg:modifiedOn": 1619259205,
        "sbg:modifiedBy": "jovana_babic",
        "sbg:createdOn": 1619259099,
        "sbg:createdBy": "jovana_babic",
        "sbg:project": "jovana_babic/encode-chip-seq-2-demo",
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:contributors": [
          "jovana_babic"
        ],
        "sbg:latestRevision": 1,
        "sbg:publisher": "sbg",
        "sbg:content_hash": "a14bff9868599cec0e0f37cbdb1039d7ff4d31a485d26bea10393cd182842ec23"
      },
      "label": "Reproducibility Idr",
      "sbg:x": 83.46283721923828,
      "sbg:y": -1786.3548583984375
    }
  ],
  "hints": [
    {
      "class": "sbg:maxNumberOfParallelInstances",
      "value": "2"
    }
  ],
  "requirements": [
    {
      "class": "ScatterFeatureRequirement"
    },
    {
      "class": "InlineJavascriptRequirement"
    },
    {
      "class": "StepInputExpressionRequirement"
    }
  ],
  "sbg:projectName": "BCO-CWL Examples",
  "sbg:revisionsInfo": [
    {
      "sbg:revision": 0,
      "sbg:modifiedBy": "phil_webster",
      "sbg:modifiedOn": 1676561927,
      "sbg:revisionNotes": "Copy of admin/sbg-public-data/encode-chip-seq-pipeline-2/8"
    }
  ],
  "sbg:image_url": "https://cgc.sbgenomics.com/ns/brood/images/phil_webster/bco-cwl-examples/encode-chip-seq-pipeline-2/0.png",
  "sbg:links": [
    {
      "id": "https://www.encodeproject.org/chip-seq/histone/",
      "label": "Homepage"
    },
    {
      "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2/blob/master/chip.wdl#L2568",
      "label": "Source Code"
    },
    {
      "id": "https://github.com/ENCODE-DCC/chip-seq-pipeline2",
      "label": "Documentation"
    }
  ],
  "sbg:categories": [
    "Epigenetics",
    "ChIP-Seq"
  ],
  "sbg:license": "MIT",
  "sbg:expand_workflow": false,
  "sbg:appVersion": [
    "v1.1"
  ],
  "id": "https://cgc-api.sbgenomics.com/v2/apps/phil_webster/bco-cwl-examples/encode-chip-seq-pipeline-2/0/raw/",
  "sbg:id": "phil_webster/bco-cwl-examples/encode-chip-seq-pipeline-2/0",
  "sbg:revision": 0,
  "sbg:revisionNotes": "Copy of admin/sbg-public-data/encode-chip-seq-pipeline-2/8",
  "sbg:modifiedOn": 1676561927,
  "sbg:modifiedBy": "phil_webster",
  "sbg:createdOn": 1676561927,
  "sbg:createdBy": "phil_webster",
  "sbg:project": "phil_webster/bco-cwl-examples",
  "sbg:sbgMaintained": false,
  "sbg:validationErrors": [],
  "sbg:contributors": [
    "phil_webster"
  ],
  "sbg:latestRevision": 0,
  "sbg:publisher": "sbg",
  "sbg:content_hash": "a8c7a9fb204e7a3b50efe5e83a384b9c1e45004b3569dce9e16274bc066b251fb",
  "sbg:workflowLanguage": "CWL",
  "sbg:copyOf": "admin/sbg-public-data/encode-chip-seq-pipeline-2/8"
}